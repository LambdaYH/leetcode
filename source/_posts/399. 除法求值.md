---
title: 399. é™¤æ³•æ±‚å€¼
date: 2021-07-14 17:16:37 +0800
categories: leetcode
tags: Union Find

---

#### [399. é™¤æ³•æ±‚å€¼]([399. é™¤æ³•æ±‚å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/evaluate-division/))



ç›´æ¥çœ‹[è§£æ]([ğŸ¦ 399. é™¤æ³•æ±‚å€¼ - é™¤æ³•æ±‚å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/))

```c++
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string, int> map;
        UnionFind uf(equations.size() * 2);
        int id = 0;
        for(int i = 0; i < equations.size(); ++i)
        {
            auto a = equations[i][0];
            auto b = equations[i][1];
            if(map.emplace(a, id).second)
                ++id;
            if(map.emplace(b, id).second)
                ++id;
            
            uf.doUnion(map[a], map[b], values[i]);
        }
        vector<double> ret;
        for(auto& query : queries)
        {
            if(map.find(query[0]) != map.end() && map.find(query[1]) != map.end())
                // mapå¦‚æœå…¶ä¸­ä¸åŒ…å«å€¼ä¼šåˆå§‹åŒ–ä¸º0ï¼Œå› æ­¤è¿™é‡Œéœ€è¦å…ˆåˆ¤æ–­
                ret.push_back(uf.isConnect(map[query[0]], map[query[1]]));
            else
                ret.push_back(-1.0);
        }
        return ret;
    }
private:
    class UnionFind {
        public:
            UnionFind(int size) : parent(vector<int>(size)), weights(vector<double>(size, 1.0))
            {
                for(int i = 0; i < size; ++i)
                    parent[i] = i;
            }
			// å½’å¹¶ï¼Œå¦‚æœå·²ç»è¿æ¥äº†ï¼Œé‚£å°±ç®—äº†ï¼Œå¦‚æœæ²¡æœ‰è¿æ¥ï¼Œç”±äºä»–ä»¬å‡ºç°åœ¨åŒä¸€å¼ä¸­ï¼Œå› æ­¤å¿…å®šå¯ä»¥å»ºç«‹è¿æ¥ã€‚å¦‚æœä»–ä»¬çš„æ ¹æ²¡æœ‰è¿æ¥é‚£å°±è®¡ç®—ä¸€ä¸‹ç„¶åè¿æ¥ï¼Œåœ¨findæ“ä½œæ—¶ä¼šæ‰§è¡Œè·¯å¾„å‹ç¼©
            void doUnion(int x, int y, double val)
            {
                int rootX = find(x);
                int rootY = find(y);
                if(rootX == rootY)
                    return;
                parent[rootX] = rootY;
                weights[rootX] = weights[y] * val / weights[x];
            }
			// å¦‚æœè¿åœ¨åŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹å°±æ˜¯æœ‰å€¼
            double isConnect(int x, int y)
            {
                int rootX = find(x);
                int rootY = find(y);
                if(rootX == rootY)
                    return weights[x] / weights[y];
                else
                    return -1.0;
            }
        private:
            vector<int> parent;
            vector<double> weights;
        private:
        	// å¯»æ‰¾çˆ¶èŠ‚ç‚¹é¡ºä¾¿è·¯å¾„å‹ç¼©
            int find(int x)
            {
                if(x != parent[x])
                {
                    int ori = parent[x];
                    parent[x] = find(parent[x]);
                    weights[x] *= weights[ori];
                }
                return parent[x];
            }
    };
};
```

