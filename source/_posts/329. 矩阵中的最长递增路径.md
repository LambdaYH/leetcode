---
title: 329. 矩阵中的最长递增路径
date: 2021-11-06 21:40:47 +0800
categories: leetcode
mathjax: false
---
#### [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)


##### 回溯(超时)

```c++
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        for(int i = 0; i < m; ++i)
            for(int j = 0; j < n; ++j)
                backTrack(matrix, i, j, -1, 0);
        return ret;
    }
private:
    int ret = 0;
    void backTrack(vector<vector<int>>& matrix, int i, int j, int pre, int tmp)
    {
        if(i < 0 || j < 0 || i >= matrix.size() || j >= matrix[0].size() || matrix[i][j] <= pre || matrix[i][j] == -1)
            return;
        pre = matrix[i][j];
        ++tmp;
        ret = max(tmp, ret);
        matrix[i][j] = -1;
        backTrack(matrix, i + 1, j, pre, tmp);
        backTrack(matrix, i - 1, j, pre, tmp);
        backTrack(matrix, i, j + 1, pre, tmp);
        backTrack(matrix, i, j - 1, pre, tmp);
        matrix[i][j] = pre;
    }
};
```

优化，记忆化dfs

因为前面走过来的路必然是小于当前的数字的，而接下来可以走的路必然是大于当前数字的，因此不用担心会走回头路。

而对于记忆化来说，不用担心这个记忆化的结果是从那边走来的，只需要知道获取这个记忆化数据的这一格必然大于记忆化的这一格，所以不可能是之前走过的路

```c++
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        memo.resize(m, vector<int>(n));
        int ret = 0;
        for(int i = 0; i < m; ++i)
            for(int j = 0; j < n; ++j)
                ret = max(ret, dfs(matrix, i, j, m, n));
        return ret;
    }
private:
    vector<vector<int>> memo;
    int dir[4][2]{ {1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int dfs(vector<vector<int>>& matrix, int i, int j, int m, int n)
    {
        if(memo[i][j])
            return memo[i][j];
        ++memo[i][j];
        for(int k = 0; k < 4; ++k)
        {
            int nextI = i + dir[k][0], nextJ = j + dir[k][1];
            if(nextI >= 0 && nextI < m && nextJ >= 0 && nextJ < n && matrix[nextI][nextJ] > matrix[i][j])
                memo[i][j] = max(memo[i][j], dfs(matrix, nextI, nextJ, m, n) + 1);
        }
        return memo[i][j];
    }
};
```
