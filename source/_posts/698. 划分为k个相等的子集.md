---
title: 698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†
date: 2022-06-29 21:43:58 +0800
categories: leetcode
tags : Dynamic Programming
---
#### [698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†]([https://leetcode.com/problems/regular-expression-matching/](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/))

å‚è€ƒ[ç»å…¸å›æº¯ç®—æ³•ï¼šé›†åˆåˆ’åˆ†é—®é¢˜ã€Œé‡è¦æ›´æ–° ğŸ”¥ğŸ”¥ğŸ”¥ã€](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/by-lfool-d9o7/)

## çƒæ¥é€‰æ‹©æ¡¶
```c++
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        auto sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % k != 0)
            return false;
        sum /= k;
        // æ’åˆ—ï¼Œä»å¤§åˆ°å°æ’ï¼Œæ˜¯ä¸ºäº†è®©å›æº¯è¿‡ç¨‹æ›´æ—©åœ°è§¦å‘å‰ªææ¡ä»¶ï¼Œè¶Šæ—©å‰ªæï¼Œå‰ªæ‰çš„å°æå°±è¶Šå¤š
        sort(nums.begin(), nums.end(), greater<int>());
        vector<int> buckets(k);
        return helper(nums, buckets, 0, sum);
    }

private:
    bool helper(vector<int> &nums, vector<int> &buckets, int index, int target) {
        // å½“æ‰€æœ‰çƒéƒ½è¢«ç”¨å®Œäº†ï¼Œè¯´æ˜æ‰€æœ‰çƒéƒ½å„ä¸ªæ”¾å…¥æ¡¶ä¸­ï¼Œå¹¶ä¸”ç”±äºbucket + nums[index] > targetçº¦æŸåœ°å­˜åœ¨ï¼Œè¯´æ˜æ‰€æœ‰æ¡¶çš„å’Œéƒ½ä¸ºtargetï¼Œæ‰€ä»¥è¿”å›true
        if(index == nums.size())
            return true;
        // ä¸‹æ ‡ä¸ºindexçš„å°çƒé€‰æ‹©è‡ªå·±è¦å»å“ªä¸ªæ¡¶ã€‚å¯¹æ¡¶è¿›è¡Œéå†ã€‚å¦‚æœä¸€ä¸ªæ¡¶éƒ½å®¹ä¸ä¸‹ä»–äº†ï¼Œå°±å¾—é€’å½’è¿”å›äº†ï¼Œè®©å‰é¢å»ä¿®å¤ã€‚
        for(int i = 0; i < buckets.size(); ++i) {
            auto &bucket = buckets[i];
            // å¦‚æœæ”¾å…¥åçš„å’Œ>targetäº†ï¼Œè¯´æ˜ä¸èƒ½æ”¾
            if(bucket + nums[index] > target)
                continue;
            // å¦‚æœå‰ä¸€ä¸ªæ¡¶çš„å’Œå’Œç°åœ¨çš„æ¡¶ä¸€æ ·ï¼Œç”±äºæ¡¶æœ¬èº«æ˜¯æ²¡æœ‰é¡ºåºæ ‡å·çš„ï¼Œæ‰€ä»¥é€‰æ‹©å‰ä¸€ä¸ªæ¡¶å’Œé€‰æ‹©å½“å‰æ¡¶çš„ç»“æœä¸€æ ·ï¼Œæ‰€ä»¥ä¸ºäº†å‡å°‘æ— ç”¨åŠŸï¼Œè·³è¿‡ã€‚
            if(i > 0 && buckets[i - 1] == bucket)
                continue;
            // ä¸ä¸Šè¿°åŸå› ç›¸åŒï¼Œç¬¬ä¸€ä¸ªçƒå§‹ç»ˆè®©ä»–è¿›ç¬¬ä¸€ä¸ªæ¡¶ï¼Œæ²¡å¿…è¦é‡å¤æ“ä½œã€‚
            if(index == 0 && i > 0)
                break;
            // çƒå…¥æ¡¶
            bucket += nums[index];
            // è®©ä¸‹ä¸€ä¸ªçƒé€‰
            if(helper(nums, buckets, index + 1, target))
                return true;
            // å›æº¯ï¼Œçƒå‡ºæ¡¶
            bucket -= nums[index];
        }
        return false;
    }
};
```

## æ¡¶æ¥é€‰æ‹©çƒ

```c++
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        auto sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % k != 0)
            return false;
        sum /= k;
        // ä»å¤§åˆ°å°æ’ï¼Œæ›´å¿«å‰ªæ
        sort(nums.begin(), nums.end(), greater<int>());
        vector<int> buckets(k);
        return helper(nums, buckets, 0, 0, sum, k - 1);
    }

private:
    // æ¥è®°å½•ä¸€ä¸ªæ¡¶è¢«è£…æ»¡æ—¶å€™ï¼Œæ¥ä¸‹æ¥çš„è·¯èƒ½ä¸èƒ½åˆ°è¾¾ã€‚é˜²æ­¢é‡å¤èµ°è¿™ç§çŠ¶æ€
    unordered_map<int, bool> memo;
    bool helper(vector<int> &nums, vector<int> &buckets, int visited, int index, int target, int cur_level) {
        // å½“æ¡¶å…¨éƒ½è£…äº†ï¼Œé‚£å°±è¯´æ˜èƒ½è£…
        if(cur_level < 0)
            return true;
        // å½“å‰æ¡¶è¢«è£…æ»¡äº†
        if(buckets[cur_level] == target) {
            // çœ‹çœ‹å½“å‰æ¡¶åœ¨è¿™ç§é€‰æ‹©ä¸‹è¢«è£…æ»¡çš„æƒ…å†µä¸‹ï¼Œèƒ½å¦
            auto r = helper(nums, buckets, visited, 0, target, cur_level - 1);
            // è®°å½•å½“å‰çŠ¶æ€ï¼Œå…å¾—åˆ«çš„æ¡¶ä¹Ÿèµ°åˆ°äº†
            memo.emplace(visited, r);
            return r;
        }
        // å¦‚æœå½“å‰çŠ¶æ€èµ°è¿‡ï¼Œç”±äºæ¡¶æ˜¯æ— åºçš„æ‰€ä»¥ç›´æ¥è¿”å›
        if(memo.count(visited))
            return memo.at(visited);
        for(int i = index; i < nums.size(); ++i) {
            // çƒç”¨è¿‡äº†ï¼Œpass
            if((1 << i) & visited)
                continue;
            // æ”¾ä¸ä¸‹è¿™ä¸ªçƒï¼Œpass
            if(buckets[cur_level] + nums[i] > target)
                continue;
            buckets[cur_level] += nums[i];
            visited ^= 1 << i;
            // è®©ä¸‹ä¸€ä¸ªçƒæ¥é€‰ï¼ŒåŒæ—¶ä¹Ÿä¼šæ ¹æ®æƒ…å†µè¿›è¡Œä¸‹ä¸€ä¸ªæ¡¶çš„åˆ¤æ–­
            if(helper(nums, buckets, visited, i + 1, target, cur_level))
                return true;
            buckets[cur_level] -= nums[i];
            visited ^= 1 << i;
            // å¦‚æœä¸‹ä¸€ä¸ªçƒå’Œå½“å‰çƒæ•°å€¼ç›¸åŒï¼Œç”±äºå½“å‰çƒå·²ç»è¿”å›äº†ï¼Œä¸”åŒ…å«äº†ä¸‹ä¸€ä¸ªçƒèƒ½åŒ…å«çš„æ‰€æœ‰æƒ…å†µï¼Œæ‰€ä»¥ç›´æ¥è·³è¿‡ï¼ˆéœ€è¦åœ¨æœ‰åºçš„å‰æä¸‹ï¼‰
            if(i < nums.size() - 1 && nums[i] == nums[i + 1])
                ++i;
        }
        return false;
    }

};
```
