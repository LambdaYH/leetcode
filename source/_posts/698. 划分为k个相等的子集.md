---
title: 698. 划分为k个相等的子集
date: 2022-06-29 21:43:58 +0800
categories: leetcode
tags : Dynamic Programming
---
#### [698. 划分为k个相等的子集]([https://leetcode.com/problems/regular-expression-matching/](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/))

参考[经典回溯算法：集合划分问题「重要更新 🔥🔥🔥」](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/by-lfool-d9o7/)

## 球来选择桶
```c++
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        auto sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % k != 0)
            return false;
        sum /= k;
        // 排列，从大到小排，是为了让回溯过程更早地触发剪枝条件，越早剪枝，剪掉的小枝就越多
        sort(nums.begin(), nums.end(), greater<int>());
        vector<int> buckets(k);
        return helper(nums, buckets, 0, sum);
    }

private:
    bool helper(vector<int> &nums, vector<int> &buckets, int index, int target) {
        // 当所有球都被用完了，说明所有球都各个放入桶中，并且由于bucket + nums[index] > target约束地存在，说明所有桶的和都为target，所以返回true
        if(index == nums.size())
            return true;
        // 下标为index的小球选择自己要去哪个桶。对桶进行遍历。如果一个桶都容不下他了，就得递归返回了，让前面去修复。
        for(int i = 0; i < buckets.size(); ++i) {
            auto &bucket = buckets[i];
            // 如果放入后的和>target了，说明不能放
            if(bucket + nums[index] > target)
                continue;
            // 如果前一个桶的和和现在的桶一样，由于桶本身是没有顺序标号的，所以选择前一个桶和选择当前桶的结果一样，所以为了减少无用功，跳过。
            if(i > 0 && buckets[i - 1] == bucket)
                continue;
            // 与上述原因相同，第一个球始终让他进第一个桶，没必要重复操作。
            if(index == 0 && i > 0)
                break;
            // 球入桶
            bucket += nums[index];
            // 让下一个球选
            if(helper(nums, buckets, index + 1, target))
                return true;
            // 回溯，球出桶
            bucket -= nums[index];
        }
        return false;
    }
};
```
