<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10. Regular Expression Matching</title>
    <url>/2021/05/11/10.%20Regular%20Expression%20Matching/</url>
    <content><![CDATA[<h4 id="regular-expression-matching"><a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a></h4>
<p>题目: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39; where: </span><br><span class="line"></span><br><span class="line">&#39;.&#39; Matches any single character.​​​​</span><br><span class="line">&#39;*&#39; Matches zero or more of the preceding element.</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br></pre></td></tr></table></figure> 这里的'*'表达有些含糊，改为Matches zero or more of the preceding character.较好</p>
<h5 id="递归">递归</h5>
<p>思路：</p>
<p><code>.</code>可以匹配任何字符，因此当遇到了<code>.</code>那就是直接匹配成功，其余状况就是比较字符是否相等即可。<code>*</code>可以匹配之前的元素，0次或多次，当匹配0次的时候，那么就将原text和pattern除去这一匹配0次的模式后的部分再次进行匹配，当匹配一次或多次的时候，就在text中删去匹配成功的部分继续把剩下的和pattern匹配，由于每一都会有这2种抉择，所以采用递归，二者状况其一匹配成功即可。</p>
<p>当pattern为空时，当且仅到s为空才会匹配成功</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span>&amp; p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里if和return的顺序不能对换，因为当且仅当p走完，才表示匹配结束，此时如果也是空串，那么就是匹配成功。</span></span><br><span class="line">        <span class="comment">// 如果对换，当s走完时候，如果p还没走完，但是p后面又可以表示匹配0个，就会导致错误的结果</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= p.size())</span><br><span class="line">            <span class="keyword">return</span> i &gt;= s.size();</span><br><span class="line">        <span class="keyword">bool</span> firstMatch = i &lt; s.size() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= p.size() - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> helper(s, p, i, j + <span class="number">2</span>) || (firstMatch &amp;&amp; helper(s, p, i + <span class="number">1</span>, j));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> firstMatch &amp;&amp; helper(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="top-down-dp">top-down dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span></span><br><span class="line">    UNKNOWN,</span><br><span class="line">    TRUE,</span><br><span class="line">    FALSE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;status&gt;&gt;(s.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;status&gt;(p.size() + <span class="number">1</span>, UNKNOWN));</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;status&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span>  <span class="built_in">string</span>&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != UNKNOWN)</span><br><span class="line">            <span class="keyword">return</span> dp[i][j] == TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= p.size())</span><br><span class="line">                <span class="keyword">return</span> i &gt;= s.size();</span><br><span class="line">            <span class="keyword">bool</span> firstMatch = i &lt; s.size() &amp;&amp; (p[j] == s[i] || p[j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">bool</span> ret;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= p.size() - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                ret = helper(i, j + <span class="number">2</span>, s, p) || (firstMatch &amp;&amp; helper(i + <span class="number">1</span>, j, s, p));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = firstMatch &amp;&amp; helper(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p);</span><br><span class="line">            dp[i][j] = ret ? TRUE : FALSE;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于递归检索过程中会出现许多的交叠，因此自然而然想到避免这种重复，所以通过dp保存起来以供后续读取，其中vector的size全都+1是防止溢出。</p>
<p>而且将substr的工作转为有i,j表示，避免了多次创建string</p>
<p><strong>但是这种仅仅可以避免交叠，top-down，顾名思义，从大往下走，分为一个个小问题从而解决，转而使用bottom-up，一个个小问题进行组合合成大问题</strong></p>
<h5 id="bottom-up-dp">bottom-up dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.size() + <span class="number">1</span>, <span class="literal">false</span>)); <span class="comment">// +1 表示了空</span></span><br><span class="line">        dp[s.size()][p.size()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size(); i &gt;= <span class="number">0</span>; --i) <span class="comment">// s从空串开始匹配，因为对于*a,是可以匹配到空串的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.size() - <span class="number">1</span>; j &gt;=<span class="number">0</span>; --j) <span class="comment">// 这里不用，因为当p为空时候，当且仅当s为空才为真，其他为假，而这种情况已经包含在了base中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> firstMatch = i &lt; s.size() &amp;&amp; (p[j] == <span class="string">&#x27;.&#x27;</span> || p[j] == s[i]);</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>] || (firstMatch &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = firstMatch &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>base为当两者全为空的时候，匹配结果为true。</p>
<p>从后面往前走，当<code>i == 0 &amp;&amp; j == 0</code>时，表示匹配了整个字符串和pattern</p>
<p>如果从前往后，不便于计算下标</p>
<p>然后分解成小问题，对于当前dp[i][j]来说，从递归的思想引过来</p>
<ol type="1">
<li>如果<code>p[j] == '.'</code>或<code>p[j] == s[i]</code>，那么<code>dp[i][j] == dp[i + 1][j + 1]</code>，说明当前匹配可以正常走，结果=除了这个位之后的匹配结果</li>
<li>如果<code>p[j + 1] == '*'</code>，那么`dp[i][j] == dp[i][j + 2] || s[i] == p[j] || p[j] == '.' &amp;&amp;dp[i + 1][j]，这是可以匹配s[i]的0个或多个，当0个时候，这匹配没有生效，所以取后两位继续匹配的结果，当匹配多个，那么p[j]被使用了，结果就是当p[j]匹配成功后，结合后面串的匹配结果得出当前的结果。</li>
<li>当2个长度都只有1个时候，直接比对当前的字母再结合之前的匹配结果。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>100. Same Tree</title>
    <url>/2021/03/23/100-Same-Tree/</url>
    <content><![CDATA[<h4 id="same-tree"><a href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((p &amp;&amp; !q) || (!p &amp;&amp; q))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!p &amp;&amp; !p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val == q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(N) S(n) : O(logN) 当平衡时，O(N) 当不平衡时，<strong>空间为递归所用的stack的大小</strong></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>101. Symmetric Tree</title>
    <url>/2021/04/05/101-Symmetric-Tree/</url>
    <content><![CDATA[<h4 id="symmetric-tree"><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h4>
<h5 id="recursively">recursively</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isTwoTreesSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTwoTreesSymmetric</span><span class="params">(TreeNode* lTree, TreeNode* rTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((!lTree &amp;&amp; rTree) || (!rTree &amp;&amp; lTree))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!lTree &amp;&amp; !rTree)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lTree-&gt;val == rTree-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isTwoTreesSymmetric(lTree-&gt;left, rTree-&gt;right) &amp;&amp; isTwoTreesSymmetric(lTree-&gt;right, rTree-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="iteratively-queue">iteratively queue</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">auto</span> t2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(t1-&gt;left);</span><br><span class="line">            q.push(t2-&gt;right);</span><br><span class="line">            q.push(t1-&gt;right);</span><br><span class="line">            q.push(t2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="iteratively-stack">iteratively stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t1 = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">auto</span> t2 = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(t1-&gt;left);</span><br><span class="line">            s.push(t2-&gt;right);</span><br><span class="line">            s.push(t1-&gt;right);</span><br><span class="line">            s.push(t2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <url>/2021/04/10/102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h4 id="binary-tree-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n = q.size(); i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/04/10/0dbfdf01ef05f.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>还有使用递归，传入层数，对每一层的vector容器加入</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>103. Binary Tree Zigzag Level Order Traversal</title>
    <url>/2021/06/10/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<h4 id="binary-tree-zigzag-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></h4>
<h5 id="使用双向队列每次都变向">使用双向队列，每次都变向</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push_back(root);</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* p;</span><br><span class="line">                <span class="keyword">if</span>(left)</span><br><span class="line">                &#123;</span><br><span class="line">                    p = s.front();</span><br><span class="line">                    s.pop_front();</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                        s.push_back(p-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                       s.push_back(p-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = s.back();</span><br><span class="line">                    s.pop_back();</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                        s.push_front(p-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                       s.push_front(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            left = !left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <url>/2021/04/09/104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h4 id="maximum-depth-of-binary-tree"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> tmp&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        backTrack(root, depth, tmp);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth, <span class="keyword">int</span>&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        ++tmp;</span><br><span class="line">        depth = max(depth, tmp);</span><br><span class="line">        backTrack(root-&gt;left, depth, tmp);</span><br><span class="line">        backTrack(root-&gt;right, depth, tmp);</span><br><span class="line">        --tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left) + <span class="number">1</span>, maxDepth(root-&gt;right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>待优化空间占用</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/04/11/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
    <content><![CDATA[<h4 id="construct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h4>
<p>太难了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">tree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>&amp; index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = preorder[index++];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = tree(preorder, left, <span class="built_in">map</span>[val] - <span class="number">1</span>, index);</span><br><span class="line">        root-&gt;right = tree(preorder, <span class="built_in">map</span>[val] + <span class="number">1</span>, right, index);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个在preorder中的点在inorder中的左边都是左树，右边是右树</p>
<p>The two key observations are:</p>
<ol type="1">
<li><p>Preorder traversal follows Root -&gt; Left -&gt; Right, therefore, given the preorder array preorder, we have easy access to the root which is preorder[0].</p></li>
<li><p>Inorder traversal follows Left -&gt; Root -&gt; Right, therefore if we know the position of Root, we can recursively split the entire array into two subtrees.</p></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>106. 从中序与后序遍历序列构造二叉树</title>
    <url>/2021/08/11/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="从中序与后序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/11/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal | Cinte's Leetcode Record</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = inorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">            <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> index = sz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="built_in">map</span>, postorder, <span class="number">0</span>, sz - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span>&amp; index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> val = postorder[index--];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;right = build(inorder, postorder, inorder[val] + <span class="number">1</span>, hi, index);</span><br><span class="line">        root-&gt;left = build(inorder, postorder, lo, inorder[val] - <span class="number">1</span>, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>107. 二叉树的层序遍历 II</title>
    <url>/2021/08/11/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II/</url>
    <content><![CDATA[<h4 id="二叉树的层序遍历-ii"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4>
<p>遍历后反转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = q.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sz = ret.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz / <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(ret[i], ret[sz - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2021/06/11/108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h4 id="convert-sorted-array-to-binary-search-tree"><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h4>
<h5 id="直接递归">直接递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node-&gt;left = helper(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = helper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>109. 有序链表转换二叉搜索树</title>
    <url>/2021/08/11/109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="有序链表转换二叉搜索树"><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h4>
<p>转为数组后再转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(nodes, <span class="number">0</span>, nodes.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nodes, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(nodes[mid]);</span><br><span class="line">        node-&gt;left = build(nodes, lo, mid - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = build(nodes, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n) + O(logn)(递归栈)</p>
<h5 id="直接使用链表">直接使用链表</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(ListNode* begin, ListNode* end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果mid的右边没有元素，那是不可能的，因为这说明walker走到了最右边，不可能</span></span><br><span class="line">        <span class="comment">// 如果mid的右边只有一个元素，在下次取右半边时候，由于取mid—&gt;next，则右边会返回nullptr</span></span><br><span class="line">        <span class="comment">// 如果右边两个元素及以上，正常走</span></span><br><span class="line">        <span class="comment">// 如果左边没有元素，则下一回合左边begin==end，返回nullptr</span></span><br><span class="line">        <span class="comment">// 如果左边只有一个，下一回合会取左边那个元素，然后下一回合后的符合上述的情况</span></span><br><span class="line">        <span class="comment">// 如果左边两个元素及以上，正常走</span></span><br><span class="line">        <span class="keyword">if</span>(begin == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = getMid(begin, end);</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(mid-&gt;val);</span><br><span class="line">        node-&gt;left = build(begin, mid);</span><br><span class="line">        <span class="comment">// 重点处理 : 由于当begin和end相邻时会倾向于取begin这个元素，所以为了避免重复取，需要使mid右移一个。</span></span><br><span class="line">        node-&gt;right = build(mid-&gt;next, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 借用链表取下一个元素方便的特性，设置为左闭右开，即无论什么情况下都不可能取到最右边的元素。</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* begin, ListNode* end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* walker = begin;</span><br><span class="line">        ListNode* runner = begin;</span><br><span class="line">        <span class="keyword">while</span>(runner != end &amp;&amp; runner-&gt;next != end)</span><br><span class="line">        &#123;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> walker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn)</p>
<p>S(n) : O(logn)(递归栈)</p>
<h5 id="中序遍历填充">中序遍历+填充</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(head, <span class="number">0</span>, getLength(head) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; head; ++ret, head = head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(ListNode*&amp; head, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        node-&gt;left = build(head, lo, mid - <span class="number">1</span>);</span><br><span class="line">        node-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        node-&gt;right = build(head, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>11. Container With Most Water</title>
    <url>/2021/05/13/11.%20Container%20With%20Most%20Water/</url>
    <content><![CDATA[<h4 id="container-with-most-water"><a href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            maxVal = max(maxVal, (j - i) * min(height[i], height[j]));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])</span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当<code>height[i] &lt; height[j]</code>时，如果不舍弃他而移动右边j，那么结果肯定时小于现在的，所以舍弃i</p>
<p>假设a2,a6为最大，需要证明当left=a2时，右边会移到a6。 即当left=a2,right=a7的下一位时left=a2,left=a6。而这一步必然时height[a2]&gt;height[a7]，若不然，则最小边界为a2，宽度只会减少，则总值减少，所以必定移动a.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1109. 航班预订统计</title>
    <url>/2021/08/30/1109.%20%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="航班预订统计"><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4>
<p>本题的区间上的预定记录可以看做是对这个区间施加的增量</p>
<p>对于一个差分数组，对<code>[l, r]</code>区间施加增量inc后，<code>d[l]</code>增加inc，而<code>d[r + 1]</code>减少inc。</p>
<p>由此便可以通过原预定记录重构出差分数组，最后进行前缀和求值就是所得结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; booking : bookings)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(booking[<span class="number">1</span>] &lt; n)</span><br><span class="line">                ret[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            ret[i] += ret[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/2021/04/09/111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h4 id="minimum-depth-of-binary-tree"><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth&#123; INT_MAX &#125;;</span><br><span class="line">        <span class="keyword">int</span> tmp&#123; <span class="number">1</span> &#125;;</span><br><span class="line">        backTrack(root, depth, tmp);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth, <span class="keyword">int</span>&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = min(depth, tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++tmp;</span><br><span class="line">        backTrack(root-&gt;left, depth, tmp);</span><br><span class="line">        backTrack(root-&gt;right, depth, tmp);</span><br><span class="line">        --tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="bfs">BFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="keyword">auto</span> sz = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <url>/2021/04/18/114-Flatten-Binary-Tree-to-Linked-List/</url>
    <content><![CDATA[<h4 id="flatten-binary-tree-to-linked-list"><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></h4>
<h5 id="我越来越菜了">我越来越菜了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// preorder traversal 是 root -&gt; left -&gt; right</span></span><br><span class="line"> <span class="comment">// 此方法是将左子树插入到root 和 右子树中间。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* now = root; <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点存在左子树，则需要优先遍历</span></span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* pre = now-&gt;left;</span><br><span class="line">                <span class="comment">// 将pre指针移到左子树的右子树的最右端</span></span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使右子树最末端的右边只想原节点的左子树</span></span><br><span class="line">                pre-&gt;right = now-&gt;right;</span><br><span class="line">                <span class="comment">// 将源节点的右边指向左边</span></span><br><span class="line">                now-&gt;right = now-&gt;left;</span><br><span class="line">                <span class="comment">// 上述的操作之后，root的右子树是原来的左子树</span></span><br><span class="line">                now-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到下一个节点，顺序始终是先左后右</span></span><br><span class="line">            now = now-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>太强了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>116. Populating Next Right Pointers in Each Node</title>
    <url>/2021/06/11/116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/</url>
    <content><![CDATA[<h4 id="populating-next-right-pointers-in-each-node"><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h4>
<h5 id="on-space">O(n) space</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = s.size();</span><br><span class="line">            <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = s.front();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p-&gt;next = s.front();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    s.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    s.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="o1-space">o(1) space</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* father = root;</span><br><span class="line">        Node* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(father-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = father;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left-&gt;next = cur-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next)</span><br><span class="line">                    cur-&gt;right-&gt;next = cur-&gt;next-&gt;left;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            father = father-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每层遍历下去，每层从最左边开始，然后操作他的儿子们，当一层没儿子就停止</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle</title>
    <url>/2021/06/11/118.%20Pascal&#39;s%20Triangle/</url>
    <content><![CDATA[<h4 id="pascals-triangle"><a href="https://leetcode.com/problems/pascals-triangle/">118. Pascal's Triangle</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(numRows);</span><br><span class="line">        ret[<span class="number">0</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i].push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                ret[i].push_back(ret[i - <span class="number">1</span>][j - <span class="number">1</span>] + ret[i - <span class="number">1</span>][j]);</span><br><span class="line">            ret[i].push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>12. Integer to Roman</title>
    <url>/2021/03/03/12-Integer-to-Roman/</url>
    <content><![CDATA[<h4 id="integer-to-roman"><a href="https://leetcode.com/problems/integer-to-roman/">12. Integer to Roman</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> roman[]&#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> nums[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = size(nums) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( num &gt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                num -= nums[i];</span><br><span class="line">                result += roman[i];</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>120. Triangle</title>
    <url>/2021/03/31/120-Triangle/</url>
    <content><![CDATA[<h4 id="triangle"><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></h4>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> layer = <span class="number">1</span>; layer &lt; n; ++layer)</span><br><span class="line">        &#123;</span><br><span class="line">            triangle[layer][<span class="number">0</span>] += triangle[layer - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            triangle[layer].back() += triangle[layer - <span class="number">1</span>].back();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; triangle[layer].size() - <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                triangle[layer][i] += min(triangle[layer - <span class="number">1</span>][i], triangle[layer - <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(triangle.back().begin(), triangle.back().end());</span><br><span class="line">        <span class="keyword">return</span> triangle.back().front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n): O(n)</p>
<p>S(n): O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <url>/2021/03/19/121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h4 id="best-time-to-buy-and-sell-stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; prices.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] - minPrice &gt; maxProfit )</span><br><span class="line">            &#123;</span><br><span class="line">                maxProfit = prices[i] - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="kadanes-algorithm"><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98">Kadane’s Algorithm</a></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxCur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSoFar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = prices.begin() + <span class="number">1</span>; i != prices.end(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            maxCur = max(<span class="number">0</span>, (*i - *(i<span class="number">-1</span>)) + maxCur);</span><br><span class="line">            maxSoFar = max(maxCur, maxSoFar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/2021/08/19/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    <content><![CDATA[<h4 id="买卖股票的最佳时机-ii"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4>
<p>如果之前持有股票，那今天可以卖出或者不卖出。卖出后状态变为今天没持有股票。</p>
<p>如果之前没有股票，今天可以买入或不买入，买入就变成了今天持有了股票。</p>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> have = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nothave = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = prices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> price = prices[i];</span><br><span class="line">            have = max(have, nothave - price);</span><br><span class="line">            nothave = max(have + price, nothave);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nothave;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="直接计算所有的上坡贪心">直接计算所有的上坡，贪心</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = prices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; ++i)</span><br><span class="line">            ret += max(prices[i + <span class="number">1</span>] - prices[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <url>/2021/05/09/124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    <content><![CDATA[<h4 id="binary-tree-maximum-path-sum"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h4>
<h5 id="和543.-diameter-of-binary-tree很像">和<a href="https://leetcode.cinte.cc/2021/04/13/543-Diameter-of-Binary-Tree/">543. Diameter of Binary Tree</a>很像</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = INT_MIN;</span><br><span class="line">        helper(root, curMax);</span><br><span class="line">        <span class="keyword">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; curMax)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = helper(node-&gt;left, curMax);</span><br><span class="line">        <span class="keyword">auto</span> right = helper(node-&gt;right, curMax);</span><br><span class="line">        <span class="keyword">auto</span> curSum = (left &lt; <span class="number">0</span> ? <span class="number">0</span> : left) + (right &lt; <span class="number">0</span> ? <span class="number">0</span> :right) + node-&gt;val;</span><br><span class="line">        curMax = max(curSum, curMax);</span><br><span class="line">        <span class="keyword">return</span> max(max(left, right), <span class="number">0</span>) + node-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稍微改改，思想没变，但可以少1次的判断 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = INT_MIN;</span><br><span class="line">        helper(root, curMax);</span><br><span class="line">        <span class="keyword">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; curMax)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = max(helper(node-&gt;left, curMax), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = max(helper(node-&gt;right, curMax), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> curSum = left + right + node-&gt;val;</span><br><span class="line">        curMax = max(curSum, curMax);</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + node-&gt;val;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>125. Valid Palindrome</title>
    <url>/2021/04/01/125-Valid-Palindrome/</url>
    <content><![CDATA[<h4 id="valid-palindrome"><a href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lo = s.begin();</span><br><span class="line">        <span class="keyword">auto</span> hi = s.end() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*lo &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; *lo &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                *lo += <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">if</span>(*hi &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; *hi &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                *hi += <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isDigitalOrAlphabet(*lo))</span><br><span class="line">                ++lo;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isDigitalOrAlphabet(*hi))</span><br><span class="line">                --hi;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(*lo != *hi)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++lo;</span><br><span class="line">                --hi;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigitalOrAlphabet</span><span class="params">(<span class="keyword">char</span>&amp; ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt; <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n): O(n)</p>
<p>S(n): O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence</title>
    <url>/2021/05/06/128.%20Longest%20Consecutive%20Sequence/</url>
    <content><![CDATA[<h4 id="longest-consecutive-sequence"><a href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    ++tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = max(ret, tmp);</span><br><span class="line">                    tmp = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(ret, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn) <br> S(n) : O(1)</p>
<p>排序后，跳过相同的，计算多个子串，如果不相等，就从头开始计算</p>
<h5 id="hash">hash</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(num - <span class="number">1</span>) == <span class="built_in">set</span>.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curNum = num + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">set</span>.find(curNum) != <span class="built_in">set</span>.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    ++curNum;</span><br><span class="line">                    ++tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = max(ret, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用哈希记录每个值，然后找，而且仅仅从连续子串的开头开始，跳过所有的中间量</p>
<p>明明是O(n)为啥比第一个O(nlogn)还慢</p>
<h5 id="discussion">discussion</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>[num]) <span class="comment">// 仅仅对于没建立过路径的数字来建立，因为如果重复建立，会导致结果重复累加</span></span><br><span class="line">            <span class="comment">// 这里的num如果是中间的点的话，更新他不会有什么影响，因为这表示他周围的点已经计算完他们本身为起点或终点的最大长度了，不会重复计算</span></span><br><span class="line">            <span class="comment">// 如果是端点，那也可以更新，总之就是让他不为0。</span></span><br><span class="line">            <span class="comment">// 事实上，这里的map[num]赋值仅仅是为了标记他已经走过，赋任何值都可以</span></span><br><span class="line">                r = max(r, <span class="built_in">map</span>[num] = <span class="built_in">map</span>[num + <span class="built_in">map</span>[num + <span class="number">1</span>]] = <span class="built_in">map</span>[num - <span class="built_in">map</span>[num - <span class="number">1</span>]] = <span class="built_in">map</span>[num - <span class="number">1</span>] + <span class="built_in">map</span>[num + <span class="number">1</span>] + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>对于n，几种情况</p>
<ol type="1">
<li>有一条到n-1的路径，则总长度为len(n-1)+1</li>
<li>有一条n+1到后面的路径，则总长度为len(n+1)+1</li>
<li>都没有，则长度为1</li>
</ol>
<p>对于一条路径来说，比如123456，则对于这条路径的开头和结尾来说，他们的最长长度应该是一样的，给他们赋予同样的值，中间的点会走到，然后会更新值，走过的点就不走了</p>
<p>差不多就是每走到一个点，如果他周围还没有，那就建立一条小路，后面走到中间的后，自然会连接两条小路</p>
<p>对于每个点来说，他都记录以他为起点或者终点的最长路的长度，如果走到的这个点没走到过，那就说明他前面的那条路没有经过现在，必然是反向，于是这个点连接前后，更新始终的值。就仿佛2个水珠的中间滴入一滴水，三者融为一体。</p>
<figure>
<img src="https://image.cinte.cc/2021/06/25/a8841a5b364b0.png" alt="1624605638438.png" /><figcaption aria-hidden="true">1624605638438.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>13. Roman to Integer</title>
    <url>/2021/03/07/13-Roman-to-Integer/</url>
    <content><![CDATA[<h4 id="roman-to-integer"><a href="https://leetcode.com/problems/roman-to-integer/">13. Roman to Integer</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>&#123;&#123;<span class="string">&quot;I&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;IV&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;V&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;IX&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;X&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;XL&quot;</span>, <span class="number">40</span>&#125;, &#123;<span class="string">&quot;L&quot;</span>, <span class="number">50</span>&#125;, &#123;<span class="string">&quot;XC&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;C&quot;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&quot;CD&quot;</span>, <span class="number">400</span>&#125;, &#123;<span class="string">&quot;D&quot;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&quot;CM&quot;</span>, <span class="number">900</span>&#125;, &#123;<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">now</span><span class="params">(<span class="number">1</span>, s[i])</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> num + <span class="built_in">map</span>[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">before</span><span class="params">(<span class="number">1</span>, s[i - <span class="number">1</span>])</span></span>;</span><br><span class="line">            <span class="built_in">string</span> sub = before + now;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(sub) != <span class="built_in">map</span>.end())</span><br><span class="line">            &#123;</span><br><span class="line">                num += <span class="built_in">map</span>[sub];</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num += <span class="built_in">map</span>[now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>130. Surrounded Regions</title>
    <url>/2021/06/13/130.%20Surrounded%20Regions/</url>
    <content><![CDATA[<h4 id="surrounded-regions"><a href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            goNeighbor(board, <span class="number">0</span>, i);</span><br><span class="line">            goNeighbor(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            goNeighbor(board, i, <span class="number">0</span>);</span><br><span class="line">            goNeighbor(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goNeighbor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">            goNeighbor(board, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; board.size() - <span class="number">1</span>)</span><br><span class="line">            goNeighbor(board, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">            goNeighbor(board, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span>)</span><br><span class="line">            goNeighbor(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当且仅当和边界相连的O块区域才可能被表留，而在中间的就全都被覆盖，因此先沿着边界检查，把所有这种O区域改成1表示要保留的，然后把里面剩下的O改成X，1改回O就行了</p>
<h5 id="使用迭代-bfs">使用迭代 BFS?</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; i != <span class="number">0</span> &amp;&amp; j != n - <span class="number">1</span> &amp;&amp; i != m - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> b = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="keyword">int</span> i = b.first;</span><br><span class="line">                    <span class="keyword">int</span> j = b.second;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">1</span>)</span><br><span class="line">                            q.push(<span class="built_in">make_pair</span>(i - <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span>(i &lt; m - <span class="number">2</span>)</span><br><span class="line">                            q.push(<span class="built_in">make_pair</span>(i + <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span>(j &gt; <span class="number">1</span>)</span><br><span class="line">                            q.push(<span class="built_in">make_pair</span>(i, j - <span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; n - <span class="number">2</span>)</span><br><span class="line">                            q.push(<span class="built_in">make_pair</span>(i, j + <span class="number">1</span>));</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于stackoverflow https://leetcode.com/problems/surrounded-regions/discuss/41612/A-really-simple-and-readable-C++-solutionuff0conly-cost-12ms/39811</p>
<p>每个递归调用32B存储空间(1个int)（有待考证），然后250*250<img src="https://image.cinte.cc/2021/06/13/4ed9acece3794.png" alt="1623589017459.png" /></p>
<p>就占用<code>32 * 250 * 250 / 2 = 1000000B = 1M = 栈大小</code></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>131. Palindrome Partitioning</title>
    <url>/2021/04/01/131-Palindrome-Partitioning/</url>
    <content><![CDATA[<h4 id="palindrome-partitioning"><a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        backTrack(ret, temp, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; temp, <span class="built_in">string</span>&amp; s, <span class="keyword">size_t</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; s.size() - <span class="number">1</span>)</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s.substr(start, i - start + <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(s.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">                backTrack(ret, temp, s, i + <span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lo = s.begin();</span><br><span class="line">        <span class="keyword">auto</span> hi = s.end() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isAlphabet(*lo))</span><br><span class="line">                ++lo;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isAlphabet(*hi))</span><br><span class="line">                --hi;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(*lo != *hi)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++lo;</span><br><span class="line">                --hi;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlphabet</span><span class="params">(<span class="keyword">char</span>&amp; ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt; <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>138. Copy List with Random Pointer</title>
    <url>/2021/04/28/138.%20Copy%20List%20with%20Random%20Pointer/</url>
    <content><![CDATA[<h4 id="copy-list-with-random-pointer"><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a></h4>
<h5 id="hashmap-vector">hashmap &amp;&amp; vector</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> headTmp = head;</span><br><span class="line">        Node* newHead = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node* newHeadTmp = newHead;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; newMap;</span><br><span class="line">        <span class="keyword">while</span>(headTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* nodeTmp = <span class="keyword">new</span> Node(headTmp-&gt;val);</span><br><span class="line">            </span><br><span class="line">            newHeadTmp-&gt;next = nodeTmp;</span><br><span class="line">            newHeadTmp = newHeadTmp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            newMap.push_back(nodeTmp);</span><br><span class="line">            <span class="built_in">map</span>[headTmp] = i++;</span><br><span class="line">            </span><br><span class="line">            headTmp = headTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headTmp = head;</span><br><span class="line">        </span><br><span class="line">        newHeadTmp = newHead;</span><br><span class="line">        newHead = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHeadTmp;</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(headTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(headTmp-&gt;random)</span><br><span class="line">                newMap[i]-&gt;random = newMap[<span class="built_in">map</span>[headTmp-&gt;random]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                newMap[i]-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            ++i;</span><br><span class="line">            headTmp = headTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="discussion中o1-space-complexity-的方法实际上还是on">discussion中O(1) space Complexity 的方法，实际上还是O(n)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* headTmp = head;</span><br><span class="line">        <span class="keyword">while</span>(headTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = <span class="keyword">new</span> Node(headTmp-&gt;val);</span><br><span class="line">            <span class="keyword">auto</span> next = headTmp-&gt;next;</span><br><span class="line">            headTmp-&gt;next = node;</span><br><span class="line">            node-&gt;next = next;</span><br><span class="line">            headTmp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        headTmp = head;</span><br><span class="line">        <span class="keyword">while</span>(headTmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(headTmp-&gt;random)</span><br><span class="line">                headTmp-&gt;next-&gt;random = headTmp-&gt;random-&gt;next;</span><br><span class="line">            headTmp = headTmp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headTmp = head;</span><br><span class="line">        Node* newHead = head-&gt;next;</span><br><span class="line">        Node* newHeadTmp = newHead;</span><br><span class="line">        <span class="keyword">while</span>(newHeadTmp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            headTmp-&gt;next = headTmp-&gt;next-&gt;next;</span><br><span class="line">            headTmp = headTmp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            newHeadTmp-&gt;next = headTmp-&gt;next;</span><br><span class="line">            newHeadTmp = newHeadTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        headTmp-&gt;next = headTmp-&gt;next-&gt;next;</span><br><span class="line">        newHeadTmp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>139. Word Break</title>
    <url>/2021/04/02/139-Word-Break/</url>
    <content><![CDATA[<h4 id="word-break"><a href="https://leetcode.com/problems/word-break/">139. Word Break</a></h4>
<p><img src="https://image.cinte.cc/2021/04/02/4e3d2b784323c.png" /> ##### dp</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        unordered_set&lt;string&gt; dict;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="kw">auto</span>&amp; word : wordDict)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            dict.insert(word);</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        vector&lt;<span class="dt">bool</span>&gt; dp(s.size() + <span class="dv">1</span>, <span class="kw">false</span>);</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>] = <span class="kw">true</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">size_t</span> i = <span class="dv">1</span>; i &lt;= s.size(); ++i)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span>(<span class="dt">size_t</span> j = <span class="dv">0</span>; j &lt; i; ++j)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            &#123;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span>(dp[j] &amp;&amp; (dict.find(s.substr(j, i - j)) != dict.end())) <span class="co">// 对于后面的i来说，要用到前面的结果，如果某一块前面部分是true的且剩下的也是可分的，那么这一块也是true，就不用重复判断前面部分了</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                &#123;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                    dp[i] = <span class="kw">true</span>;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp.back();</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>&#125;;</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<p>T(n) : O(n^2) ? <br> S(n) : O(n)</p>
<p>动态规划 ： 用数组存储子问题的值，用子问题的值直接得到现在问题的值</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2021/03/07/14-Longest-Common-Prefix/</url>
    <content><![CDATA[<h4 id="longest-common-prefix"><a href="https://leetcode.com/problems/longest-common-prefix/">14. Longest Common Prefix</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;strs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minSize = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> minSizeStrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].size() &lt; minSize)</span><br><span class="line">            &#123;</span><br><span class="line">                minSize = strs[i].size();</span><br><span class="line">                minSizeStrIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> chs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> bias = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ch : strs[minSizeStrIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; strs.size();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == minSizeStrIndex)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (ch != strs[i][bias])</span><br><span class="line">                    <span class="keyword">return</span> chs;</span><br><span class="line">            &#125;</span><br><span class="line">            chs += ch;</span><br><span class="line">            ++bias;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>141. Linked List Cycle</title>
    <url>/2021/04/04/141-Linked-List-Cycle/</url>
    <content><![CDATA[<h4 id="linked-list-cycle"><a href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></h4>
<h5 id="最没技术的做法">最没技术的做法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.emplace(head).second)</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="two-point">two point</h5>
<p>nb! <a href="https://codingfreak.blogspot.com/2012/09/detecting-loop-in-singly-linked-list_22.html">explanation</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设slow起始位于N(0),而fast位于N(d - 1)（其中d为一个随机位置）<br> 假设环的长度为M，则t时间后slow位于N(t mod M)，而fast位于N((2t + d) mod M) <br> <span class="math display">\[\left\{
\begin{aligned}
t = pM + x \\
2t + d = qM + x
\end{aligned}
\right.\]</span> 两式相减<br> 得到t = (q - p)M - d<br> 因此，他们必相遇</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Point</tag>
      </tags>
  </entry>
  <entry>
    <title>142. Linked List Cycle II</title>
    <url>/2021/04/12/142-Linked-List-Cycle-II/</url>
    <content><![CDATA[<h4 id="linked-list-cycle-ii"><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(<span class="built_in">set</span>.emplace(head).second))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="使用linked-cycle中的two-point-方法">使用linked cycle中的two point 方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* walker = head;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> isMeet = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(runner-&gt;next &amp;&amp; runner-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(walker == runner)</span><br><span class="line">            &#123;</span><br><span class="line">                isMeet = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isMeet)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = head;</span><br><span class="line">            <span class="keyword">while</span>(walker != runner)</span><br><span class="line">            &#123;</span><br><span class="line">                walker = walker-&gt;next;</span><br><span class="line">                runner = runner-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> runner;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.cinte.cc/2021/04/12/fe23f299564ba.png" alt="image.png" /> 即当一个点从第一次遇见的点开始，走r-m步，走到环的起始点时，另一个点刚好从起点走到环的起始点</p>
<p>针对最后取为1的修订 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Smart solution. But replacing all &quot;wake&quot; to &quot;walk&quot; in your words makes me feel better :) Another minor point is you can&#39;t just &quot;here we takes n &#x3D; 1&quot; even it doesn&#39;t affect the last result. It still should read as s&#x3D;nr-m. That means the 1st pointer starts from beginning of the list while the 2nd pointer starts from meet point, they will meet in the cycle point but the 2nd pointer walked n times of the cycle.</span><br></pre></td></tr></table></figure> 第二次循环时候，runner是走了<code>r2-2r1</code>(设为n)圈，这个数字为正即可，因为不管他多走几圈都影响不了结果。而r2是runner走的圈数，r1是walker走的圈数。</p>
<p>k为步数，s为起点到环起点的距离，m为圈长 <code>r2 = (2k - s) / m</code>，而<code>r1 = (k - s) / m</code>，则<code>r2 / r1 = 2 + s/k+s</code>，所以<code>r2 - 2r1 =  s / k + s</code>必定为正数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>144. 二叉树的前序遍历</title>
    <url>/2021/07/14/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="二叉树的前序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4>
<p>迭代算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(root);</span><br><span class="line">                ret.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        tra(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tra</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ret.push_back(root-&gt;val);</span><br><span class="line">        tra(root-&gt;left);</span><br><span class="line">        tra(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <url>/2021/07/14/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="二叉树的后序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4>
<p>迭代算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>; <span class="comment">// 来判断右子树是否访问过，以免重复访问，关键</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先把左边全都压入栈</span></span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left; </span><br><span class="line">            &#125;</span><br><span class="line">            root = s.top(); <span class="comment">// 弹出节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="comment">// 如果节点右边为空，或者右边树之前走过了，那就轮到记录当前节点的值了</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right || root-&gt;right == prev) </span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(root-&gt;val);</span><br><span class="line">                prev = root; <span class="comment">// 这个节点走过了，如果没有设置这个的话，假设s是t的右节点，这里如果遍历s后，下一个弹出的就是t了，而t的右节点显然为s，但是非空，因此会进入else中继续进入右节点，导致无限循环。</span></span><br><span class="line">                <span class="comment">// 换言之，在弹出过程中，root是向上移动的，为了防止他重复进入，用prev堵住</span></span><br><span class="line">                root = <span class="literal">nullptr</span>; <span class="comment">// 这里都遍历到右边说明右边遍历完了，那么左边自然也遍历完了，防止他再进自己左边，就需要设为null，然后前面的都是进栈了</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(root); <span class="comment">// 右边还有东西，重新压root入栈，走完右边再用</span></span><br><span class="line">                root = root-&gt;right; <span class="comment">// 进入右边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归算法</p>
<p>太简单不写了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU Cache</title>
    <url>/2021/05/02/146.%20LRU%20Cache/</url>
    <content><![CDATA[<h4 id="lru-cache"><a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity): capacity(capacity), head(<span class="keyword">new</span> Node()), tail(<span class="keyword">new</span> Node()) &#123;</span><br><span class="line">        head-&gt;post = tail;</span><br><span class="line">        head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        tail-&gt;post = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.find(key) != cache.end())</span><br><span class="line">        &#123;</span><br><span class="line">            moveNodeToHead(cache[key]);</span><br><span class="line">            <span class="keyword">return</span> cache[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.find(key) == cache.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache.size() &gt; capacity - <span class="number">1</span>)</span><br><span class="line">                cache.erase(removeTailNode());</span><br><span class="line">            Node* node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            addNodeToHead(node);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = cache[key];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;val != value)</span><br><span class="line">                node-&gt;val = value;</span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* post;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> val): key(key), val(val) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;post = node-&gt;post;</span><br><span class="line">        node-&gt;post-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNodeToHead</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;post = head-&gt;post;</span><br><span class="line">        head-&gt;post = node;</span><br><span class="line">        node-&gt;post-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveNodeToHead</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addNodeToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeTailNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = tail-&gt;prev;</span><br><span class="line">        tail-&gt;prev = node-&gt;prev;</span><br><span class="line">        tail-&gt;prev-&gt;post = tail;</span><br><span class="line">        <span class="keyword">auto</span> key = node-&gt;key;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt; cache;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>使用doubleLinkedList是因为在删除时候需要操作前面的元素，因此DoublelinkedList可以实现O(1)的删除操作，而SingleLinkedList就需要O(n)<br> 总体思路是访问过的移动到第一位，而最少访问的放在最后，如果新进来的时候缓存满了，那么就释放掉最后一位。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>148. Sort List</title>
    <url>/2021/04/30/148.%20Sort%20List/</url>
    <content><![CDATA[<h4 id="sort-list"><a href="https://leetcode.com/problems/sort-list/">148. Sort List</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// split O(logn)</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// head-&gt;next 是为了单个节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> midPoint = getMid(head);</span><br><span class="line">        <span class="keyword">auto</span> left = sortList(head);</span><br><span class="line">        <span class="keyword">auto</span> right = sortList(midPoint);</span><br><span class="line">        <span class="keyword">return</span> mergeList(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这里的获取终点函数记得要进行部分调整，要从中间切断这个list</span></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* walker = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = !walker ? head : walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = walker-&gt;next;</span><br><span class="line">        walker-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeList(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeList(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn)</p>
<p>总体是分成许多一半一半的，然后每一小部分merge</p>
<h5 id="优化merge">优化merge</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> midPoint = getMid(head);</span><br><span class="line">        <span class="keyword">auto</span> left = sortList(head);</span><br><span class="line">        <span class="keyword">auto</span> right = sortList(midPoint);</span><br><span class="line">        <span class="keyword">return</span> mergeList(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* walker = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = !walker ? head : walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = walker-&gt;next;</span><br><span class="line">        walker-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> prev = &amp;dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">            prev-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3Sum</title>
    <url>/2021/03/11/15-3Sum/</url>
    <content><![CDATA[<h4 id="sum"><a href="https://leetcode.com/problems/3sum/">15. 3Sum</a></h4>
<h5 id="自己的方法">自己的**方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> bias = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nummm;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nummm.find(num) != nummm.end())</span><br><span class="line">            &#123;</span><br><span class="line">                ++bias;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nummm.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = ++bias; i &lt; nums.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">set</span>.find(target - nums[i]) != <span class="built_in">set</span>.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(&#123;-target, target - nums[i], nums[i]&#125;);</span><br><span class="line">                    <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">                    <span class="keyword">while</span>(i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="改">改</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> bias = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt; nums.size())</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++bias;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = ++bias; i &lt; nums.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">set</span>.find(target - nums[i]) != <span class="built_in">set</span>.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(&#123;-target, target - nums[i], nums[i]&#125;);</span><br><span class="line">                    <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">                    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">                        ++i;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="discussion里的on2方法">discussion里的O(n^2)方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span> || *(nums.begin()) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(i==<span class="number">0</span>||(i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i<span class="number">-1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i + <span class="number">1</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> num = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[low] + nums[high] == num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(&#123;nums[i], nums[low], nums[high]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low + <span class="number">1</span>])</span><br><span class="line">                        ++low;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high - <span class="number">1</span>])</span><br><span class="line">                        --high;</span><br><span class="line">                    ++low;</span><br><span class="line">                    --high;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[low] + nums[high] &lt; num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++low;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>152. Maximum Product Subarray</title>
    <url>/2021/04/12/152-Maximum-Product-Subarray/</url>
    <content><![CDATA[<h4 id="maximum-product-subarray"><a href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></h4>
<h5 id="仿kadane算法">仿kadane算法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxEndHere = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minEndHere = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.begin() + <span class="number">1</span>; i != nums.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = *i;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">                swap(maxEndHere, minEndHere);</span><br><span class="line">            </span><br><span class="line">            maxEndHere = max(num, maxEndHere * num);</span><br><span class="line">            minEndHere = min(num, minEndHere * num);</span><br><span class="line">            </span><br><span class="line">            maxSoFar = max(maxEndHere, maxSoFar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="另一种思路">另一种思路</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum&#123; nums[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="keyword">int</span> product&#123; <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.begin(); i != nums.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, product *= *i);</span><br><span class="line">            <span class="keyword">if</span>(!*i) product = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.end() - <span class="number">1</span>; i != nums.begin(); --i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, product *= *i);</span><br><span class="line">            <span class="keyword">if</span>(!*i) product = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curLR = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curRL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>; i &lt; nums.size(); ++i, --j)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = max(ret, max(curLR *= nums[i], curRL *= nums[j]));</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">                curLR = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">0</span>)</span><br><span class="line">                curRL = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当负数的个数为偶数时，全乘起来就是最大，为奇数时，需要抛弃一个 <br> 每次的乘法，最大的乘积受到最后一个负数的限制</p>
<p>review <br> 当负数个数为偶数且中间没有0，那么无论左到右还是右到左都会遍历到。</p>
<p>抛开此外，可以观察到分界线为0，每一块被0分开的没0区域都表示一个乘积，当这一个区域没有负数或者负数个数为偶数，那么无论左到右还是右到左都会遍历到。当为奇数，那么以其中一个奇数为分界线将分成左右2块为偶的区域，由此需要左到右和右到左遍历。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>1545. 找出第 N 个二进制字符串中的第 K 位</title>
    <url>/2021/08/23/1545.%20%E6%89%BE%E5%87%BA%E7%AC%AC%20N%20%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E4%BD%8D/</url>
    <content><![CDATA[<h4 id="找出第-n-个二进制字符串中的第-k-位"><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">1545. 找出第 N 个二进制字符串中的第 K 位</a></h4>
<p><span class="math display">\[
len_n = len_{n-1} * 2 + 1 \\
= (len_{n - 2} * 2 + 1) * 2 + 1 \\
= ... \\
= ((len_1 * 2 + 1) * 2 + 1) * 2... \\
= 2^{n - 1} + 1 + 2 * 1 + 2 * 2 * 1 + ... 2^{n - 2} \\
= 2^{n - 1} + \frac{1*(1 - 2^{n - 1})}{1 - 2} \\
= 2^{n - 1} + 2^{n - 1} - 1 \\
= 2^n - 1
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// S_n的长度为2^n - 1，因此S_n是由2^(n - 1) - 1 + 1 + 2^(n - 1) - 1构成的。所以中间放&#x27;1&#x27;的地方是2^(n-1)</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当k为1时，恒为0，如果没有这一行，当n = 1,k = 1时会判定为1</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 中间值，是当前字符串放&#x27;1&#x27;的位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid == k)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果k&lt;mid，在前半字符串中递归搜索</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; mid)</span><br><span class="line">                <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果k &gt; mid，在前半字符串的反转中搜索，等效为将k变换后搜索新的k</span></span><br><span class="line">                <span class="keyword">return</span> invert(findKthBit(n - <span class="number">1</span>, mid * <span class="number">2</span> - k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;1&#x27;</span> - ch + <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 虽然条件传送可以避免后续步骤中的分支预测错误惩罚，但当前分支依旧会有惩罚，因此使用算数运算可以避免这种分支预测错误带来的惩罚。</span></span><br><span class="line">        <span class="comment">// return ch == &#x27;0&#x27; ? &#x27;1&#x27; : &#x27;0&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>155. Min Stack</title>
    <url>/2021/04/09/155-Min-Stack/</url>
    <content><![CDATA[<h4 id="min-stack"><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></h4>
<p>抄的dicussion中的<a href="https://leetcode.com/problems/min-stack/discuss/49010/Clean-6ms-Java-solution">一种实现方法</a>，真的帅</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        topEle = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!topEle)</span><br><span class="line">            topEle = <span class="keyword">new</span> Node(val, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            topEle = <span class="keyword">new</span> Node(val, min(topEle-&gt;min, val), topEle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = topEle;</span><br><span class="line">        topEle = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topEle-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topEle-&gt;min;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node () : val(<span class="number">0</span>), min(INT_MAX), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        Node (<span class="keyword">int</span> val, <span class="keyword">int</span> min) : val(val), min(min), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        Node (<span class="keyword">int</span> val, <span class="keyword">int</span> min, Node* next) : val(val), min(min), next(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* topEle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 3Sum Closest</title>
    <url>/2021/03/17/16-3Sum-Closest/</url>
    <content><![CDATA[<h4 id="sum-closest"><a href="https://leetcode.com/problems/3sum-closest/">16. 3Sum Closest</a></h4>
<h5 id="refer-3sum">refer <a href="https://leetcode.cinte.cc/2021/03/11/15-3Sum/">3sum</a></h5>
<h5 id="solution-1-2-points">Solution 1( 2 points)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size() &amp;&amp; diff != <span class="number">0</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(diff))</span><br><span class="line">                &#123;</span><br><span class="line">                    diff = sum - target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                    ++lo;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --hi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff + target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <url>/2021/04/12/160-Intersection-of-Two-Linked-Lists/</url>
    <content><![CDATA[<h4 id="intersection-of-two-linked-lists"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h4>
<h5 id="最直接法">最直接法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span>(headA)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(headA);</span><br><span class="line">            headA = headA-&gt;next;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(headB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(headB) != <span class="built_in">set</span>.end())</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="预先求差">预先求差</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> lenB&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        </span><br><span class="line">        ListNode* a = headA;</span><br><span class="line">        ListNode* b = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            ++lenA;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            ++lenB;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; ++i)</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; ++i)</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(headA &amp;&amp; headB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(headA == headB)</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="次迭代">2次迭代</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a == <span class="literal">nullptr</span> ? headB : a-&gt;next;</span><br><span class="line">            b = b == <span class="literal">nullptr</span> ? headA : b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他们第一次跑会有一个长度的差，短的先跑到终点后，到长的端点。当长的指针跑到终点后，回到短的端点。此时先前一个刚好跑了他们的距离差，这是他们在距离上是处于同一个起点的。</p>
<p>设短的到交点距离x，长的到交点距离y，公共部分距离为z，则如果要求交点，那么让他们走到交点的路程一致即可，则让短的走到头后跳到长，长的走到头后跳到短，最后对于短头来说x+y+z,长头也是x+y+z，刚好在交点相交。</p>
<p>review</p>
<p>如果没交点，第二轮时候他们肯定一同走到尾巴。长的比短的多出来的步数，由于短的先走到头，然后比长的走到短头会刚好多走这么几步，于是就处于同意起跑线。</p>
<p>具体见<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!">discussion</a>中的评论第一条</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>1646. 获取生成数组中的最大值</title>
    <url>/2021/08/23/1646.%20%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="获取生成数组中的最大值"><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></h4>
<h5 id="直接模拟生成">直接模拟生成</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGenerated</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="number">2</span> * i] = nums[i];</span><br><span class="line">            ret = max(ret, nums[<span class="number">2</span> * i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[<span class="number">2</span> * i + <span class="number">1</span>] = nums[i] + nums[i + <span class="number">1</span>];</span><br><span class="line">                ret = max(nums[<span class="number">2</span> * i + <span class="number">1</span>], ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>合并奇数和偶数的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGenerated</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[i / <span class="number">2</span>] + (i &amp; <span class="number">1</span>) * nums[i / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">            ret = max(nums[i], ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>165. 比较版本号</title>
    <url>/2021/08/31/165.%20%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="比较版本号"><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">        <span class="keyword">int</span> vt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : version1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v1.push_back(vt);</span><br><span class="line">                vt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vt = vt * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v1.push_back(vt);</span><br><span class="line">        <span class="keyword">while</span>(!v1.empty() &amp;&amp; v1.back() == <span class="number">0</span>)</span><br><span class="line">            v1.pop_back();</span><br><span class="line">        vt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : version2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v2.push_back(vt);</span><br><span class="line">                vt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vt = vt * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v2.push_back(vt);</span><br><span class="line">        <span class="keyword">while</span>(!v2.empty() &amp;&amp; v2.back() == <span class="number">0</span>)</span><br><span class="line">            v2.pop_back();</span><br><span class="line">        <span class="keyword">int</span> m = v1.size(), n = v2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(m, n); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i] &gt; v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v1[i] &lt; v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m &lt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="优化空间分割过程中比较">优化空间，分割过程中比较</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = version1.size(), n = version2.size();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m || j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                x = x * <span class="number">10</span> + version1[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                y = y * <span class="number">10</span> + version2[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x != y)</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>169. Majority Element</title>
    <url>/2021/04/08/169-Majority-Element/</url>
    <content><![CDATA[<h4 id="majority-element"><a href="https://leetcode.com/problems/majority-element/">169. Majority Element</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[num] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[num] &gt; n)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="法二">法二</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超过n / 2数量的元素必定会在n / 2处出现</p>
<h5 id="投票法">投票法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candidate;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)</span><br><span class="line">                candidate = num;</span><br><span class="line">            </span><br><span class="line">            count += (candidate == num) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次丢弃与少数元素相同的多数元素前缀，最后存在的最多的一定是多数元素。解释如下，很棒 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Approach 6: Boyer-Moore Voting Algorithm</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">If we had some way of counting instances of the majority element as +1+1 and instances of any other element as -1−1, summing them would make it obvious that the majority element is indeed the majority element.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Essentially, what Boyer-Moore does is look for a suffix sufsuf of nums where suf[0]suf[0] is the majority element in that suffix. To do this, we maintain a count, which is incremented whenever we see an instance of our current candidate for majority element and decremented whenever we see anything else. Whenever count equals 0, we effectively forget about everything in nums up to the current index and consider the current number as the candidate for majority element. It is not immediately obvious why we can get away with forgetting prefixes of nums - consider the following examples (pipes are inserted to separate runs of nonzero count).</span><br><span class="line"></span><br><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line"></span><br><span class="line">Here, the 7 at index 0 is selected to be the first candidate for majority element. count will eventually reach 0 after index 5 is processed, so the 5 at index 6 will be the next candidate. In this case, 7 is the true majority element, so by disregarding this prefix, we are ignoring an equal number of majority and minority elements - therefore, 7 will still be the majority element in the suffix formed by throwing away the first prefix.</span><br><span class="line"></span><br><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]</span><br><span class="line"></span><br><span class="line">Now, the majority element is 5 (we changed the last run of the array from 7s to 5s), but our first candidate is still 7. In this case, our candidate is not the true majority element, but we still cannot discard more majority elements than minority elements (this would imply that count could reach -1 before we reassign candidate, which is obviously false).</span><br><span class="line"></span><br><span class="line">Therefore, given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. Eventually, a suffix will be found for which count does not hit 0, and the majority element of that suffix will necessarily be the same as the majority element of the overall array.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Letter Combinations of a Phone Number</title>
    <url>/2021/03/10/17-Letter-Combinations-of-a-Phone-Number/</url>
    <content><![CDATA[<h4 id="letter-combinations-of-a-phone-number"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.size())</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(<span class="string">&quot;&quot;</span>, digits);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; phone&#123;&#123;<span class="string">&#x27;2&#x27;</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;3&#x27;</span>, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;4&#x27;</span>, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;5&#x27;</span>, &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;6&#x27;</span>, &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;7&#x27;</span>, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;8&#x27;</span>, &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;9&#x27;</span>, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> comb, <span class="built_in">string</span> digit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!digit.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(comb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : phone[digit[<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(comb + ch, digit.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>review <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        backTrack(ret, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="built_in">map</span>&#123;</span><br><span class="line">        &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, <span class="built_in">string</span>&amp; tmp, <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == digits.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : <span class="built_in">map</span>[digits[i] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += ch;</span><br><span class="line">            backTrack(ret, tmp, digits, i + <span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有一种</p>
<p>先把一个字母依次添加，然后再依次网上衔接各种情况</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>171. Excel Sheet Column Number</title>
    <url>/2021/06/13/171.%20Excel%20Sheet%20Column%20Number/</url>
    <content><![CDATA[<h4 id="excel-sheet-column-number"><a href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel Sheet Column Number</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = columnTitle.size();</span><br><span class="line">        <span class="keyword">int</span> sum = columnTitle.back() - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            sum += (columnTitle[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) * (tmp *= <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>26进制转为10进制，就n转10差不多</p>
<h5 id="但我还是算的更麻烦了">但我还是算的更麻烦了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = columnTitle.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            sum = (columnTitle[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) + sum * <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>189. Rotate Array</title>
    <url>/2021/07/01/189.%20Rotate%20Array/</url>
    <content><![CDATA[<h4 id="rotate-array"><a href="https://leetcode.com/problems/rotate-array/">189. Rotate Array</a></h4>
<h5 id="第三种方法太复杂了只会第四种">第三种方法太复杂了，只会第四种</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.size() - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">            swap(nums[start++], nums[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <url>/2021/03/13/19-Remove-Nth-Node-From-End-of-List/</url>
    <content><![CDATA[<h4 id="remove-nth-node-from-end-of-list"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* target = head;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* iterator = head;</span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++size;</span><br><span class="line">            iterator = iterator-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target = target-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size - n - <span class="number">1</span> == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            target-&gt;next = target-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="discussion">discussion</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *start = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *fast = start, *slow = start;</span><br><span class="line">        start-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pseudoHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        pseudoHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> walker = pseudoHead;</span><br><span class="line">        <span class="keyword">auto</span> runner = pseudoHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt;= n)</span><br><span class="line">            runner = runner-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(runner)</span><br><span class="line">        &#123;</span><br><span class="line">            runner = runner-&gt;next;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> p = walker-&gt;next;</span><br><span class="line">        walker-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> pseudoHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>198. House Robber</title>
    <url>/2021/04/09/198-House-Robber/</url>
    <content><![CDATA[<h4 id="house-robber"><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(nums[i] + dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="注意到每次只用到dpi---2和dpi---1用2变量优化">注意到每次只用到dp[i - 2]和dp[i - 1],用2变量优化</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = max(nums[i] + dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">            swap(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(1)</p>
<p><a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.">dicussion中的动态规划推导步骤</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>199. Binary Tree Right Side View</title>
    <url>/2021/04/07/199-Binary-Tree-Right-Side-View/</url>
    <content><![CDATA[<h4 id="binary-tree-right-side-view"><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz = q.size(); i &lt; sz; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) S(n) : O(k)(k为每层数)</p>
<h5 id="discussion的方法">discussion的方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        rightView(ret, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rightView</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, TreeNode* node, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(depth == ret.size()) <span class="comment">// 如果当depth != ret.size()时return，则会导致传递的终止，不行，当不等时候，那就继续遍历下去，说不定下面一层又轮到你了</span></span><br><span class="line">            ret.push_back(node-&gt;val);</span><br><span class="line">        </span><br><span class="line">        rightView(ret, node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        rightView(ret, node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(logn) 总体思路是每层只添加一个，然后仅当每层没添加时才会添加进去，而层数通过ret的大小来判定，由于是从右到左遍历，因此每层添加的一定是最右的</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2021/02/01/2-Add-Two-Numbers/</url>
    <content><![CDATA[<h4 id="add-two-numbers"><a href="https://leetcode.com/problems/add-two-numbers/">2. Add Two Numbers</a></h4>
<h5 id="第一次">第一次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *result = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *point = result;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1 != <span class="number">0</span> &amp;&amp; l2 != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = l1-&gt;val + l2-&gt;val + c;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="string">&quot;case 1&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="number">0</span> &amp;&amp; l2 == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = l1-&gt;val + c;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="string">&quot;case 2&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="number">0</span> &amp;&amp; l2 != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = l2-&gt;val + c;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="string">&quot;case 3&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (...)</span><br><span class="line">            &#123;</span><br><span class="line">                point-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">                c = sum / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span> (l1 != <span class="number">0</span> || l2 != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    point-&gt;next = <span class="keyword">new</span> ListNode();</span><br><span class="line">                    point = point-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        point-&gt;next = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (l1 != <span class="number">0</span> || l2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.cinte.cc/2021/02/01/5634aa76486d6.png" alt="第一次结果" /> <a id="more"></a></p>
<h5 id="第二次">第二次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *result = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *point = result;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="number">0</span> &amp;&amp; l2 != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = l1-&gt;val + l2-&gt;val + c;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="number">0</span> &amp;&amp; l2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = l1-&gt;val + c;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="number">0</span> &amp;&amp; l2 != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = l2-&gt;val + c;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span> + c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="number">0</span> || l2 != <span class="number">0</span> || c != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                point-&gt;next = <span class="keyword">new</span> ListNode();</span><br><span class="line">                point = point-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (l1 != <span class="number">0</span> || l2 != <span class="number">0</span> || c != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.cinte.cc/2021/02/02/dcab1942c9d21.png" /></p>
<h5 id="复习">复习</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pseudoL1 = l1;</span><br><span class="line">        <span class="keyword">auto</span> pseudoL2 = l2;</span><br><span class="line">        <span class="keyword">int</span> l1Length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2Length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pseudoL1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++l1Length;</span><br><span class="line">            pseudoL1 = pseudoL1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pseudoL2)</span><br><span class="line">        &#123;</span><br><span class="line">            ++l2Length;</span><br><span class="line">            pseudoL2 = pseudoL2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1Length &gt; l2Length)</span><br><span class="line">            swap(l1, l2);</span><br><span class="line">        <span class="keyword">auto</span> ret = l2;</span><br><span class="line">        <span class="keyword">auto</span> pre = l2;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> sum = l2-&gt;val + l1-&gt;val + c;</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">            l2-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">            pre = l2;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!l2)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> sum = l2-&gt;val + c;</span><br><span class="line">                l2-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">                c = sum / <span class="number">10</span>;</span><br><span class="line">                pre = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/05/16/7355ecdb33a0c.png" alt="1621148746599.png" /><figcaption aria-hidden="true">1621148746599.png</figcaption>
</figure>
<h5 id="solution">solution</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* ret = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">auto</span> ans = ret;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = c;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ret-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            ret = ret-&gt;next;</span><br><span class="line">            c = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c)</span><br><span class="line">            ret-&gt;next = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2021/03/18/20-Valid-Parentheses/</url>
    <content><![CDATA[<h4 id="valid-parentheses"><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></h4>
<h5 id="solution-太强了">Solution 太强了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; <span class="built_in">map</span>&#123; &#123;<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;, &#123; <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span> &#125;, &#123; <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span> &#125; &#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (s.size() % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == (st.size() ? <span class="built_in">map</span>[st.top()] : <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">                st.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>200. Number of Islands</title>
    <url>/2021/04/12/200-Number-of-Islands/</url>
    <content><![CDATA[<h4 id="number-of-islands"><a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a></h4>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.size() || j &gt;= grid[<span class="number">0</span>].size() || grid[i][j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>深度优先遍历，当遇到一块陆地后，向周围遍历，遍历过的土地做上标记防止重复遍历，当遍历完一整块岛后，返回，计数加一</p>
<h5 id="使用并查集">使用<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></h5>
<p>对discuss中的代码加以批注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] distance = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;; <span class="comment">// 4个方向</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(grid);  </span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;  </span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;  <span class="comment">// 当遇上陆地</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] d : distance) &#123; <span class="comment">// 陆地的4个方向进行遍历</span></span><br><span class="line">                    <span class="keyword">int</span> x = i + d[<span class="number">0</span>]; </span><br><span class="line">                    <span class="keyword">int</span> y = j + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 当且仅当是陆地时进入循环</span></span><br><span class="line">                        <span class="keyword">int</span> id1 = i*cols+j; <span class="comment">// 当前陆地的id ，展开成1维表示</span></span><br><span class="line">                        <span class="keyword">int</span> id2 = x*cols+y; <span class="comment">// 周围陆地的id，同样是展开成一维</span></span><br><span class="line">                        uf.union(id1, id2); <span class="comment">// 进行并查，具体见UnionFind CLASS</span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> uf.count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Union Find:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] father;  </span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    UnionFind(<span class="keyword">char</span>[][] grid) &#123;  </span><br><span class="line">        m = grid.length;  </span><br><span class="line">        n = grid[<span class="number">0</span>].length;  </span><br><span class="line">        father = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> id = i * n + j;</span><br><span class="line">                    father[id] = id; <span class="comment">// 对每一个陆地初始化，初始化后，每个陆地都各自分为一类</span></span><br><span class="line">                    count++; <span class="comment">// 在归并之前，总数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> find1 = find(node1); <span class="comment">// 查找node 1 和 node 2属于哪一类</span></span><br><span class="line">        <span class="keyword">int</span> find2 = find(node2);</span><br><span class="line">        <span class="keyword">if</span>(find1 != find2) &#123;</span><br><span class="line">            father[find1] = find2; <span class="comment">// 由于二者是邻接的陆地，因此当二者属于的类不同时，将其合并</span></span><br><span class="line">            count--; <span class="comment">// 2块陆地合并，计数减一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归查找所属的类，直到查找到其所属的最顶端类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (father[node] == node) &#123;  </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        father[node] = find(father[node]);  </span><br><span class="line">        <span class="keyword">return</span> father[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>207. Course Schedule</title>
    <url>/2021/04/21/207-Course-Schedule/</url>
    <content><![CDATA[<h4 id="course-schedule"><a href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a></h4>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(numCourses);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">done</span><span class="params">(numCourses, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录走过的点，如果走到了这个点并标记为true，表示通过这个点可以走回去</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">todo</span><span class="params">(numCourses, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录在走路过程中走过的点，如果走路过程中撞到了，表明有环，那么必定返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; course : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[course[<span class="number">1</span>]].push_back(course[<span class="number">0</span>]); <span class="comment">// 建立有向图,注意方向  review : 其实主要是判断环路，方向无所谓啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!helper(<span class="built_in">map</span>, i, todo, done))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">map</span>, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; todo, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(todo[index]) <span class="comment">// 撞到了 失败了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(done[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 因为如果这条路不能走的话，之前就已经返回false了，所以再次走到肯定是安全的</span></span><br><span class="line">        </span><br><span class="line">        done[index] = <span class="literal">true</span>; <span class="comment">// 走了这个点</span></span><br><span class="line">        todo[index] = <span class="literal">true</span>; <span class="comment">// 走到了这个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : <span class="built_in">map</span>[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!helper(<span class="built_in">map</span>, i, todo, done))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        todo[index] = <span class="literal">false</span>; <span class="comment">// 这趟走完了，没有发现环，这条路是安全的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个点都是一条路走到黑，所以是DFS</p>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">checked</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 0 : unknown, 1 : ok</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : prerequisites)</span><br><span class="line">            graph[c[<span class="number">0</span>]].push_back(c[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!check(graph, visited, checked, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; checked, <span class="keyword">int</span> course)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checked[course] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[course])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[course] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : graph[course])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(graph, visited, checked, c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[course] = <span class="number">0</span>;</span><br><span class="line">        checked[course] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>208. Implement Trie (Prefix Tree)</title>
    <url>/2021/04/26/208.%20Implement%20Trie%20(Prefix%20Tree)/</url>
    <content><![CDATA[<h4 id="implement-trie-prefix-tree"><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a></h4>
<h5 id="使用vector">使用vector</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        Node* point = root;        </span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!travesalChilds(word, start, point))</span><br><span class="line">            &#123;</span><br><span class="line">                point-&gt;childs.push_back(<span class="keyword">new</span> Node(word[start]));</span><br><span class="line">                point = point-&gt;childs.back(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        point-&gt;endOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!travesalChilds(word, start, point))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> point-&gt;endOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; prefix.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!travesalChilds(prefix, start, point))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> endOfWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; childs;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(<span class="keyword">char</span> val, <span class="keyword">bool</span> end = <span class="literal">false</span>) : val(val), endOfWord(end) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">travesalChilds</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; start, Node*&amp; node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; child : node-&gt;childs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(child-&gt;val == s[start])</span><br><span class="line">            &#123;</span><br><span class="line">                node = child;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="使用hashmap">使用hashmap</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        Node* point = root;        </span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs.find(word[start]) != point-&gt;childs.end())</span><br><span class="line">                point = point-&gt;childs[word[start]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                point = point-&gt;childs.insert(&#123;word[start] ,<span class="keyword">new</span> Node(word[start])&#125;).first-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        point-&gt;endOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs.find(word[start]) != point-&gt;childs.end())</span><br><span class="line">                point = point-&gt;childs[word[start]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> point-&gt;endOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; prefix.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs.find(prefix[start]) != point-&gt;childs.end())</span><br><span class="line">                point = point-&gt;childs[prefix[start]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> endOfWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span> ,Node*&gt; childs;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(<span class="keyword">char</span> val, <span class="keyword">bool</span> end = <span class="literal">false</span>) : val(val), endOfWord(end) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="使用数组">使用数组</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        Node* point = root;        </span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)</span><br><span class="line">                point = point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node(word[start]);</span><br><span class="line">                point = point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        point-&gt;endOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; word.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)</span><br><span class="line">                point = point-&gt;childs[word[start] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> point-&gt;endOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Node* point = root;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(++start &lt; prefix.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[prefix[start] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)</span><br><span class="line">                point = point-&gt;childs[prefix[start] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> endOfWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        Node* childs[<span class="number">26</span>]&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(<span class="keyword">char</span> val, <span class="keyword">bool</span> end = <span class="literal">false</span>) : val(val), endOfWord(end) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() : head(<span class="keyword">new</span> Node()) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> point = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                point = point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = <span class="keyword">new</span> Node(ch);</span><br><span class="line">                point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">                point = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        point-&gt;isWord = <span class="literal">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> point = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                point = point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> point-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> point = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                point = point-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        Node* childs[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord = <span class="literal">false</span>;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(<span class="keyword">char</span> val) : val(val), childs&#123;<span class="literal">nullptr</span>&#125; &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <url>/2021/03/14/21-Merge-Two-Sorted-Lists/</url>
    <content><![CDATA[<h4 id="merge-two-sorted-lists"><a href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>213. House Robber II</title>
    <url>/2021/05/16/213.%20House%20Robber%20II/</url>
    <content><![CDATA[<h4 id="house-robber-ii"><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></h4>
<p>我好菜</p>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(sz == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(sz &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> dpNotRobFirst[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> dpRobFirst[<span class="number">2</span>];</span><br><span class="line">        dpNotRobFirst[<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dpNotRobFirst[<span class="number">1</span>] = max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        dpRobFirst[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dpRobFirst[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; sz - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dpNotRobFirst[<span class="number">0</span>] = max(dpNotRobFirst[<span class="number">1</span>], dpNotRobFirst[<span class="number">0</span>] + nums[i + <span class="number">1</span>]);</span><br><span class="line">            dpRobFirst[<span class="number">0</span>] = max(dpRobFirst[<span class="number">1</span>], dpRobFirst[<span class="number">0</span>] + nums[i]);</span><br><span class="line">            swap(dpNotRobFirst[<span class="number">0</span>], dpNotRobFirst[<span class="number">1</span>]);</span><br><span class="line">            swap(dpRobFirst[<span class="number">0</span>], dpRobFirst[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dpNotRobFirst[<span class="number">1</span>], dpRobFirst[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分为rob第一个和不rob第一个，问题变为rob[1, n - 2]和rob[2, n - 1]</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/2021/04/12/215-Kth-Largest-Element-in-an-Array/</url>
    <content><![CDATA[<h4 id="kth-largest-element-in-an-array"><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></h4>
<h5 id="直接用sort">?直接用sort</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> *(nums.end() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn) <br></p>
<h5 id="手生了写一下快速排序">手生了，写一下快速排序</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> *(nums.end() - k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = pa(nums, lo, hi);</span><br><span class="line">        quickSort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pa</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i&#123; lo &#125;;</span><br><span class="line">        <span class="keyword">int</span> j &#123; hi + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; nums[++i] &lt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; lo &amp;&amp; nums[--j] &gt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[j], nums[lo]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用优先级队列">使用优先级队列</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.push(num);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; nums.size() - k + <span class="number">1</span>)</span><br><span class="line">                pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn) <br> S(n) : O(n)</p>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = nums.size() - k;</span><br><span class="line">        <span class="keyword">int</span> lo&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> j = pa(nums, lo, hi);</span><br><span class="line">            <span class="keyword">if</span>(j &gt; k)</span><br><span class="line">                hi = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k)</span><br><span class="line">                lo = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pa</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i&#123; lo &#125;;</span><br><span class="line">        <span class="keyword">int</span> j &#123; hi + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; nums[++i] &lt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; lo &amp;&amp; nums[--j] &gt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[j], nums[lo]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最好的情况下时只进行一次partition， 为O(n) <br> 最坏的情况是对于每个元素都进行partition 为O(n^2)</p>
<p>将原数组进行洗牌后可以保证O(n)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses</title>
    <url>/2021/03/19/22-Generate-Parentheses/</url>
    <content><![CDATA[<h4 id="generate-parentheses"><a href="https://leetcode.com/problems/generate-parentheses/">22. Generate Parentheses</a></h4>
<p>这道题很硬核的使用了多种递归的方法</p>
<h5 id="递归-brute-force">递归 Brute Force</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        genrateAll(<span class="built_in">string</span>(<span class="number">2</span>*n, <span class="string">&#x27; &#x27;</span>), <span class="number">0</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">genrateAll</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s))</span><br><span class="line">                ret.push_back(s);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[pos] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            genrateAll(s, pos + <span class="number">1</span>, ret);</span><br><span class="line">            s[pos] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            genrateAll(s, pos + <span class="number">1</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --count;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举出所有情况，然后对每种情况判断是否是合法的括号对，用到了<a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a>中的思路</p>
<h5 id="backtracking">BackTracking</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        backTracking(ret, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="built_in">string</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == n*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(open &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            backTracking(ret, open + <span class="number">1</span>, close, s + <span class="string">&quot;(&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open &gt; close)</span><br><span class="line">        &#123;</span><br><span class="line">            backTracking(ret, open, close + <span class="number">1</span>, s + <span class="string">&quot;)&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅当括号符合添加的条件时才添加这个括号。 <br> 当左括号小于N的时候，表示可以加左边括号，那就加，当左括号大于右边括号时，那就加上右边括号来闭合。</p>
<h5 id="closure-number">Closure Number</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) ret.push_back(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; left : generateParenthesis(c))</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; right : generateParenthesis(n - c - <span class="number">1</span>))</span><br><span class="line">                    ret.push_back(<span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个 n == 0 时添加一个""是为了让他可以进入一次循环计算右边项而不是直接return <br> c = (2c + 1 - 0 - 1）/2 <br> n - c - 1 = (2n - 2c - 1 - 1)/2 <br></p>
<p>review : <code>()</code>中间包裹c对括号，()右边再加上n-c-1对括号，总共n对括号</p>
<p>为什么不在()左边加呢? 答： 也行</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>221. Maximal Square</title>
    <url>/2021/04/19/221-Maximal-Square/</url>
    <content><![CDATA[<h4 id="maximal-square"><a href="https://leetcode.com/problems/maximal-square/">221. Maximal Square</a></h4>
<h5 id="brute-force">Brute Force</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(curLen + i &lt; m &amp;&amp; curLen + j &lt; n &amp;&amp; !stop)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt;= curLen + j; ++k)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[i + curLen][k] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                stop = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= curLen + i; ++k)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[k][j + curLen] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                stop = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;                            </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!stop)</span><br><span class="line">                            ++curLen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxLen = max(curLen, maxLen);</span><br><span class="line">                    curLen = <span class="number">1</span>;</span><br><span class="line">                    stop = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen * maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个大小每次增长，遍历行</p>
<h5 id="dp">DP</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(matrix[<span class="number">0</span>].size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = min(min(dp[j - <span class="number">1</span>], dp[j]), prev) + <span class="number">1</span>;</span><br><span class="line">                    maxLen = max(dp[j], maxLen);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen * maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在答案的approach2中，不能使用原矩阵做为dp的矩阵，因为对于char来说，过大的矩阵会使其溢出</p>
<p>approach3<del>还是不咋懂</del>总体是每行扫描更新当前行的值，然后进入下一行后，只需要用到上一行的数据和当前行</p>
<figure>
<img src="https://image.cinte.cc/2021/04/20/f37cb333eda7e.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>225. 用队列实现栈</title>
    <url>/2021/08/27/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h4 id="用队列实现栈"><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty())</span><br><span class="line">            q1.push(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q1.size() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.front());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q2.size() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.front());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q1.size() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.front());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = q1.front();</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q2.size() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.front());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = q2.front();</span><br><span class="line">            q1.push(q2.front());</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.empty() &amp;&amp; q2.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>另一种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>226. Invert Binary Tree</title>
    <url>/2021/04/09/226-Invert-Binary-Tree/</url>
    <content><![CDATA[<h4 id="invert-binary-tree"><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>23. Merge k Sorted Lists</title>
    <url>/2021/03/20/23-Merge-k-Sorted-Lists/</url>
    <content><![CDATA[<h4 id="merge-k-sorted-lists"><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></h4>
<h5 id="solution-1">Solution 1</h5>
<p>思路<img src="https://image.cinte.cc/2021/03/21/71cece659332e.png" /> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; newLists;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lists.size(); i = i + <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != lists.size() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newLists.push_back(mergeTwoLists(lists[i], lists[i + <span class="number">1</span>]));</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                newLists.push_back(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newLists.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> newLists[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mergeKLists(newLists);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> Time complexity: O(NlogK) <br> Space complexity: O(logK)</p>
<p><strong>优化后</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stride = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = lists.size();</span><br><span class="line">        <span class="keyword">while</span>(stride &lt; sz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz - stride; i = i + <span class="number">2</span> * stride)</span><br><span class="line">            &#123;</span><br><span class="line">                lists[i] = mergeTwoLists(lists[i], lists[i + stride]);</span><br><span class="line">            &#125;</span><br><span class="line">            stride *= <span class="number">2</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> lists.empty() ? <span class="literal">nullptr</span> : lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> Time complexity: O(NlogK) <br> Space complexity: O(1)</p>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; lists.size(); step *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size() - step; i += <span class="number">2</span> * step)</span><br><span class="line">                lists[i] = merge(lists[i], lists[i + step]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists.empty() ? <span class="literal">nullptr</span> : lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = merge(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = merge(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> stride = <span class="number">1</span>; stride &lt; n; stride *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - stride; i += stride * <span class="number">2</span>) <span class="comment">// 注意这个n-stride十分重要，因为最后一步中i的位置是位于n-sride-1,所以需要让i停下来</span></span><br><span class="line">                lists[i] = merge(lists[i], lists[i + stride]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode ret;</span><br><span class="line">        ListNode* pseudoHead = &amp;ret;</span><br><span class="line">        <span class="keyword">while</span>(l2 &amp;&amp; l1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pseudoHead-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pseudoHead-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pseudoHead = pseudoHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pseudoHead-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> ret.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="solution-2-use-priority_queue">Solution 2 use priority_queue</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cuscomp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, ListNode *&gt; p1, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, ListNode *&gt; p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.first &gt; p2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, ListNode *&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, ListNode *&gt;&gt;, cuscomp&gt; q;</span><br><span class="line">        ListNode *point = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *head = point;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;<span class="built_in">list</span> : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>)</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(<span class="built_in">list</span>-&gt;val, <span class="built_in">list</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.top().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            point-&gt;next = <span class="keyword">new</span> ListNode(node-&gt;val);</span><br><span class="line">            point = point-&gt;next;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(node-&gt;val, node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review-1">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cusComp&gt; pq;</span><br><span class="line">        ListNode* pesudoHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* point = pesudoHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : lists)</span><br><span class="line">            <span class="keyword">if</span>(node)</span><br><span class="line">                pq.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            point-&gt;next = p;</span><br><span class="line">            point = point-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                pq.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pesudoHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">cusComp</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* p1, ListNode* p2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1-&gt;val &gt; p2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(NlogK) <br> Space complexity: O(N)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>230. Kth Smallest Element in a BST</title>
    <url>/2021/04/19/230-Kth-Smallest-Element-in-a-BST/</url>
    <content><![CDATA[<h4 id="flatten-binary-tree-to-linked-list"><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">114. Flatten Binary Tree to Linked List</a></h4>
<h5 id="我越来越菜了">我越来越菜了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span>(cur || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(++i == k)</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>in-order 遍历就是从小到大的排序，因此只需要进行in-order遍历</p>
<p>中序遍历中先把最左边的加进栈，然后走一个节点的右边。当没有右树的就会进入下一个循环走到上一个树</p>
<h5 id="inorder递归">inorder递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        inorder(root, ret, k);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; ret, <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorder(root-&gt;left, ret, k);</span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root-&gt;right, ret, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>231. 2 的幂</title>
    <url>/2021/08/20/231.%202%20%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h4 id="的幂"><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></h4>
<p>非正数的整数和0一定不是2的幂</p>
<p>正数的整数中只有2进制只有一个1才是2的幂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>; <span class="comment">// 也可以使用 n &amp; (-n) == n，因为-n在计算机中表示为取反再加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>234. Palindrome Linked List</title>
    <url>/2021/04/13/234-Palindrome-Linked-List/</url>
    <content><![CDATA[<h4 id="palindrome-linked-list"><a href="https://leetcode.com/problems/palindrome-linked-list/">234. Palindrome Linked List</a></h4>
<h5 id="很慢的two-point">很慢的two Point</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* walker = head;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(walker)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(runner)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(runner-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(walker-&gt;val);</span><br><span class="line">                    runner = runner-&gt;next-&gt;next;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    runner = <span class="literal">nullptr</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.top() != walker-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用链表反转">使用链表反转</h5>
<h5 id="two-point-法2">two point 法2</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* rev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        ListNode* walker = head;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            ListNode *tmp = rev;</span><br><span class="line">            rev = walker;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            rev-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(runner)</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(rev &amp;&amp; rev-&gt;val == walker-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            rev = rev-&gt;next;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>236. Lowest Common Ancestor of a Binary Tree</title>
    <url>/2021/04/22/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
    <content><![CDATA[<h4 id="lowest-common-ancestor-of-a-binary-tree"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h4>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">        backTrack(root, p, q, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(TreeNode* node, TreeNode* p, TreeNode* q, TreeNode*&amp; ret)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 设置为1的话就可以隐藏细节，仅仅那个最近的具有最丰富的细节，往上就没了，所以上面就不会再覆盖之前的结果</span></span><br><span class="line">        <span class="keyword">int</span> mid = (node == p || node == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = backTrack(node-&gt;left, p, q, ret) ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = backTrack(node-&gt;right, p, q, ret) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid + left + right &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = node;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid + left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抄的solution T(n) : O(n) <br> S(n) : O(n) 递归堆栈的大小</p>
<p>判断每个节点，当某一结点左边和右边或左边和中间或右边和中间包含目标时，返回那个节点</p>
<h5 id="记录父亲再去遍历">记录父亲再去遍历</h5>
<p>先获取到所有对的父亲，直到p和q的父亲都有了再停止</p>
<p>然后随便挑一个获取到他的所有祖先</p>
<p>另外一个再往回遍历，若有交点，就是解 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line">        parent[root] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(parent.find(p) == parent.end() || parent.find(q) == parent.end()) <span class="comment">// 这里不能用!parent[p] || !parent[q],因为parent[root] = nullptr</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                parent[tmp-&gt;right] = tmp;</span><br><span class="line">                s.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                parent[tmp-&gt;left] = tmp;</span><br><span class="line">                s.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; ancestor;</span><br><span class="line">        <span class="keyword">while</span>(parent.find(p) != parent.end())</span><br><span class="line">        &#123;</span><br><span class="line">            ancestor.insert(p);</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ancestor.find(q) == ancestor.end())</span><br><span class="line">        &#123;</span><br><span class="line">            q = parent[q];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> T(n) : O(n) <br> S(n) : O(n)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>238. Product of Array Except Self</title>
    <url>/2021/07/07/238.%20Product%20of%20Array%20Except%20Self/</url>
    <content><![CDATA[<h4 id="product-of-array-except-self"><a href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        ret.front() = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            ret[i] = ret[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] *= right * nums[i + <span class="number">1</span>];</span><br><span class="line">            right *= nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于数 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Numbers:     2    3    4     5</span><br><span class="line">Lefts:            2  2*3 2*3*4</span><br><span class="line">Rights:  3*4*5  4*5    5      </span><br></pre></td></tr></table></figure> 由此可见对于一个数的乘积，只需要计算他左边所有数的乘积和右边所有数的乘积，两者相乘就可以获得除了这个数外的乘积，而对于每一位来说，左右乘积都可以通过O(n)的两次遍历来达到，O(n)space的算法就是把左右的乘积放到left和right两个数组中</p>
<p>如果要将O(n)space降低到O(1)space，就需要把左乘积先存放在返回的数组中，然后从右往前遍历，对于每一个位置都在每次遍历时计算出一个右乘积，这个乘积ret中保存的左乘积，就可以直接得到答案</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>239. Sliding Window Maximum</title>
    <url>/2021/05/06/239.%20Sliding%20Window%20Maximum/</url>
    <content><![CDATA[<h4 id="sliding-window-maximum"><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front() &lt; i - k + <span class="number">1</span>)</span><br><span class="line">                dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i])</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">                ret.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用双向序列，先加入的在序列头，后加入的在序列尾。当序列头中坐标小于i-k+1时，这个元素对于目前的窗口已经没用了，将其舍弃掉。对于其他的元素，从尾部移掉所有小于当前值的元素，因为对于<code>a[x] &lt; a[i] &amp;&amp; x &lt; i</code>，后面的窗口可以使用<code>a[i]</code>而不是<code>a[x]</code>。由此一来序列头永远都是当前窗口最大项。</p>
<p>为什么从尾部移除小于当前值的元素而不是从头部呢？ &gt; 只需要想清楚要移除的是<code>a[x] &lt; a[i] &amp;&amp; x &lt; i</code>，因此在插入一个元素前把前面的无用项全都丢了再插入，当然是从后面开始往前删。<code>a[x] &gt; a[i] &amp;&amp; x &lt; i</code>的元素对后面是有用的</p>
<figure>
<img src="https://image.cinte.cc/2021/05/06/0bf7c9025d7a9.png" alt="1620305144539.png" /><figcaption aria-hidden="true">1620305144539.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2021/03/15/24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<h4 id="swap-nodes-in-pairs"><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* point = head;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> ListNode();</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(point != <span class="literal">nullptr</span> &amp;&amp; point-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* n2 = point-&gt;next;</span><br><span class="line">            ListNode* next = n2-&gt;next;</span><br><span class="line">            n2-&gt;next = point;</span><br><span class="line">            point-&gt;next = next;</span><br><span class="line">            pre-&gt;next = n2;</span><br><span class="line">            pre = point;</span><br><span class="line">            point = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="discussion-递归">discussion 递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next ==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* n = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        n-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>240. Search a 2D Matrix II</title>
    <url>/2021/04/20/240-Search%20-a-2D-Matrix-II/</url>
    <content><![CDATA[<h4 id="search-a-2d-matrix-ii"><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. Search a 2D Matrix II</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.size() &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target)</span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>从第一行的最后一个元素开始，如果这个元素比target大，那么让j减小，减小到这个元素比target小，因为<code>matrix[i][j + 1] &gt; target</code>，所以这一列及以后都可以被抛弃了</p>
<p>如果当前元素比target小，那么让i增加，由于<code>matrix[i - 1][j] &lt; target</code>表明上一行，在经过列筛选后的上限都低于target，因此也可以被抛弃了。</p>
<p>重复上述，不断抛弃列和行，如得到相等，则找到了，若无则未找到</p>
<p>j从最后一列而i从0开始是为了可以使得i和j的<strong>判断条件分离</strong>，若两者都是从0或从最大开始，那么他们的抛弃条件同为<或>，导致无法很好的分开操作2者</p>
<p>真的太棒了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2021/08/31/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="k-个一组翻转链表"><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4>
<p>递归</p>
<p>递归栈需要O(n / k)的空间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> tail = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pt = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!pt)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pt = pt-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = reverseKGroup(head, k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* pseudoHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        pseudoHead-&gt;next = head;</span><br><span class="line">        ListNode* tail;</span><br><span class="line">        <span class="keyword">auto</span> pre = pseudoHead;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* hair = pre;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(!pre)</span><br><span class="line">                    <span class="keyword">return</span> pseudoHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> next = pre-&gt;next;</span><br><span class="line">            tie(head, tail) = reverse(hair-&gt;next, next);</span><br><span class="line">            hair-&gt;next = head;</span><br><span class="line">            tail-&gt;next = next;</span><br><span class="line">            pre = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pseudoHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; reverse(ListNode* head, ListNode* tail)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pt = head;</span><br><span class="line">        <span class="keyword">while</span>(pt != tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = pt-&gt;next;</span><br><span class="line">            pt-&gt;next = pre;</span><br><span class="line">            pre = pt;</span><br><span class="line">            pt = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;pre, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>264. Ugly Number II</title>
    <url>/2021/05/17/264.%20Ugly%20Number%20II/</url>
    <content><![CDATA[<h4 id="ugly-number-ii"><a href="https://leetcode.com/problems/ugly-number-ii/">264. Ugly Number II</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, l3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t1 = dp[l1] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> t2 = dp[l2] * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">auto</span> t3 = dp[l3] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = min(min(t1, t2), t3);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == t1)</span><br><span class="line">                ++l1;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == t2) <span class="comment">// 去重，如果一个值在当前回合是最小值，那么如果存在重复，在下一回合中他也是最小值，因此需要去重。不能用else if</span></span><br><span class="line">                ++l2;       <span class="comment">// 不仅仅是去重，还需要指针的移动</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == t3)</span><br><span class="line">                ++l3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>维护三个序列，分别是x2，x3，x5的序列。其中通过l1,l2,l3表示</p>
<p>这三个序列通过指针的位置来表示，当这个序列的用完后，根据dp中由小到大排，那么移动到下一个作为下一个的候选</p>
<p>之所以可以这样是因为dp已经帮助我们实现排序，因此只需要应用之前的排序结果，取了其中一个序列的一个值后，把他移动到序列的下一个位置，也就是ugly number种刚好比他大的一个数。注意三个数的序列可能会发生重叠。因此需要去重处理。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>275. H 指数 II</title>
    <url>/2021/07/12/275.%20H%20%E6%8C%87%E6%95%B0%20II/</url>
    <content><![CDATA[<h4 id="h-指数-ii"><a href="https://leetcode-cn.com/problems/h-index-ii/">275. H 指数 II</a></h4>
<h5 id="二分">二分</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = citations.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = sz;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid] &lt; sz - mid)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sz - hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>279. Perfect Squares</title>
    <url>/2021/04/02/279-Perfect-Squares/</url>
    <content><![CDATA[<h4 id="perfect-squares"><a href="https://leetcode.com/problems/perfect-squares/">279. Perfect Squares</a></h4>
<h5 id="backtrack-超时了虽然可以运行但是太慢了">backTrack 超时了，虽然可以运行但是太慢了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        backTrack(n, count, temp);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span>&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            count = min(count, temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="built_in">sqrt</span>(n); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++temp;</span><br><span class="line">            backTrack(n - i * i, count, temp);</span><br><span class="line">            --temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, INT_MAX - <span class="number">1</span>)</span></span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">1</span>; j * j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[i] = min(cnt[i - j * j] + <span class="number">1</span>, cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn) <br> S(n) : O(n)</p>
<p>动态规划 ： 用数组存储子问题的值，用子问题的值直接得到现在问题的值</p>
<h5 id="bfs">BFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整体转化为对一个图的BFS</span></span><br><span class="line">        <span class="comment">// 当且仅当节点I和节点J相差一个perfect square number的时候，两点连线</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">// 访问过的点 </span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefectNumber; </span><br><span class="line">        <span class="comment">// 先计算低于n的所有完全平方数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            prefectNumber.push_back(i * i);</span><br><span class="line">            visited[i * i - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果n本身就是完全平方数，那就直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(prefectNumber.back() == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 这是第一圈，先把所有完全平方数push进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : prefectNumber)</span><br><span class="line">            q.push(num);</span><br><span class="line">        <span class="comment">// 开始往外扩圈</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = q.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : prefectNumber)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 首次碰到等于n的那一圈就是所要求的最小值</span></span><br><span class="line">                    <span class="keyword">if</span>(num + p == n)</span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                    <span class="comment">// 访问过的点不需要再去访问，反之去访问并把这个点加入到下一圈要访问的候选</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(num + p &lt; n &amp;&amp; !visited[num + p - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[num + p - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                        q.push(num + p);</span><br><span class="line">                    <span class="comment">// 大于n的节点无需访问，由于存着的完全平方数是递增的，所以可以直接跳出循环。</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num + p &gt; n)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一圈一圈地往外找</p>
<h5 id="math借助legendres-three-square-theorem">math，借助<a href="https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem">Legendre's three-square theorem</a></h5>
<p>摸了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>283. Move Zeroes</title>
    <url>/2021/04/14/283-Move-Zeroes/</url>
    <content><![CDATA[<h4 id="move-zeroes"><a href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes</a></h4>
<p>两步： 1. 保持原顺序 2. 零在最后面</p>
<p>总体思路<br> 先实现1后实现2，需要认识到如下之点</p>
<p>The 2 requirements of the question are:</p>
<ol type="1">
<li><p>Move all the 0's to the end of array.</p></li>
<li><p>All the non-zero elements must retain their original order.</p></li>
</ol>
<p>It's good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</p>
<h5 id="很直观的方法但有时也是非常好用的办法">很直观的方法，但有时也是非常好用的办法。</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">        <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            numOfZero += (num == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num :nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                ans.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz - numOfZero; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        fill(nums.begin() + sz - numOfZero, nums.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<h5 id="对上述方法优化空间占用">对上述方法优化空间占用</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> noZeroIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num :nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                nums[noZeroIndex++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        fill(nums.begin() + noZeroIndex, nums.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) S(n) : O(1)</p>
<h5 id="再优化由于上面需要执行完n次操作还可以优化">再优化，由于上面需要执行完N次操作，还可以优化</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> noZeroIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num :nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                swap(nums[noZeroIndex++], num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) <br> S(n) : O(1) <br></p>
<p>这里仅需要执行非0的个数</p>
<p>由于noZeroIndex和num不同时，noZeroIndex指向的必定是0元素，这时与num进行交换就可以将0元素移动到后头，依次往复，所有的0都会跑到后面去</p>
<p>因为如果是0，noZeroIndex就不会加，就会留着，如果相同，那就是自己加自己。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>287. Find the Duplicate Number</title>
    <url>/2021/04/14/287-Find-the-Duplicate-Number/</url>
    <content><![CDATA[<h4 id="find-the-duplicate-number"><a href="https://leetcode.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a></h4>
<p>很绕，由于不能改数组，这种情况废弃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= nums[mid]) <span class="comment">// 这里不能用不等号，因为只如果全是正确排列的话，这个一定是等号，如果mid左边出现了重复，那么mid的数会不等于mid+1，但是nums[mid] &lt; mid + 1的情况当且仅当重复数出现在左边或本身就是重复数时才会发生。因此这种情况必然是hi=mid。而nums[mid] &gt;= mid + 1时，如果自身是重复数，那么其余的重复数必然出现在他的右边，因为如果在左边的话，那肯定就小于了。如果自身不是，那就是nums[mid] == mid + 1的情况，也肯定在右边。</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid + <span class="number">1</span> &gt; nums[mid])</span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(N) : O(nlogn)</p>
<p>S(n) : O(1)</p>
<h5 id="另一种使用二分">另一种使用二分</h5>
<p>设cnt为数组中<strong>小于等于</strong>当前元素的元素的个数，设重复数为target</p>
<p>将重复的数字看作是插入到了数组中，当插入到了比target小的数中，那么设<code>i &lt; target</code>，cnt[i]必然&lt;i，当插入到了比target大的数中，设<code>j &gt; target</code>，cnt[j]必然&gt;j，因为多了一个比他小的cnt。</p>
<p>如果都正常的话，在<code>1~target-1</code>区间中的数cnt[i]==i，<code>target~n</code>中的数必然&gt;j</p>
<p>由此，在1~n区间内进行二分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">                cnt += num &lt;= mid ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mid)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用cycle有点静态链表的思想其中的链表组成如图">使用cycle，有点静态链表的思想，其中的链表组成如图</h5>
<figure>
<img src="https://image.cinte.cc/2021/04/15/5dfe75d8ed3ce.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>由于位于0处的数字不可能是0，所以他不可能原地跳不出去。 如果碰到一个原地跳不出去的，那就说明已经是环了</p>
<p>最后套用<a href="https://leetcode.cinte.cc/2021/04/12/142-Linked-List-Cycle-II/">142. Linked List Cycle II</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> walker = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> runner = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            walker = nums[walker];</span><br><span class="line">            runner = nums[nums[runner]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(walker != runner);</span><br><span class="line">        </span><br><span class="line">        walker = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(walker != runner)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = nums[walker];</span><br><span class="line">            runner = nums[runner];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> runner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>292. Nim 游戏</title>
    <url>/2021/08/26/292.%20Nim%20%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="nim-游戏"><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a></h4>
<h5 id="我是弱智">我是弱智</h5>
<p>观察规律发现，只要最后给对手剩下4个，我一定赢。反之，对手给你剩下4个时候你一定输</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(n % <span class="number">4</span> == <span class="number">0</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推理</span><br><span class="line"></span><br><span class="line">让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</span><br><span class="line"></span><br><span class="line">同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>295. Find Median from Data Stream</title>
    <url>/2021/05/04/295.%20Find%20Median%20from%20Data%20Stream/</url>
    <content><![CDATA[<h4 id="find-median-from-data-stream295.-find-median-from-data-stream"><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream295. Find Median from Data Stream</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(even)</span><br><span class="line">        &#123;</span><br><span class="line">            large.push(num);</span><br><span class="line">            small.push(large.top());</span><br><span class="line">            large.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            small.push(num);</span><br><span class="line">            large.push(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        even = !even;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(even)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;((small.top() + large.top())) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> small.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    <span class="keyword">bool</span> even = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>small存放小的一半，large存放大的一半，保证small的大小永远等于<code>large.size()</code>或<code>large.size() + 1</code></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>297. Serialize and Deserialize Binary Tree</title>
    <url>/2021/05/04/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
    <content><![CDATA[<h4 id="serialize-and-deserialize-binary-tree"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a></h4>
<h5 id="瞎写懒得看别人写法了">瞎写，懒得看别人写法了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> nodeNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; nodeNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                nodeNum += (p-&gt;left ? <span class="number">1</span> : <span class="number">0</span>) + (p-&gt;right ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">                --nodeNum;</span><br><span class="line">                res += to_string(p-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                res += <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            res += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.back() = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        <span class="keyword">auto</span> nodes = parseString(data);</span><br><span class="line">        TreeNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> leftNotIn = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node : nodes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.empty())</span><br><span class="line">                q.push(root = <span class="keyword">new</span> TreeNode(*node));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> curNode = q.front();</span><br><span class="line">                <span class="keyword">if</span> (!curNode-&gt;left &amp;&amp; leftNotIn)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node)</span><br><span class="line">                        q.push(curNode-&gt;left = <span class="keyword">new</span> TreeNode(*node));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        curNode-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    leftNotIn = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!curNode-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node)</span><br><span class="line">                        q.push(curNode-&gt;right = <span class="keyword">new</span> TreeNode(*node));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        curNode-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    leftNotIn = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigitalOrCharacter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; <span class="string">&#x27;9&#x27;</span> &gt;= ch) || (<span class="string">&#x27;a&#x27;</span> &lt;= ch &amp;&amp; <span class="string">&#x27;z&#x27;</span> &gt;= ch) || ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSplitCondition</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27;,&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; parseString(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; cache;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">auto</span> begin = s.begin();</span><br><span class="line">        <span class="keyword">auto</span> end = s.end() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*begin != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            ++begin;</span><br><span class="line">        <span class="keyword">while</span> (*end != <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            --end;</span><br><span class="line">        ++begin;</span><br><span class="line">        <span class="keyword">for</span> (; begin != end + <span class="number">1</span>; ++begin)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSplitCondition(*begin))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> realNum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> positive = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cache.empty())</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                <span class="keyword">if</span> (cache.front() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    positive = <span class="number">-1</span>;</span><br><span class="line">                    cache.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!cache.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    realNum = realNum * <span class="number">10</span> + <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(cache.front() - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    cache.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (realNum == <span class="number">69560</span>) <span class="comment">// null</span></span><br><span class="line">                    res.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res.push_back(<span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(realNum * positive));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isDigitalOrCharacter(*begin))</span><br><span class="line">            &#123;</span><br><span class="line">                cache.push(*begin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/05/04/17e6eafd0bf31.png" alt="1620118342754.png" /><figcaption aria-hidden="true">1620118342754.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2021/02/02/3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<h4 id="longest-substring-without-repeating-characters"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></h4>
<h5 id="第一次">第一次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre_index = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            max = count &gt; max ? count : max;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.emplace(ch, index++).second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = <span class="built_in">map</span>[ch];</span><br><span class="line">                <span class="built_in">map</span>[ch] = index - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (t - pre_index &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count -= t - pre_index;</span><br><span class="line">                pre_index = t + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = count &gt; max ? count : max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.cinte.cc/2021/02/02/b303f008647ee.png" /></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>300. Longest Increasing Subsequence</title>
    <url>/2021/04/28/300.%20Longest%20Increasing%20Subsequence/</url>
    <content><![CDATA[<h4 id="longest-increasing-subsequence"><a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">std</span>::lower_bound(heap.begin(), heap.end(), num);</span><br><span class="line">            <span class="keyword">if</span>(i == heap.end())</span><br><span class="line">                heap.push_back(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *i = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="不使用stdlower_bound">不使用std::lower_bound</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = binarySearch(heap.begin(), heap.end(), num);</span><br><span class="line">            <span class="keyword">if</span>(i == heap.end())</span><br><span class="line">                heap.push_back(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *i = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.size();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> count = end - begin;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            it = begin;</span><br><span class="line">            step = count / <span class="number">2</span>;</span><br><span class="line">            it += step;</span><br><span class="line">            <span class="keyword">if</span>(*it &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = ++it;</span><br><span class="line">                count -= step + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                count = step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; piles;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> i = binarySearch(piles, <span class="number">0</span>, piles.size(), num);</span><br><span class="line">            <span class="keyword">if</span>(i != piles.size())</span><br><span class="line">                piles[i] = num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                piles.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> piles.size();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>视频介绍:<br> <video src="https://www.youtube.com/watch?v=22s1xxRvy28 " controls="controls" width="500" height="300">Browser Not Support HTML5!</video></p>
<p><img src="https://image.cinte.cc/2021/04/29/69ac0fcca1882.png" alt="1619669700668.png" /> 如图，把所有牌分堆，从左开始寻找，一旦找到他比某个牌堆的顶端少，就放过去，以贪婪原则。</p>
<p>这样分出的排队数量就是里面的最长增长的串，保证这一点可以通过数学归纳法，详情见视频3:43, 直观的理解是因为：<br> <strong>每个排队中的顺序都是依据原数组中顺序递减的，因此，每个牌堆中最多只能取一张牌，因此增长序列长度&lt;=牌堆数</strong></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>leetcode favorite</tag>
      </tags>
  </entry>
  <entry>
    <title>301. 删除无效的括号</title>
    <url>/2021/07/17/301.%20%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="删除无效的括号"><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录左右括号数，当碰到右括号时，若左括号数不为0，那么左括号数减一，表示这是一对合法括号，</span></span><br><span class="line">        <span class="comment">// 若左括号数为0，那么右括号数加一，这是一个需要删除的括号</span></span><br><span class="line">        <span class="comment">// 若遇到左括号，那么由于合法左括号不会出现在右括号之后，因此只需要左括号数加一即可</span></span><br><span class="line">        <span class="comment">// 剩下的左括号数和右括号数就是应当删除的括号数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++leftCount;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(leftCount == <span class="number">0</span>)</span><br><span class="line">                    ++rightCount;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --leftCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始回溯</span></span><br><span class="line">        <span class="built_in">string</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        helper(s, <span class="number">0</span>, tmp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 记录无效的左右括号数</span></span><br><span class="line">    <span class="keyword">int</span> leftCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> index, <span class="built_in">string</span>&amp; tmp, <span class="keyword">int</span> curLeft, <span class="keyword">int</span> curRight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当左括号和右括号全都删掉后，由于回溯过程中保证左括号小于右括号，所以此时必定为合法的。然后使用set去重</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.emplace(tmp).second &amp;&amp; leftCount == <span class="number">0</span> &amp;&amp; rightCount == <span class="number">0</span>) <span class="comment">// 这种似乎会超时，需要用下面那种的写法</span></span><br><span class="line">                ret.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若左括号没有删除完</span></span><br><span class="line">            <span class="keyword">if</span>(leftCount != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删除这个左括号，开始回溯</span></span><br><span class="line">                --leftCount;</span><br><span class="line">                helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">                ++leftCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保留这个左括号，开始回溯</span></span><br><span class="line">            tmp += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            ++curLeft; <span class="comment">// 当前的左括号数+1</span></span><br><span class="line">            helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">            --curLeft;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[index] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只有目前遇到的左括号数&gt;右括号数时，才可以选择删除这个右括号或者保留</span></span><br><span class="line">            <span class="keyword">if</span>(curLeft &gt; curRight)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 与左括号类似</span></span><br><span class="line">                <span class="keyword">if</span>(rightCount != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --rightCount;</span><br><span class="line">                    helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">                    ++rightCount;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                ++curRight;</span><br><span class="line">                helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">                --curRight;</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            <span class="comment">// 当左括号数==右括号数时，只能抛弃这个右括号，不能保留，否则就是无效状态了</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curLeft == curRight)</span><br><span class="line">            &#123;</span><br><span class="line">                --rightCount;</span><br><span class="line">                helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">                ++rightCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 碰到字母，就保留</span></span><br><span class="line">            tmp += s[index];</span><br><span class="line">            helper(s, index + <span class="number">1</span>, tmp, curLeft, curRight);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>精简优化,思路同上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(leftCount == <span class="number">0</span>)</span><br><span class="line">                    ++rightCount;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --leftCount;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++leftCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        helper(s, <span class="number">0</span>, s.size(), <span class="number">0</span>, <span class="number">0</span>, tmp);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ret</span><span class="params">(<span class="built_in">set</span>.begin(), <span class="built_in">set</span>.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> leftCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> index, <span class="keyword">int</span> sz, <span class="keyword">int</span> curLeft, <span class="keyword">int</span> curRight, <span class="built_in">string</span>&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == sz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(leftCount == <span class="number">0</span> &amp;&amp; rightCount == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">set</span>.insert(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ch = s[index];</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> &amp;&amp; leftCount)</span><br><span class="line">        &#123;</span><br><span class="line">            --leftCount;</span><br><span class="line">            helper(s, index + <span class="number">1</span>, sz, curLeft, curRight, tmp);</span><br><span class="line">            ++leftCount;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; rightCount)</span><br><span class="line">        &#123;</span><br><span class="line">            --rightCount;</span><br><span class="line">            helper(s, index + <span class="number">1</span>, sz, curLeft, curRight, tmp);</span><br><span class="line">            ++rightCount;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += ch;</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;)&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            helper(s, index + <span class="number">1</span>, sz, curLeft, curRight, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; curLeft &gt; curRight)</span><br><span class="line">            helper(s, index + <span class="number">1</span>, sz, curLeft, curRight + <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            helper(s, index + <span class="number">1</span>, sz, curLeft + <span class="number">1</span>, curRight, tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="bfs">BFS</h5>
<p>对于一串，每层把每个括号都删掉一次试试看，然后进入下一层，每层删掉的括号是一致的，当一层碰到有效后，把这一层所有有效的加入然后返回。</p>
<p>。。。。不想写（抄</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>304. Range Sum Query 2D - Immutable</title>
    <url>/2021/05/18/304.%20Range%20Sum%20Query%202D%20-%20Immutable/</url>
    <content><![CDATA[<h4 id="range-sum-query-2d---immutable"><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) : dp(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(matrix.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size() + <span class="number">1</span>, <span class="number">0</span>))), rows(matrix.size()), cols(matrix[<span class="number">0</span>].size()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols + <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - dp[row1][col2 + <span class="number">1</span>]- dp[row2 + <span class="number">1</span>][col1] + dp[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>大小加一时为了防止下标越界</p>
<figure>
<img src="https://image.cinte.cc/2021/05/19/7cd0db20fc189.png" alt="1621411468268.png" /><figcaption aria-hidden="true">1621411468268.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>309. 最佳买卖股票时机含冷冻期</title>
    <url>/2021/07/14/309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    <content><![CDATA[<h4 id="最佳买卖股票时机含冷冻期"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4>
<h5 id="dp">dp</h5>
<p>冷冻期的处理：如果前一天卖出股票，这一天就不能卖，如果前一天没卖，这一天就能卖或者不卖。</p>
<p>对于目前的持股状态，根据卖出和不卖出，持有和不持有组合，共有四种情况：</p>
<ol type="1">
<li>我现在有股票，并且当天没卖出</li>
<li>我现在有股票，并且当天卖出了 (违背事实，舍去)</li>
<li>我现在没股票，并且当天没卖出</li>
<li>我现在没股票，并且当天卖出了</li>
</ol>
<p>对于1</p>
<p>​ 由于我现在有并且当天没卖出，所以当天的值就是前一天<code>1</code>情况或者<code>前一天没股票但是买入了</code>，也就是<code>3+今天买入后(冷冻期)</code></p>
<p>对于3</p>
<p>​ 由于我现在没有而且当天也没有，说明我之前就没有，今天也不能买过来，所以我今天的收益就是<code>3</code>和<code>4</code>之中的最大值</p>
<p>对于4</p>
<p>​ 由于我现在没有并且当天卖出了，则今天就不能买入了，所以前一天不能卖出，所以值就是<code>前一天1的情况加上今天卖出的收益</code>。</p>
<p>以上三种状态同步进行，最后最大值会在3，4之间获得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 有股票而且当天没卖出，对应1</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 没股票并且当天没卖出，对应3</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 有股票但当天卖了，对应4，视为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp.back()[<span class="number">1</span>], dp.back()[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>发现只用到了前一天的数据，所以可以把S(n)优化为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">3</span>]&#123;-prices[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>], tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">1</span>], dp[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>leetcode favorite</tag>
      </tags>
  </entry>
  <entry>
    <title>31. Next Permutation</title>
    <url>/2021/05/03/31.%20Next%20Permutation/</url>
    <content><![CDATA[<h4 id="next-permutation"><a href="https://leetcode.com/problems/next-permutation/">31. Next Permutation</a></h4>
<p>题目意思解释: 比如有<code>[9, 5, 6, 4, 1]</code>,代表一个数<code>95641</code>，要找到通过数列中数字组合而成的大于这个数中的最小一个，即<code>96145</code>, <code>[9, 6, 1, 4, 5]</code></p>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> turningPoint = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> justGreater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                turningPoint = i;</span><br><span class="line">                justGreater = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(turningPoint &amp;&amp; nums[i] &gt; nums[turningPoint - <span class="number">1</span>])</span><br><span class="line">                justGreater = i;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(turningPoint)</span><br><span class="line">            swap(nums[justGreater], nums[turningPoint - <span class="number">1</span>]);</span><br><span class="line">        reverse(nums, turningPoint);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">            swap(nums[start++], nums[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要注意到转折点后的序列必然是递减的</p>
<p>寻找序列中第一个满足<code>a[i] &gt; a[i - 1]</code>且其后序列递减的一部分作为转折点，将<code>a[i - 1]</code>和后面递减序列中刚刚好大于<code>a[i - 1]</code>的数<code>a[j]</code>交换，因为<code>a[j - 1] &gt; a[j]</code>其<code>a[j + 1] &lt; a[j]</code>，而<code>a[i - 1] &lt; a[j] &amp;&amp; a[i - 1] &gt; a[j + 1]</code>，所以交换后后面的递减次序不变，为了实现最小，只需要将交换后的后面再升序排列即可。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>312. 戳气球</title>
    <url>/2021/07/17/312.%20%E6%88%B3%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<h4 id="戳气球"><a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球</a></h4>
<h5 id="自上而下">自上而下</h5>
<p><strong>戳气球会导致左右邻居的移动，因此将问题转化为添加气球</strong></p>
<p><code>helper(i, j)</code>表示在<code>i~j</code>这个开区间内添加气球，之所以开区间是因为左右区间设置为边界外，那里的气球是不能戳的，可以考虑到。</p>
<p>然后寻找这个区间添加后值最大的气球，对左右两边继续进行添加，对于每个区间，都会遍历每个值，然后对左右两边进行递归，从而求出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(nums.size() + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(nums.size() + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size() + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            val[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, nums.size() + <span class="number">1</span>, memo, val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi - <span class="number">1</span>) <span class="comment">// 注意这个，由于是开区间，所以当left和right相差1时，内部已经没有元素了，所以返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[lo][hi] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt; hi; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pro = val[lo] * val[i] * val[hi];</span><br><span class="line">            pro += helper(lo, i, memo, val) + helper(i, hi, memo, val);</span><br><span class="line">            memo[lo][hi] = max(memo[lo][hi], pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="自下而上">自下而上</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(nums.size() + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(nums.size() + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size() + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            val[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">        <span class="comment">// 从后面往前，小区间逐渐计算到大区间，之所以要从后往前，是因为如果从前往后的话，那就从大到校了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从i + 2，开始，因为i和j间必须存在一个元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; nums.size() + <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pro = val[i] * val[k] * val[j];</span><br><span class="line">                    <span class="comment">// 由于k&lt;j,所以memo[k]已经可以从之前的i，j遍历结果出来了，当没有元素时候就是0，是base，而k&gt;i，所以memo[k][j]也可以从之前的结果出来了</span></span><br><span class="line">                    pro += memo[i][k] + memo[k][j];</span><br><span class="line">                    memo[i][j] = max(memo[i][j], pro);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>][nums.size() + <span class="number">1</span>]; <span class="comment">// 返回最大区间的解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>313. 超级丑数</title>
    <url>/2021/08/09/313.%20%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h4 id="超级丑数"><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h4>
<p>类似<a href="https://leetcode.cinte.cc/2021/05/17/264.%20Ugly%20Number%20II/">264. Ugly Number II | Cinte's Leetcode Record</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">point</span><span class="params">(primes.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = primes.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n)</span></span>;</span><br><span class="line">        ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> minVal = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                minVal = min(ret[point[j]] * primes[j], minVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(minVal == ret[point[j]] * primes[j])</span><br><span class="line">                    ++point[j];</span><br><span class="line">            ret[i] = minVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>316. 去除重复字母</title>
    <url>/2021/08/19/316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h4 id="去除重复字母"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></h4>
<p><strong>前置知识：</strong></p>
<p>​ 对于一个字符串，如果要从中去除一个字符使得字符串的字典序最小。那么需要去除的是最靠左边的一个<code>s[i] &gt; s[i + 1]</code>的字符串，因为最前面的最字典序影响最大。这个<code>s[i]</code>称为关键字符。</p>
<p>本题不能打乱原来的顺序，且每个字母只出现一次，因为所需的是从头开始遍历，处理遍历到的所有的关键字符。</p>
<p>维护一个栈</p>
<ol type="1">
<li>当栈顶&gt;当前字符时候，删除栈顶。但是因为每个字母都要出现一次，因此当后面这个栈顶字母不再出现时，就不能删除。</li>
<li>当栈顶&lt;当前字符时候，压入栈，但由于不能重复，所以如果栈中已有同个字符，就不压入。</li>
<li>当相等时，不能压入，因为不能重复。</li>
</ol>
<p><strong>为什么要用栈呢</strong></p>
<blockquote>
<p>为了维护字符间以及字符删除后的相邻关系以及字符删除后继续维持原来的顺序，栈是一个非常适合的数据结构。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> visited[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> num[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sz = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            ++num[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() &gt; ch &amp;&amp; num[st.top() - <span class="string">&#x27;a&#x27;</span>] != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --num[st.top() - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                    visited[st.top() - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(ch);</span><br><span class="line">                visited[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                --num[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(st.size(), <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> index = st.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ret[index--] = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <url>/2021/05/10/32.%20Longest%20Valid%20Parentheses/</url>
    <content><![CDATA[<h4 id="longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h4>
<h5 id="stack">stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(st.empty())</span><br><span class="line">                    st.push(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    maxLength = max(maxLength, i - st.top());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stack中存储坐标，括号两端(左端为括号开始的前一个, 右端为当前括号)构成最长的值。先push(-1)是便于计算，每遇到一个)就pop出一个，空的时候就push，为了方便后面计算坐标。</p>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = max(i - st.top() <span class="number">-1</span>, ret);</span><br><span class="line">            <span class="keyword">if</span>(st.size() != <span class="number">1</span> &amp;&amp; s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[st.top()] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    dp[i] = (i - dp[i - <span class="number">1</span>] &gt; <span class="number">1</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = max(maxLen, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于<code>s[i] == ')'</code>这时一个括号要收尾</p>
<ol type="1">
<li>如果<code>s[i - 1] == '('</code>，则<code>dp[i] = dp[i - 2] + 2</code></li>
<li>如果<code>s[i - 1] == ')'</code>，此时如果<code>s[i-1]</code>有配对的<code>'('</code>或者多个合法的配对，那么通过先前这个的长度往前减坐标寻找是否有与<code>s[i]</code>配对的<code>'('</code>若有，则这个与其配对的将之中包裹的合法括号和先前的合法括号连接相加<code>dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2</code></li>
</ol>
<h5 id="review-1">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    dp[i] = (i - <span class="number">2</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">                    dp[i] = (i - dp[i - <span class="number">1</span>] &gt; <span class="number">1</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, dp[i]);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - dp[i + <span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; s[i - dp[i + <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i + <span class="number">2</span>] = dp[i + <span class="number">1</span>] + <span class="number">2</span> + dp[i - dp[i + <span class="number">1</span>]];</span><br><span class="line">                    ret = max(dp[i + <span class="number">2</span>], ret);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                dp[i + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="two-point">two point</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                ++right;</span><br><span class="line">            <span class="keyword">if</span>(left == right)</span><br><span class="line">                maxLength = max(maxLength, <span class="number">2</span> * right);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; left)</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                ++right;</span><br><span class="line">            <span class="keyword">if</span>(left == right)</span><br><span class="line">                maxLength = max(maxLength, <span class="number">2</span> * right);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right &lt; left)</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遇见<code>(</code>就增加left，遇见<code>)</code>就增加right，当二者相等时候，表明所有<code>(</code>和<code>)</code>配对了，计算长度，更新max</p>
<p>从左到右时，当right&gt;left，表示前面遇到的<code>(</code>比<code>)</code>少，因此由于括号的顺序，不可能再长下去了，由此重置left和right继续开始计数</p>
<p>从右往左时，当left&gt;right, 表示前面遇到的<code>)</code>比<code>(</code>少，同理</p>
<p>要从左往右和从右往左都走一遍是因为... 证明：<span class="citation" data-cites="wander">[@wander]</span>(https://leetcode.com/wanders/) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proof of validity for approach 4:</span><br><span class="line"></span><br><span class="line">Let i and j denote the starting and ending indices of the longest valid subsequence.</span><br><span class="line">Note that in the forward pass after (fully) processing each character, it&#39;s always the case that left &gt;&#x3D; right. (*)</span><br><span class="line">This is in particular true after processing i-1 (immediately before processing i).</span><br><span class="line"></span><br><span class="line">Case 1: If immediately before i left &#x3D; right, then the forward pass will detect the length of the longest valid subsequence.</span><br><span class="line">(The number of &#39;(&#39; and &#39;)&#39; is the same for any valid subseq. Thus after processing j, left &#x3D; right.)</span><br><span class="line"></span><br><span class="line">Case 2: If immediately before i left &gt; right, the forward pass will not detect the longest valid subsequence, but we claim the backward pass will.</span><br><span class="line">Similar to observation (*) above, note that right &gt;&#x3D; left after fully processing each element in the backward pass. We detect the longest valid subsequence in the backward pass if and only if right &#x3D; left after processing j+1 (immediately before processing j).</span><br><span class="line">So what if right &gt; left (in the backward pass immediately before processing j)?</span><br><span class="line">Well, then the maximality of our subsequence from i to j would be contradicted.</span><br><span class="line">Namely, we can increase j to j&#39; so that (j,j&#39;] has one more &#39;)&#39; than &#39;(&#39;, and decrease i to i&#39;, so that [i&#39;,i) has one more &#39;(&#39; than &#39;)&#39;.</span><br><span class="line">The resulting subsequence from i&#39; to j&#39; will have longer length and will still be valid (the number of &#39;(&#39; and &#39;)&#39; will be incremented by the same amount).</span><br><span class="line"></span><br><span class="line">Thus, either the backward pass or forward pass (possibly both) will detect the longest valid subsequence.</span><br><span class="line"></span><br><span class="line">Edit: as @papercup points out in response to @bmunot9 , one can take i&#39; &#x3D; i - 1 and j&#39; &#x3D; j + 1, since</span><br><span class="line"></span><br><span class="line">left &gt; right immediately before i in the forward pass implies that s[i] &#x3D;&#x3D; &#39;(&#39;, otherwise maximality would already be contradicted (one could find i0&lt;i such that s[i0,i) is valid, and thus s[i0,j] would be valid). Similarly</span><br><span class="line">right &gt; left immediately after j+1 (before j) in the backward pass implies s[j] &#x3D;&#x3D; &#39;)&#39;</span><br></pre></td></tr></table></figure> 左边走不到的右边必然走的到，否则矛盾，具体见上面</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>322. Coin Change</title>
    <url>/2021/04/21/322-Coin-Change/</url>
    <content><![CDATA[<h4 id="coin-change"><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></h4>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i)</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>33. Search in Rotated Sorted Array</title>
    <url>/2021/03/20/33-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<h4 id="search-in-rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h4>
<h5 id="first-time">First Time</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">        <span class="keyword">auto</span> bias = binarySearch(nums, <span class="number">0</span>, sz - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = sz;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[(mid + bias) % sz] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (nums[(hi + bias) % sz] == target) ? (hi + bias) % sz : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">size_t</span> lo, <span class="keyword">size_t</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[hi])</span><br><span class="line">            &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(logN)</p>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[hi])</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bias = hi;</span><br><span class="line">        lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[(mid + bias) % sz] &gt; target)</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[(mid + bias) % sz] == target)</span><br><span class="line">                <span class="keyword">return</span> (mid + bias) % sz;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>337. House Robber III</title>
    <url>/2021/04/23/337-House-Robber-III/</url>
    <content><![CDATA[<h4 id="house-robber-iii"><a href="https://leetcode.com/problems/house-robber-iii/">337. House Robber III</a></h4>
<p>对于一个节点来说，如果rob这个点，那么他的child就不能rob, 如果不rob，那么他的child可以rob也可以不rob<br> 对于rob这个节点来说，需要计算他的grandchild rob或者不rob的情况，不rob时也需要计算，如果递归则需要重复计算，因此每次的递归函数都计算这一个rob和不rob的情况<br> 用pair保存起来rob和不rob的记过</p>
<p>于是这种情况下就不会产生重复计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = helper(root);</span><br><span class="line">        <span class="keyword">return</span> max(ret.first, ret.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pair&lt;int, int&gt; helper(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> left = helper(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = helper(node-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if rob</span></span><br><span class="line">        <span class="keyword">int</span> rob = node-&gt;val + left.second + right.second;</span><br><span class="line">        <span class="keyword">int</span> notRob = max(left.first, left.second) + max(right.first, right.second);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;rob, notRob&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="approach-1-未改进前的算法使用memo优化">approach 1 未改进前的算法使用memo优化</h5>
<p>如果不用memo，则rob和不rob情况会重复计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(helper(root, <span class="literal">false</span>), helper(root, <span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; robed;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; noRobed;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">bool</span> isRobed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isRobed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(robed.find(node) != robed.end())</span><br><span class="line">                <span class="keyword">return</span> robed[node];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left = helper(node-&gt;left, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">int</span> right = helper(node-&gt;right, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">int</span> ret = node-&gt;val + left + right;</span><br><span class="line">                robed[node] = ret;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(noRobed.find(node) != noRobed.end())</span><br><span class="line">                <span class="keyword">return</span> noRobed[node];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left = max(helper(node-&gt;left, <span class="literal">false</span>), helper(node-&gt;left, <span class="literal">true</span>));</span><br><span class="line">                <span class="keyword">int</span> right = max(helper(node-&gt;right, <span class="literal">false</span>), helper(node-&gt;right, <span class="literal">true</span>));</span><br><span class="line">                <span class="keyword">int</span> ret = left + right;</span><br><span class="line">                noRobed[node] = ret;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp复习时候看不懂了">dp（复习时候看不懂了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pc;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val; <span class="comment">// vector来存放节点的值</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qNode; <span class="comment">// 用来遍历</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qIndex; <span class="comment">// 用来存放节点所对应的指标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        qNode.push(root);</span><br><span class="line">        qIndex.push(index);</span><br><span class="line">        <span class="comment">// 将所有节点的值放入val，每个节点对应index</span></span><br><span class="line">        <span class="keyword">while</span>(!qNode.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 层级遍历</span></span><br><span class="line">            <span class="keyword">auto</span> node = qNode.front();</span><br><span class="line">            qNode.pop();</span><br><span class="line">            <span class="keyword">auto</span> fatherI = qIndex.front();</span><br><span class="line">            qIndex.pop();</span><br><span class="line">            <span class="keyword">if</span>(node)</span><br><span class="line">            &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                pc[fatherI].push_back(index); <span class="comment">// father中放入孩子</span></span><br><span class="line">                val.push_back(node-&gt;val);</span><br><span class="line">                qNode.push(node-&gt;left);</span><br><span class="line">                qNode.push(node-&gt;right);</span><br><span class="line">                qIndex.push(index);</span><br><span class="line">                qIndex.push(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始dp</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpRob</span><span class="params">(index + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpNoRob</span><span class="params">(index + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最后一层开始往上走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pc[i].empty()) <span class="comment">// 叶子节点的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                dpRob[i] = val[i];</span><br><span class="line">                dpNoRob[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dpRob[i] = val[i];</span><br><span class="line">                <span class="comment">// 遍历孩子节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; j : pc[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dpRob[i] += dpNoRob[j]; <span class="comment">// 如果rob，那么就加上前面不rob的</span></span><br><span class="line">                    dpNoRob[i] += max(dpRob[j], dpNoRob[j]); <span class="comment">// 如果不rob，那么前面随便rob还是不rob，取最大值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dpRob[<span class="number">0</span>], dpNoRob[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>base : leaf</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>338. Counting Bits</title>
    <url>/2021/04/14/338-Counting-Bits/</url>
    <content><![CDATA[<h4 id="counting-bits"><a href="https://leetcode.com/problems/counting-bits/">338. Counting Bits</a></h4>
<h5 id="o32n-解法">O(32n) 解法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = i;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 10进制转2进制，每次共32bit</span></span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = cur % <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">1</span>)</span><br><span class="line">                    ++count;</span><br><span class="line">                cur /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用库">使用库</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(__builtin_popcount(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="section"></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; countBits(int num) &#123;</span><br><span class="line">        vector&lt;int&gt; ret(num + 1);</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] &#x3D; ret[i &gt;&gt; 1] + (i &amp; 1); &#x2F;&#x2F; 右移相当于取出了除了最后一位的所有值，如果最后一位为1就加一，最后一位为0，那就和右移后的一样</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>右移加上最后一位，类似动态规划的思想</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2021/03/14/34.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
    <content><![CDATA[<h4 id="find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h4>
<h5 id="first-time">First Time</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> medium = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[medium] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                lo = medium + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[medium] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                hi = medium - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pos = medium;</span><br><span class="line">                <span class="keyword">while</span> (pos &gt; <span class="number">0</span> &amp;&amp; nums[pos] == nums[pos - <span class="number">1</span>]) --pos;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;pos, i - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="second-time">Second time</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> posL = <span class="number">-1</span>, posR = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> medium = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[medium] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                lo = medium + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[medium] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                hi = medium - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                posL = posR = medium;</span><br><span class="line">                <span class="keyword">while</span> (posL &gt; <span class="number">0</span> &amp;&amp; nums[posL] == nums[posL - <span class="number">1</span>]) --posL;</span><br><span class="line">                <span class="keyword">while</span> (posR &lt; size - <span class="number">1</span> &amp;&amp; nums[posR] == nums[posR + <span class="number">1</span>]) ++posR; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;posL, posR&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="solution">Solution</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(left == nums.size() || nums[left] != target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;left, binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">bool</span> isLeft)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> med = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[med] &gt; target || (isLeft &amp;&amp; nums[med] == target))</span><br><span class="line">            &#123;</span><br><span class="line">                hi = med;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lo = med + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[lo] != target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left = lo;</span><br><span class="line">        lo = <span class="number">0</span>;</span><br><span class="line">        hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                lo = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left, hi&#125;;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中第一次往左找，第二次的mid+1是为了使mid偏向右边，从而找到最右的</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>343. Integer Break</title>
    <url>/2021/05/19/343.%20Integer%20Break/</url>
    <content><![CDATA[<h4 id="integer-break"><a href="https://leetcode.com/problems/integer-break/">343. Integer Break</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i - j]));</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于一个数，截成两段，挨个尝试，每一段由于那个数字在运算时候是不计算他本身的，所以后面用时候需要比较他自己和他break后谁打，所以要有这么多max</p>
<h5 id="数学方法优化">数学方法优化</h5>
<p><a href="https://leetcode.com/problems/integer-break/discuss/80721/Why-factor-2-or-3-The-math-behind-this-problem.">discussion</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You&#39;re making it pretty complicated.</span><br><span class="line"></span><br><span class="line">If an optimal product contains a factor f &gt;&#x3D; 4, then you can replace it with factors 2 and f-2 without losing optimality, as 2*(f-2) &#x3D; 2f-4 &gt;&#x3D; f. So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you&#39;d only use it for n&#x3D;2 and n&#x3D;3, where it&#39;s needed).</span><br><span class="line"></span><br><span class="line">For the rest I agree, 3*3 is simply better than 2*2*2, so you&#39;d never use 2 more than twice.</span><br><span class="line"></span><br><span class="line">6 &#x3D; 2 + 2 + 2 &#x3D; 3 + 3. But 2 * 2 * 2 &lt; 3 * 3.</span><br><span class="line">Therefore, if there are three 2&#39;s in the decomposition, we can replace them by two 3&#39;s to gain a larger product.</span><br></pre></td></tr></table></figure> 存在大于4的因子时候，他永远可以被拆到小于4，因此只需要1，2，3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">            dp[i] = max(<span class="number">3</span> * max(i - <span class="number">3</span>, dp[i - <span class="number">3</span>]) ,max(dp[i - <span class="number">1</span>], <span class="number">2</span> * max(i - <span class="number">2</span>, dp[i - <span class="number">2</span>]))); <span class="comment">// 此处dp[i - 1]而不是max(dp[i - 1], i - 1)是因为i&gt;3时，2 * (i - 2) &gt; 1 * (i - 1)</span></span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>347. Top K Frequent Elements</title>
    <url>/2021/07/12/347.%20Top%20K%20Frequent%20Elements/</url>
    <content><![CDATA[<h4 id="top-k-frequent-elements"><a href="%5B(1)%20Top%20K%20Frequent%20Elements%20-%20LeetCode%5D(https://leetcode.com/problems/top-k-frequent-elements/)">347. Top K Frequent Elements</a></h4>
<h5 id="quick-select">Quick Select</h5>
<p>快速排序，每次只排一半</p>
<p>T(n) : <a href="https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2871/">(1) Explore - LeetCode</a></p>
<p>b = 2, d=1,a=1</p>
<p>T(n) = T(n/2) + f(n)=T(n/2)+T(n)</p>
<figure>
<img src="https://image.cinte.cc/2021/07/13/1743ba8b9de75.png" alt="1626147961860.png" /><figcaption aria-hidden="true">1626147961860.png</figcaption>
</figure>
<p>那么T(n) 为 O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            <span class="built_in">map</span>[num] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : <span class="built_in">map</span>)</span><br><span class="line">            unique.push_back(it.first);</span><br><span class="line">        sort(<span class="number">0</span>, unique.size() - <span class="number">1</span>, unique.size() - k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="comment">// for(int i = unique.size() - 1; i &gt;= unique.size() - k; --i) // 注意这种情况是错误的，当unique.siez() - k为0时，因为unique.size()是无符号数，而i是有符号数，i与unique.size() - k比较时将会自动转换为无符号数比较，这时的i是一个极大的无符号数，将导致i为负数时仍旧成立，解决方法可以先将unique.size()转为int</span></span><br><span class="line">        <span class="comment">//     ret.push_back(unique[i]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = unique.end() - <span class="number">1</span>; i != unique.end() - <span class="number">1</span> - k; --i)</span><br><span class="line">            ret.push_back(*i);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unique;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> pivot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        swap(unique[pivot], unique[lo]);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">map</span>[unique[lo]];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; <span class="built_in">map</span>[unique[++i]] &lt; c) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; lo &amp;&amp; <span class="built_in">map</span>[unique[--j]] &gt; c) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(unique[i], unique[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(unique[j], unique[lo]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> pivot = lo + (rand() % (hi - lo + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">auto</span> j = patition(lo, hi, pivot);</span><br><span class="line">        <span class="keyword">if</span>(j == k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; k)</span><br><span class="line">            sort(lo, j - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sort(j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>35. Search Insert Position</title>
    <url>/2021/03/21/35-Search-Insert-Position/</url>
    <content><![CDATA[<h4 id="search-insert-position"><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(logN) <br> S(n) : O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>36. Valid Sudoku</title>
    <url>/2021/03/22/36-Valid-Sudoku/</url>
    <content><![CDATA[<h4 id="valid-sudoku"><a href="https://leetcode.com/problems/valid-sudoku/">36. Valid Sudoku</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sz = board.size();</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[i][num - <span class="number">49</span>] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        row[i][num - <span class="number">49</span>] += <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(col[num - <span class="number">49</span>][j] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        col[num - <span class="number">49</span>][j] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(block[i / <span class="number">3</span>][j / <span class="number">3</span>][num - <span class="number">49</span>] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        block[i / <span class="number">3</span>][j / <span class="number">3</span>][num - <span class="number">49</span>] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T : O(1) S : O(1)</p>
<h5 id="more">more</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sz = board.size();</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[i][num - <span class="number">49</span>] || col[num - <span class="number">49</span>][j] || block[i / <span class="number">3</span>][j / <span class="number">3</span>][num - <span class="number">49</span>])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        row[i][num - <span class="number">49</span>] = col[num - <span class="number">49</span>][j] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][num - <span class="number">49</span>] =  <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>37. Sudoku Solver</title>
    <url>/2021/03/25/37-Sudoku-Solver/</url>
    <content><![CDATA[<h4 id="sudoku-solver"><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    col[num - <span class="number">49</span>][j] += <span class="number">1</span>;</span><br><span class="line">                    row[i][num - <span class="number">49</span>] += <span class="number">1</span>;</span><br><span class="line">                    block[i / <span class="number">3</span>][j / <span class="number">3</span>][num - <span class="number">49</span>] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[target][j] || row[i][target] || block[i / <span class="number">3</span> ][j /<span class="number">3</span>][target])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> solve(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> solve(board, i, j + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; num = board[i][j];</span><br><span class="line">            <span class="keyword">if</span>(valid(i, j, c - <span class="number">49</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                num = c;</span><br><span class="line">                col[num - <span class="number">49</span>][j] = row[i][num - <span class="number">49</span>] = block[i / <span class="number">3</span> ][j /<span class="number">3</span>][num - <span class="number">49</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(solve(board, i, j + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                col[num - <span class="number">49</span>][j] = row[i][num - <span class="number">49</span>] = block[i / <span class="number">3</span> ][j /<span class="number">3</span>][num - <span class="number">49</span>] = <span class="number">0</span>;</span><br><span class="line">                num = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(N)</p>
<p>也是一个回溯的问题，但与combined sum不同的是这个回溯只得使用return 来作为停止条件，而combined sum中则以添加到vector中为结束。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>378. Kth Smallest Element in a Sorted Matrix</title>
    <url>/2021/07/12/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix/</url>
    <content><![CDATA[<h4 id="kth-smallest-element-in-a-sorted-matrix"><a href="%5B(1)%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix%20-%20LeetCode%5D(https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)">378. Kth Smallest Element in a Sorted Matrix</a></h4>
<h5 id="使用堆只应用了行递增而没有用列递增">使用堆（只应用了行递增而没有用列递增）</h5>
<p>对于矩阵</p>
<p>借助归并排序思想，把每一行视为一个递增序列，如果归并的话，就是把每一行归并序列合并为一个递增序列，但这题并不需要实现完整的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  5   9</span><br><span class="line">10 11 13</span><br><span class="line">12 13 15</span><br></pre></td></tr></table></figure>
<p>可以先窥探第一列，第一列是每一个行序列的最小值所组成的，因此第一列中的最小值毫无疑问是1，这里可以先弹出1，矩阵变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   5  9</span><br><span class="line">10 11 13</span><br><span class="line">12 13 15</span><br></pre></td></tr></table></figure>
<p>若要继续判断，只需要判断<code>5, 10, 12</code>中的最小值，然后继续弹出最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      9</span><br><span class="line">10 11 13</span><br><span class="line">12 13 15</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line">10 11 13</span><br><span class="line">12 13 15</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   11 13</span><br><span class="line">12 13 15</span><br></pre></td></tr></table></figure>
<p>所以需要一个优先级队列来维护顶头最小，下面最大的一个堆，并且每个堆中的元素需要记录这个元素在矩阵中的坐标，从而可以在弹出后用它右边的元素接替。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Ele, <span class="built_in">vector</span>&lt;Ele&gt;, less&lt;Ele&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            pq.push(Ele(matrix[i][<span class="number">0</span>], i, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.y == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pq.push(Ele(matrix[p.x][p.y + <span class="number">1</span>], p.x, p.y + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top().val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ele</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        Ele(<span class="keyword">int</span> val, <span class="keyword">int</span> x, <span class="keyword">int</span> y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ele&amp; ele) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &gt; ele.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/07/13/1249885fbe47b.png" alt="1626163371546.png" /><figcaption aria-hidden="true">1626163371546.png</figcaption>
</figure>
<p>less：当左边小于右边时，return true</p>
<p>priority_queue：当新进来的数导致了顺序错误，则return true。此处是新进来的数如果大于顶头的数，就return true。</p>
<p>因此类中应当重载<code>&lt;</code>操作符，当左边小于右边时return false，也就是左边大于右边时return true。</p>
<p><code>lhs &lt; rhs</code>时，调用的是lhs的重载操作符，所以需要lhs&gt;rhs返回true，所以是this-&gt;val&gt;ele.val。</p>
<h5 id="使用二分查找">使用二分查找</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix.back().back();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> mid = (hi + lo) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">auto</span> num = check(matrix, mid);</span><br><span class="line">            <span class="comment">// 如果使用num == k时候就返回，就会导致mid可能不是这区间里数</span></span><br><span class="line">            <span class="keyword">if</span>(num &gt;= k)</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; k)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt;= mid)</span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="怎么保证最后的值是矩阵中的值">怎么保证最后的值是矩阵中的值?</h6>
<p>若right不在矩阵中</p>
<ol type="1">
<li>当mid恰好大于解一点点的话，最终得到的面积会与k相等，解位于lo~mid内，这时候令hi=mid</li>
<li>当mid恰好小于解一点点的话，最终得到的面积会小于k，这时候hi不变，lo变为mid+1，为什么lo不是mid呢，因为当取lo==mid时，由于c++中除法向下取整，所以会导致无限循环。而hi如果取mid-1，就会导致区间将不再包括hi。而lo取mid+1则不会，因为这种情况下mid+1~hi中肯定有解。</li>
</ol>
<p>如果right在矩阵中</p>
<p>​ 与上述类似</p>
<p>所以，根据上述情况，<strong>解可以始终保证位于区间lo~hi之中</strong>，当lo和hi相等之时，就可以保证他们必定为解。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>38. 外观数列</title>
    <url>/2021/08/25/38.%20%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h4 id="外观数列"><a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h4>
<h5 id="模拟">模拟</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> pre = ret[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, sz = ret.size(); j &lt; sz; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ret[j] != pre)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += (<span class="keyword">char</span>)(num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    tmp += pre;</span><br><span class="line">                    pre = ret[j];</span><br><span class="line">                    num = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp += (<span class="keyword">char</span>)(num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            tmp += pre;</span><br><span class="line">            ret = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>387. First Unique Character in a String</title>
    <url>/2021/03/15/387-first-unique-character-in-a-string/</url>
    <content><![CDATA[<h4 id="first-unique-character-in-a-string"><a href="https://leetcode.com/problems/first-unique-character-in-a-string/">387. First Unique Character in a String</a></h4>
<h5 id="first-time">First Time</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.emplace(s[i], i).second)</span><br><span class="line">                <span class="built_in">map</span>[s[i]] = <span class="number">-1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[ch] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">map</span>[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="second-time">Second Time</h5>
<p>数组由于直接获取内存地址而不需要散列，是更快的O(N) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstUniqChar(string s) &#123;</span><br><span class="line">        int eng[26]&#123;0&#125;;</span><br><span class="line">        for(auto&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            eng[ch - &#39;a&#39;] +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for(auto&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            if(eng[ch - &#39;a&#39;] &#x3D;&#x3D; 1)</span><br><span class="line">                return i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### 尝试只进入一次(还是很慢) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.emplace(s[i]).second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>.erase(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">map</span>.size() ? <span class="built_in">map</span>.begin()-&gt;second : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">map</span>.begin(); i != <span class="built_in">map</span>.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            j = min(j, i-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>39. Combination Sum</title>
    <url>/2021/03/22/39-Combination-Sum/</url>
    <content><![CDATA[<h4 id="combination-sum"><a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h4>
<h5 id="backtrack"><a href="https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)">backTrack</a></h5>
<blockquote>
<p>摘自wiki: 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        backTrack(ret, candidates, temp, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start; i &lt; candidates.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(candidates[i]);</span><br><span class="line">            backTrack(ret, candidates, temp, remain - candidates[i], i);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>394. Decode String</title>
    <url>/2021/04/15/394-Decode-String/</url>
    <content><![CDATA[<h4 id="decode-string"><a href="https://leetcode.com/problems/decode-string/">394. Decode String</a></h4>
<h5 id="我越来越菜了">我越来越菜了</h5>
<p>由于括号是包裹的，后出现的左括号会匹配后面遇到的第一个右括号，所以使用堆栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st; <span class="comment">// 保存遇到方括号之前的字符串</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num; <span class="comment">// 保存方括号前的计数</span></span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(ret); <span class="comment">// 遇到方括号开端后，先压入当前字符串，当进入方括号过程中中再次遇到，就会压入先前方括号开端到此方括号之间的字符串</span></span><br><span class="line">                num.push(curNum); <span class="comment">// 计数值同理</span></span><br><span class="line">                curNum = <span class="number">0</span>; <span class="comment">// 此方括号计数已经入栈，所以开始下一轮计数</span></span><br><span class="line">                ret = <span class="string">&quot;&quot;</span>; <span class="comment">// 开始计算方括号中的字符串</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = st.top(); <span class="comment">// 遇见结尾，出栈，先把这个方括号之前，上一个方括号之后的字符串出栈</span></span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">auto</span> c = num.top(); <span class="comment">// 当前方括号的计数值出栈</span></span><br><span class="line">                num.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">                    p += ret; <span class="comment">// 之前的加上当前括号的值，代表了前一个大括号所包含的字符串</span></span><br><span class="line">                ret = p;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                curNum = curNum * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="递归">递归</h5>
<p>本质上就是将堆栈方法改为了函数递归栈实现，碰到]就返回，碰到[就进去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[index] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[index] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[index] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                ret += s[index++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(s[index] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[index] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    num = num * <span class="number">10</span> + s[index++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++index;</span><br><span class="line">                <span class="keyword">auto</span> t = helper(s, index);</span><br><span class="line">                <span class="keyword">while</span>(num-- &gt; <span class="number">0</span>)</span><br><span class="line">                    ret += t;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>处理一个框框中的数据，框框里遇到框框就再递归</p>
<p>review <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, i, s.size());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; i, <span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curTime = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> r;</span><br><span class="line">        <span class="keyword">for</span>(i; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ch = s[i];</span><br><span class="line">            <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                curTime = curTime * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = helper(s, ++i, sz);</span><br><span class="line">                <span class="keyword">if</span>(curTime == <span class="number">0</span>)</span><br><span class="line">                    curTime = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curTime; ++j)</span><br><span class="line">                    r.append(tmp);</span><br><span class="line">                curTime = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>399. 除法求值</title>
    <url>/2021/07/14/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h4 id="除法求值"><a href="%5B399.%20除法求值%20-%20力扣（LeetCode）%20(leetcode-cn.com)%5D(https://leetcode-cn.com/problems/evaluate-division/)">399. 除法求值</a></h4>
<p>直接看<a href="%5B🎦%20399.%20除法求值%20-%20除法求值%20-%20力扣（LeetCode）%20(leetcode-cn.com)%5D(https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/)">解析</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(equations.size() * <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = equations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">auto</span> b = equations[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.emplace(a, id).second)</span><br><span class="line">                ++id;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.emplace(b, id).second)</span><br><span class="line">                ++id;</span><br><span class="line">            </span><br><span class="line">            uf.doUnion(<span class="built_in">map</span>[a], <span class="built_in">map</span>[b], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; query : queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(query[<span class="number">0</span>]) != <span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>.find(query[<span class="number">1</span>]) != <span class="built_in">map</span>.end())</span><br><span class="line">                <span class="comment">// map如果其中不包含值会初始化为0，因此这里需要先判断</span></span><br><span class="line">                ret.push_back(uf.isConnect(<span class="built_in">map</span>[query[<span class="number">0</span>]], <span class="built_in">map</span>[query[<span class="number">1</span>]]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret.push_back(<span class="number">-1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            UnionFind(<span class="keyword">int</span> size) : parent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size)), weights(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(size, <span class="number">1.0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">                    parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 归并，如果已经连接了，那就算了，如果没有连接，由于他们出现在同一式中，因此必定可以建立连接。如果他们的根没有连接那就计算一下然后连接，在find操作时会执行路径压缩</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">doUnion</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> val)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">                <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">                <span class="keyword">if</span>(rootX == rootY)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                weights[rootX] = weights[y] * val / weights[x];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 如果连在同一个父节点就是有值</span></span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">isConnect</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">                <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">                <span class="keyword">if</span>(rootX == rootY)</span><br><span class="line">                    <span class="keyword">return</span> weights[x] / weights[y];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; weights;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	<span class="comment">// 寻找父节点顺便路径压缩</span></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(x != parent[x])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> ori = parent[x];</span><br><span class="line">                    parent[x] = find(parent[x]);</span><br><span class="line">                    weights[x] *= weights[ori];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Median of Two Sorted Arrays</title>
    <url>/2021/03/05/4-Median-of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<h4 id="median-of-two-sorted-arrays"><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">            swap(m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[n / <span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums2[n / <span class="number">2</span>] + nums2[n / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imin = <span class="number">0</span>, imax = m;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (imin &lt;= imax) <span class="comment">// 相等后进入最后计算一次，然后得出解</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (imin + imax) / <span class="number">2</span>, j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i; <span class="comment">// 推导过程中假设是奇数的情况让左边多一个，则i + j = m + n - i - j，如果是偶数那就相同，此时由于这个除法是向下取整的，所以偶数和奇数情况可以合并</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (nums1[i - <span class="number">1</span>] &gt; nums2[j]))   <span class="comment">// 本来是需要i&gt;0 &amp;&amp; j &lt; n，但是由于满足n &gt;= m，当i &gt; 0时，j = (m + n + 1) / 2 - i &lt;= (m + n + 1) / 2 &lt;= (m + n + 1) / 2 &lt;= m + 1/2 &lt; m            &#123;</span></span><br><span class="line">                imax = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; m &amp;&amp; (nums2[j - <span class="number">1</span>] &gt; nums1[i])) <span class="comment">// j &gt; 0 &amp;&amp; i &lt; m, 同上证明</span></span><br><span class="line">            &#123;</span><br><span class="line">                imin = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 几种边缘情况处理</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    left = nums2[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    left = nums1[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == m)</span><br><span class="line">                &#123;</span><br><span class="line">                    right = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    right = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right = min(nums1[i], nums2[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> left; <span class="comment">// 假设的是左半边多一个</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>40. Combination Sum II</title>
    <url>/2021/03/23/40-Combination-Sum-II/</url>
    <content><![CDATA[<h4 id="combination-sum-ii"><a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        backTrack(ret, candidates, temp, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start; i &lt; candidates.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(candidates[i]);</span><br><span class="line">            backTrack(ret, candidates, temp, remain - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; candidates.size() &amp;&amp; candidates[i] == candidates[i+<span class="number">1</span>])</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>406. Queue Reconstruction by Height</title>
    <url>/2021/04/14/406-Queue-Reconstruction-by-Height/</url>
    <content><![CDATA[<h4 id="queue-reconstruction-by-height"><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h4>
<h5 id="o32n-解法">O(32n) 解法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> p1[<span class="number">0</span>] &gt; p2[<span class="number">0</span>] || (p1[<span class="number">0</span>] == p2[<span class="number">0</span>] &amp;&amp; p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>]); </span><br><span class="line">             &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : people)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.insert(ret.begin() + p[<span class="number">1</span>], p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先插入最高的人，最高的人组成的子序列所排列的顺序一定是由其K所决定的，当插入第二大的序列后，他不会影响第一大的序列，且仅仅由其本身和比他的序列影响，由其相对位置插入，可知，当为0时，就插到比他大的0前面，为1时，就插到比他大的1前面，比他大的那个往后移一位</p>
<p>结合<a href="https://leetcode.com/problems/queue-reconstruction-by-height/discuss/89359/Explanation-of-the-neat-Sort%2BInsert-solution">explaination</a></p>
<p>最后一个人的位置不会影响前面的人，但前面人的位置将影响到最后一个人，因此最后一个人的k必定表示其绝对位置，将其划分为一堆的子问题，每个子问题在解决时都先忽略子问题中最小的的那个数，那个数在所有其他数排列完后再插入那个绝对的位置。 依此，则从最大数开始排起，后面插入的数对于先前的序列来说必定是插入其的K位置，不断扩大子问题，往复，直到整个序列往复。最小的数插入到其的K位置。</p>
<p>中心思想：最小的数的k必定表示其在结果中的绝对位置，抛开这个最小的数，生成一个子问题。再抛开子问题中最小的数，生成一个子-子问题......</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>41. First Missing Positive</title>
    <url>/2021/05/10/41.%20First%20Missing%20Positive/</url>
    <content><![CDATA[<h4 id="first-missing-positive"><a href="https://leetcode.com/problems/first-missing-positive/">41. First Missing Positive</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= sz &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) <span class="comment">// 这里之所以使用nums[i] != nums[nums[i] - 1]而不是nums[i] != i + 1, 是为了防止2个相同的数出现在这两处。这里是让当前的数字搬到正确的地方去，而不是让当前地方具有正确的数字。因为如果当前地方的数字缺失，那么永远也出不了循环。</span></span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个长度为n的数列中，如果所有正数都没缺失，那么必然是1,2,3,4...排列，且一个数a的正确位置必定是在a-1处，因此如果<code>A[i]</code>不处在<code>A[A[i] - 1]</code>，那么交换<code>A[i]</code>和<code>A[A[i] - 1]</code>让他去正确位置，由此直到所有该到正确位置的到正确位置，其中&lt;=0和&gt;n的数没有正确位置，所以终止。 排好位置后再遍历</p>
<h5 id="手动hash">手动hash？</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">0</span>); <span class="comment">// 使得每个处于i位置的数对应为i，所以需要多加一个</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt;= n) <span class="comment">// 此处需要 &gt;= n 而不是 &gt; n 是因为原数组为n-1长度，那么最大正数为n-1，现在因为加了一个，但是n是不合法的</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[num % n] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] / n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用一段解释<span class="citation" data-cites="triton11">[@triton11]</span>(https://leetcode.com/triton11/) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">So consider an array like [1,4,3,3,3]. The length is 5, so n &#x3D; 5. For each item, we are basically overwriting the spot at the index of the item with 5 + spot. So, at index 0 we have a 1, and 1%5 is 1, so we replace the item at index 1 with 5 + that item. Now our array is [1,9,3,3,3]. Next, at index 1 we have a 9, and 9%5 is 4 (notice how adding 5 didn&#39;t change the fact that we can still find the original value with % 5), so we replace the item at index 4 with 5 + that item. Our array is now [1, 9, 3, 3, 8]. Continuing, we get [1, 9, 3, 8, 8] then [1, 9, 3, 13, 8] and finally [1, 9, 3, 18, 8]. When we iterate through to find the values at the end, starting at index 1, we find that 9&#x2F;5 is greater than 1, 3&#x2F;5 is not greater than 1, 13&#x2F;5 and 8&#x2F;5 are greater than 1. Thus, since 3&#x2F;5 is the first not greater than 5, we know index 2 was never used or added to, so 2 is the missing number. Feel free to comment if you have Qs or if I made any mistakes.</span><br></pre></td></tr></table></figure> 一个数加上一个模值后可以通过取余保留其原来的信息，也可以通过其大小显示出频率，如果一个位置的数没被加到，那他就小于模，就是missing的数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>415. 字符串相加</title>
    <url>/2021/08/17/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h4 id="字符串相加"><a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></h4>
<h5 id="效率很低的模拟方法">效率很低的模拟方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = num1.size() - <span class="number">1</span>, b = num2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (a &gt;= <span class="number">0</span> &amp;&amp; b &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = num1[a--] + num2[b--] - <span class="string">&#x27;0&#x27;</span> - <span class="string">&#x27;0&#x27;</span> + c;</span><br><span class="line">            c = i / <span class="number">10</span>;</span><br><span class="line">            i %= <span class="number">10</span>;</span><br><span class="line">            ret = <span class="keyword">char</span>(i + <span class="string">&#x27;0&#x27;</span>) + ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span> &amp;&amp; (a &gt;= <span class="number">0</span> || b &gt;= <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span>)</span><br><span class="line">                i = num1[a--] - <span class="string">&#x27;0&#x27;</span> + c;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = num2[b--] - <span class="string">&#x27;0&#x27;</span> + c;</span><br><span class="line"></span><br><span class="line">            c = i / <span class="number">10</span>;</span><br><span class="line">            i %= <span class="number">10</span>;</span><br><span class="line">            ret = <span class="keyword">char</span>(i + <span class="string">&#x27;0&#x27;</span>) + ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>)</span><br><span class="line">            ret = <span class="keyword">char</span>(c + <span class="string">&#x27;0&#x27;</span>) + ret;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span> || b &gt;= <span class="number">0</span>)</span><br><span class="line">            ret = a &gt;= <span class="number">0</span> ? num1.substr(<span class="number">0</span>, a + <span class="number">1</span>) + ret : num2.substr(<span class="number">0</span>, b + <span class="number">1</span>) + ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在字符串的开头添加字符会导致每次都要重新分配字符串<br> 为了避免多次重新分配字符串，采用先加再反转来避免，顺便可以合并其中的一部分块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = num1.size() - <span class="number">1</span>, b = num2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (a &gt;= <span class="number">0</span> || b &gt;= <span class="number">0</span> || c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)</span><br><span class="line">                i += num1[a--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(b &gt;= <span class="number">0</span>)</span><br><span class="line">                i += num2[b--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i += c;</span><br><span class="line">            c = i / <span class="number">10</span>;</span><br><span class="line">            i %= <span class="number">10</span>;</span><br><span class="line">            ret += <span class="keyword">char</span>(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ret.begin(), ret.end());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>416. Partition Equal Subset Sum</title>
    <url>/2021/04/27/416.%20Partition%20Equal%20Subset%20Sum/</url>
    <content><![CDATA[<h4 id="partition-equal-subset-sum"><a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></h4>
<p>若求是否存在两个子序列相等，只需要求序列中是否存在子序列和等于总序列的一半。所以当和为奇数时候就是无效的。</p>
<p>转化为dp</p>
<p><code>dp[i][j]</code>表示0~i的数字能否获得和为j，若能为true，不能为false。</p>
<p>对于一行的<code>dp[i][j]</code>来说</p>
<ol type="1">
<li>取当前这个<code>nums[i]</code>，则如果0~i-1的数字可以达到<code>j - nums[i]</code>和的话就是true，反之为false。也就是<code>dp[i - 1][j - nums[i]]</code>是否为true</li>
<li>不取当前这个<code>nums[i - 1]</code>，则如果0~i-1可以达到和为j，也就是<code>dp[i - 1][j]</code>是否为true。</li>
</ol>
<p>基础情况是当没有数字时，当且仅当j为0时为true。当和为0时，对于所有数字都是true，因此只需要不取。</p>
<p><img src="https://image.cinte.cc/2021/07/14/dd813ec6f1dfb.jpg" /></p>
<h5 id="二维dp">二维dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(nums.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum; ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || (j &gt;= nums[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] : <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back()[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt; <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] || (j &gt;= nums[i - <span class="number">1</span>] ? dp[j - nums[i - <span class="number">1</span>]] : <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处从sum走是因为，i - num是一个小于 i 的值，可以保证走在后面的时候这个值还是上一行生成的结果，如果从小到大走，走到后面时就会把前面的结果刷新掉了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>42. Trapping Rain Water</title>
    <url>/2021/05/03/42.%20Trapping%20Rain%20Water/</url>
    <content><![CDATA[<h4 id="trapping-rain-water"><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftWater</span><span class="params">(height.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; maxNum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">                maxNum = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            leftWater[i + <span class="number">1</span>] = maxNum - height[i] + leftWater[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = height.size() - <span class="number">1</span>; i &gt; maxIndex; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; maxNum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxNum = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            leftWater[maxIndex + <span class="number">1</span>] += maxNum - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftWater[maxIndex + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="答案中的dp">答案中的dp</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        right[height.size() - <span class="number">1</span>] = height.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); ++i)</span><br><span class="line">            left[i] = max(left[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = height.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = max(right[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); ++i)</span><br><span class="line">            ans += min(left[i], right[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>借图 <img src="https://image.cinte.cc/2021/05/03/486c6df33cd87.png" alt="1620046011104.png" /> 只可意会，左边由两边都是取得最低的量</p>
<h5 id="使用stack">使用stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; bars;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; height.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!bars.empty() &amp;&amp; height[cur] &gt; height[bars.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> top = bars.top();</span><br><span class="line">                bars.pop();</span><br><span class="line">                <span class="keyword">if</span>(bars.empty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> distance = cur - bars.top() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> heightBounded = min(height[cur], height[bars.top()]) - height[top];</span><br><span class="line">                res += distance * heightBounded;</span><br><span class="line">            &#125;</span><br><span class="line">            bars.push(cur++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每碰到一个比之前的障碍高的就计算一次体积，每次计算的是方形，进行填充，由于比较低的在填完后被pop，而他的障碍会被push，因此在填充完毕后，对于后面来看，这就是一条水平线，示意图如下 <img src="https://image.cinte.cc/2021/05/04/a1a5e02ec1c12.png" alt="1620108974861.png" /> 图中红色标号表示填充水块的次序</p>
<h5 id="two-points">Two Points</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(leftMax &lt; height[left])</span><br><span class="line">                    leftMax = height[left];</span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rightMax &lt; height[right])</span><br><span class="line">                    rightMax = height[right];</span><br><span class="line">                res += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中间盛的水可以由左右边界来决定，当左边比右边矮的时候，水由左边边界决定，因为条件决定了左边不会比右边高，所以左边的水量又会受左边的最高峰影响，左边最高峰之左，水由边界决定，最高峰之右，由最高峰决定。将其最高峰之左再细分，又会有许多局部最高峰，由此一来，对于每一步更新其最高峰，更新最高峰之前的水由前一个局部边界决定，更新最高峰后的水由最高峰决定，同时这个局部最高峰又成了下一个区域的边界。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>43. 字符串相乘</title>
    <url>/2021/08/17/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h4 id="字符串相乘"><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h4>
<h5 id="字符串加法模拟出字符串乘法">字符串加法模拟出字符串乘法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.size() &gt; num2.size())</span><br><span class="line">            swap(num1, num2);</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = num2.size() - <span class="number">1</span>; b &gt;= <span class="number">0</span>; --b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (num2[b] - <span class="string">&#x27;0&#x27;</span>) * x + c;</span><br><span class="line">                tmp += <span class="keyword">char</span>(t % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                c = t / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="number">0</span>)</span><br><span class="line">                tmp += <span class="keyword">char</span>(c + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">while</span>(tmp.size() &gt; <span class="number">1</span> &amp;&amp; tmp.back() == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            reverse(tmp.begin(), tmp.end());</span><br><span class="line">            num2 += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ret = add(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span>&amp; num1, <span class="built_in">string</span>&amp; num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = num1.size() - <span class="number">1</span>, b = num2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (a &gt;= <span class="number">0</span> || b &gt;= <span class="number">0</span> || c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span>)</span><br><span class="line">                i += num1[a--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(b &gt;= <span class="number">0</span>)</span><br><span class="line">                i += num2[b--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i += c;</span><br><span class="line">            c = i / <span class="number">10</span>;</span><br><span class="line">            i %= <span class="number">10</span>;</span><br><span class="line">            ret += <span class="keyword">char</span>(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ret.begin(), ret.end());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="转成数组存储每一位的计算结果最后把数组转成字符串">转成数组存储每一位的计算结果，最后把数组转成字符串</h5>
<p>c++中字符串可以直接当作数组 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) <span class="comment">// 如果有0，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(m + n, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">// 乘积大小不会大于m+n位，具体看题解的证明</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) + ret[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ret[i + j + <span class="number">1</span>] = tmp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 第i位和第j位的两个字符串乘法结果到第i+j+1位上</span></span><br><span class="line">                ret[i + j] = (ret[i + j] - <span class="string">&#x27;0&#x27;</span> + tmp / <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 进位存在前一位，由于是从大到小处理，所以不用担心溢出，后续会处理。</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 去掉开头0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(ret[i] != <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                <span class="keyword">return</span> ret.substr(i, m + n - i);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>437. Path Sum III</title>
    <url>/2021/04/26/437.%20Path%20Sum%20III/</url>
    <content><![CDATA[<h4 id="path-sum-iii"><a href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III</a></h4>
<h5 id="backtrack">backTrack</h5>
<p>这是对每个点都遍历他的儿子，从而判断路径，时间复杂度为(n^2) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            backTrack(p, targetSum, cur, count);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; cur, <span class="keyword">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cur += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(cur == target)</span><br><span class="line">            ++count;</span><br><span class="line">        backTrack(root-&gt;left, target, cur, count);</span><br><span class="line">        backTrack(root-&gt;right, target, cur, count);</span><br><span class="line">        cur -= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### 使用hashmap</p>
<p>记录路径上的和，当 可知 路径中某一段的值 = 当前和 - 某一段开始位置之前的和，由此，target = curSum - somePlaceSum--&gt; somePlaceSum = curSum - target,如果这个值存在于走过的路径上，那么表示存在这一段和=target，由于可能存在不同段具有相同的和，因此进行计数</p>
<p>使用backTrack来记录每一段的hashmap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur += root-&gt;val; <span class="comment">// 加上当前值，开始遍历他的儿子</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">map</span>[cur - targetSum]; <span class="comment">// 如果存在在他回溯的路径上存在cur-targetSum的值，说明存在这样一个节点使得在此节点之前的和为cur-targetSum。如果路径上存在多条和为此，那么后面也和他的路径数量相同。</span></span><br><span class="line">        ++<span class="built_in">map</span>[cur]; <span class="comment">// 路径当前和所对应的计数加一。可处理存在重复和的情况。</span></span><br><span class="line">        ret += pathSum(root-&gt;left, targetSum) + pathSum(root-&gt;right, targetSum); <span class="comment">// 往儿子遍历，如果儿子中也存在这样的路径，那就加上去。</span></span><br><span class="line">        --<span class="built_in">map</span>[cur]; <span class="comment">// 回溯返回</span></span><br><span class="line">        cur -= root-&gt;val; <span class="comment">// 回溯返回</span></span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回这个节点到他儿子路上和为target的路径数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)</p>
<p>review <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        recurse(root, <span class="built_in">map</span>, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; <span class="built_in">map</span>, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        ret += <span class="built_in">map</span>[curSum - targetSum]; <span class="comment">// 注意这两行的顺序，大坑啊</span></span><br><span class="line">        ++<span class="built_in">map</span>[curSum];                  <span class="comment">// 如果++在前的话，假如targetSum = 0，那就每个节点都会算上自己了，对于targetSum不是0的情况似乎没什么影响</span></span><br><span class="line">        recurse(root-&gt;left, <span class="built_in">map</span>, targetSum, curSum);</span><br><span class="line">        recurse(root-&gt;right, <span class="built_in">map</span>, targetSum, curSum);</span><br><span class="line">        --<span class="built_in">map</span>[curSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>438. Find All Anagrams in a String</title>
    <url>/2021/07/14/438.%20Find%20All%20Anagrams%20in%20a%20String/</url>
    <content><![CDATA[<h4 id="find-all-anagrams-in-a-string"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></h4>
<p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem.">sliding window大佬归纳</a></p>
<h5 id="滑动窗口">滑动窗口</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : p)</span><br><span class="line">            ++<span class="built_in">map</span>[ch];</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="built_in">map</span>.size();</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[end]) != <span class="built_in">map</span>.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--<span class="built_in">map</span>[s[end]] == <span class="number">0</span>)</span><br><span class="line">                    --count;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(end - begin + <span class="number">1</span> == p.size()) <span class="comment">// 由于这里保证所有字符出现过了，只要窗口大小等于目标就说明等于解</span></span><br><span class="line">                    ret.push_back(begin);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[begin]) != <span class="built_in">map</span>.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(++<span class="built_in">map</span>[s[begin]] &gt; <span class="number">0</span>)</span><br><span class="line">                        ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>448. Find All Numbers Disappeared in an Array</title>
    <url>/2021/04/12/448-Find-All-Numbers-Disappeared-in-an-Array/</url>
    <content><![CDATA[<h4 id="find-all-numbers-disappeared-in-an-array"><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a></h4>
<h5 id="抄的discussion">抄的discussion</h5>
<p>使用原数列中的坐标是否为负来表征当前坐标所代表的值是否存在。由此使得S(n) = O(n)</p>
<p>聪明啊！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 下述操作也类似一个哈希表</span></span><br><span class="line">            <span class="keyword">int</span> m = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>; <span class="comment">// 当前的数字，对应的角标，由于可能之前被操作为负的，所以要绝对值</span></span><br><span class="line">            nums[m] = nums[m] &gt; <span class="number">0</span> ? -nums[m] : nums[m];  <span class="comment">// 角标对应过去的为负，表示那个被记录到了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ret.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                ret.push_back(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II</title>
    <url>/2021/04/30/45.%20Jump%20Game%20II/</url>
    <content><![CDATA[<h4 id="jump-game-ii"><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(maxReach &lt; nums.size() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++level;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> maxT = maxReach; i &lt;= maxT; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                maxReach = max(maxReach, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span>(maxReach &gt;= nums.size() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>视为<a href="https://leetcode.com/problems/jump-game-ii/discuss/18028/O(n)-BFS-solution">BFS问题</a></p>
<p>每个区域里都可以走到下一层的任何一个点，实在走不到了，只能换层了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>, maxReachFurther = <span class="number">0</span>, maxReachEnd = <span class="number">0</span>; <span class="comment">// #defind jumptime level，这样解释比较合理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i)  <span class="comment">// 这里用nums.size() - 1而不是nums.size() 是因为如果走到了最后一个，但是最后一个，那么已经不用考虑换层了，例如[0]，如果到达0，再换层，那就扰乱了结果。因为假设的是一定可以到达终点，而最后一次起跳就表示了一定可以到达终点。这里面对最后一跳超越终点也无所谓，因为已经记录了这一跳了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxReachFurther = max(maxReachFurther, nums[i] + i); <span class="comment">// 目前层能达到的最远</span></span><br><span class="line">            <span class="comment">// 首先先从0开始起跳，跳跃次数加一。然后每次碰到这次的结尾，跳跃次数加一。</span></span><br><span class="line">            <span class="keyword">if</span>(maxReachEnd == i)</span><br><span class="line">            &#123;</span><br><span class="line">                maxReachEnd = maxReachFurther;  <span class="comment">// 对于下一层来说  记录上一层能达到的最远，如果遇见，那么这一层就结束了</span></span><br><span class="line">                ++level; <span class="comment">// level代表着需要重新起跳，跳到下一层了，记录的不是层数而跳跃的次数。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>46. Permutations</title>
    <url>/2021/03/25/46-Permutations/</url>
    <content><![CDATA[<h4 id="permutations"><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> num [<span class="number">6</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        backTrack(nums, ret, temp, num);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span>* num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == nums.size())</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]) <span class="keyword">continue</span>;</span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, ret, temp, num);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>461. 汉明距离</title>
    <url>/2021/07/13/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h4 id="汉明距离"><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h4>
<h5 id="直接移位">直接移位</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x ^= y;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += x &amp; <span class="number">1</span>;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="只遍历1">只遍历1</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x ^= y;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            x &amp;= x - <span class="number">1</span>;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>x-1会将x中最近的一个1变成0，而这个1左边的全变成1。</p>
<p>所以<code>x&amp;x-1</code>会使得这个最近的1及其右边全都变成0，而左边保持不变，则每次都如此操作，循环次数就是1的个数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode favorite</tag>
      </tags>
  </entry>
  <entry>
    <title>47. Permutations II</title>
    <url>/2021/03/25/47-Permutations-II/</url>
    <content><![CDATA[<h4 id="permutations-ii"><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> num[<span class="number">8</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        backTrack(ret, nums, temp , num);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span>* num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == nums.size())</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]) <span class="keyword">continue</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">            backTrack(ret, nums, temp, num);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="comment">// 重点。从重复串的第一个元素搜索已经可以获得获得重复串的全排列结果了，所以防止后面重复得到，就跳过。也就是说，重复字符串的元素只会顺位取而不会掉头。也就是说，如果有重复的，那么搜索起点一样，肯定会重复，所以要剔除</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another BackTrack</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image</title>
    <url>/2021/03/31/48-Rotate-Image/</url>
    <content><![CDATA[<h4 id="rotate-image"><a href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a></h4>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">                matrix[i][j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抄de</p>
<h5 id="转置-翻转">转置 + 翻转</h5>
<p>transpose and reflect in linear algebra <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[i][n - j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>49. Group Anagrams</title>
    <url>/2021/03/28/49-Group-Anagrams/</url>
    <content><![CDATA[<h4 id="group-anagrams"><a href="https://leetcode.com/problems/group-anagrams/">49. Group Anagrams</a></h4>
<h5 id="按照排序后的字符串作为索引">按照排序后的字符串作为索引</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp&#123;str&#125;;</span><br><span class="line">            sort(str.begin(), str.end());</span><br><span class="line">            <span class="built_in">map</span>[str].push_back(tmp);                           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v : <span class="built_in">map</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>494. Target Sum</title>
    <url>/2021/04/27/494.%20Target%20Sum/</url>
    <content><![CDATA[<h4 id="target-sum"><a href="https://leetcode.com/problems/target-sum/">494. Target Sum</a></h4>
<h5 id="backtrack">backTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        backTrack(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> cur, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == target)</span><br><span class="line">                ++ret;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(nums, target, cur + nums[i], i + <span class="number">1</span>);</span><br><span class="line">        backTrack(nums, target, cur - nums[i], i + <span class="number">1</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hashmap">hashmap</h5>
<p>本质上是用hash来代替递归操作，实际上还是走遍了分支 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>[-nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : <span class="built_in">map</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[it.first + nums[i]] += it.second;</span><br><span class="line">                tmp[it.first - nums[i]] += it.second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span> = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### dp <a href="https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.">DP IS EASY! 5 Steps to Think Through DP Questions.</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <url>/2021/04/23/5-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<h4 id="longest-palindromic-substring"><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></h4>
<h5 id="approach-3">Approach 3</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; maxp&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][i + <span class="number">1</span>] &amp;&amp; maxlen &lt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = <span class="number">2</span>;</span><br><span class="line">                maxp = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;i, <span class="number">2</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处循环先j再i 是由于以下j为j - 1 而 i 为 i + 1</span></span><br><span class="line">        <span class="comment">// 如果先i 再 j，则i + 1永远不是i的前一任</span></span><br><span class="line">        <span class="comment">// 先j后i，则可以用i,i+1的base来处理</span></span><br><span class="line">        <span class="comment">// 也是不断拉长区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j || j == i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    maxp = j - i + <span class="number">1</span> &gt; maxlen ? <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;i, j - i + <span class="number">1</span>&#125; : maxp;   </span><br><span class="line">                    maxlen = max(maxlen, maxp.second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxp.first, maxp.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2) <br> S(n) : O(n^2)</p>
<p>dp改 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                maxLength = <span class="number">2</span>;</span><br><span class="line">                maxVal = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">3</span>; len &lt;= s.size(); ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len - <span class="number">1</span>; j &lt; s.size(); ++i, ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxVal = i;</span><br><span class="line">                    maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxVal, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### approach 4(很快) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; maxP;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> lenO = extract(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> lenS = extract(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (max(lenO.second, lenS.second) &gt; maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (lenO.second &gt; lenS.second)</span><br><span class="line">                    maxP = lenO;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    maxP = lenS;</span><br><span class="line">                maxLen = maxP.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxP.first, maxP.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pair&lt;int, int&gt; extract(string&amp; s, int left, int right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= s.size() &amp;&amp; s[left] == s[right])</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;left + <span class="number">1</span>, right - left - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> T(n) : O(n^2) <br> S(n) : O(1)</p>
<h5 id="approach-5-manachers-algorithm"><a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher&#39;s_algorithm">Approach 5: Manacher's Algorithm</a></h5>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>528. 按权重随机选择</title>
    <url>/2021/08/30/528.%20%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h4 id="按权重随机选择"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4>
<p>把权重分成长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : ww(w), total(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        sz = w.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : ww)</span><br><span class="line">        &#123;</span><br><span class="line">            total += num;</span><br><span class="line">            num = end;</span><br><span class="line">            end = total;</span><br><span class="line">        &#125;</span><br><span class="line">        u = uniform_int_distribution&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, total - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pick = u(e);</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = sz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ww[mid] &gt; pick)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ww;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    mt19937 e;</span><br><span class="line">    <span class="comment">// default_random_engine e;</span></span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="使用stl的版本">使用STL的版本</h5>
<p>右开左闭</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : e(random_device&#123;&#125;()), u(<span class="number">0</span>, accumulate(w.begin(), w.end(), <span class="number">0</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        partial_sum(w.begin(), w.end(), back_inserter(pre));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = u(e);</span><br><span class="line">        <span class="keyword">return</span> upper_bound(pre.begin(), pre.end(), x) - pre.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mt19937 e;</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<p>右闭左开</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : e(random_device&#123;&#125;()), u(<span class="number">1</span>, accumulate(w.begin(), w.end(), <span class="number">0</span>)) &#123;</span><br><span class="line">        partial_sum(w.begin(), w.end(), back_inserter(pre));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = u(e);</span><br><span class="line">        <span class="keyword">return</span> lower_bound(pre.begin(), pre.end(), x) - pre.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mt19937 e;</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>C++STL说明：</p>
<ol type="1">
<li>mt19937头文件是<random> 是伪随机数产生器，用于产生高性能的随机数</li>
<li>uniform_int_distribution 头文件在<random>中，是一个随机数分布类，参数为生成随机数的类型，构造函数接受两个值表示区间段</li>
<li>accumulate 头文件在<numeric>中，求特定范围内所有元素的和。</li>
<li>spartial_sum函数的头文件在<numeric>，对(first, last)内的元素逐个求累计和，放在result容器内</li>
<li>back_inserter函数头文件<iterator>，用于在末尾插入元素。</li>
<li>lower_bound头文件在<algorithm>，用于找出范围内不大于num的第一个元素</li>
<li>upper_bound头文件在<algorithm>，用于找出范围内大于num的第一个元素</li>
<li>random_device头文件再<random>，是非确定性随机数生成器，生成均匀分布的无符号数。生成器可能会依靠非确定源（比如硬件设备）生成真随机数，不过在环境受限时生成伪随机数。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>53. Maximum Subarray</title>
    <url>/2021/03/26/53-Maximum-Subarray/</url>
    <content><![CDATA[<h4 id="maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h4>
<h5 id="kadane算法"><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane&#39;s_algorithm">Kadane算法</a></h5>
<blockquote>
<p>Whenever you see a question that asks for the maximum or minimum of something, consider Dynamic Programming as a possibility</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxCur = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxCur = max(nums[i], maxCur + nums[i]);</span><br><span class="line">            maxNum = max(maxNum, maxCur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="分而知之dq">分而知之D&amp;Q</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">0</span>, nums.size() - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>; <span class="comment">// 如果都小于0，那就不采用那边，那么那边的和就是0</span></span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left ; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            maxLeft = max(maxLeft, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            maxRight = max(maxRight, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bestCombined = nums[mid] + maxLeft + maxRight;</span><br><span class="line">        <span class="keyword">int</span> leftHalf = find(left, mid - <span class="number">1</span>, nums); <span class="comment">// 这里不用考虑为什么不把mid包含进来，因为如果包含的mid是属于最大的子序列，且只有单边，那么maxRight = 0的情况就已经将其包括了</span></span><br><span class="line">        <span class="keyword">int</span> rightHalf = find(mid + <span class="number">1</span>, right, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(bestCombined, max(leftHalf, rightHalf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>取中点，往左计算和，往右计算和，这时候有三种情况，中点是最长子串之中的元素，最长子串在中点右边，最长子串在中点左边。对于第一种情况，那就是左+右+中，对于后两种，那么再对左右子串进行同样的查找(DQ)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>538. 把二叉搜索树转换为累加树</title>
    <url>/2021/07/13/538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h4 id="把二叉搜索树转换为累加树"><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4>
<h5 id="中序遍历变种">中序遍历变种</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rightVal = <span class="number">0</span>;</span><br><span class="line">        dfs(root, rightVal);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; rightVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;right, rightVal);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val += rightVal;</span><br><span class="line">        rightVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;left, rightVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>右-&gt;中-&gt;左</p>
<p>rightVal始终保存他右边树枝的最大值</p>
<p>我好傻</p>
<p>简单的思考方法:</p>
<p><strong>中序单增</strong>，于是反中序为单减，对于每个节点加上他左边的和就行</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>54. Spiral Matrix</title>
    <url>/2021/04/08/54-Spiral-Matrix/</url>
    <content><![CDATA[<h4 id="spiral-matrix"><a href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> bL = <span class="number">0</span>, bR = n - <span class="number">1</span>, bU = <span class="number">0</span>, bB = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(bL &lt;= bR &amp;&amp; bU &lt;= bB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bL; i &lt;= bR; ++i)</span><br><span class="line">                ret.push_back(matrix[bU][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bU + <span class="number">1</span>; i &lt;= bB; ++i)</span><br><span class="line">                ret.push_back(matrix[i][bR]);</span><br><span class="line">            <span class="keyword">if</span>(bU &lt; bB &amp;&amp; bL &lt; bR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bR - <span class="number">1</span>; i &gt; bL; --i)</span><br><span class="line">                    ret.push_back(matrix[bB][i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bB; i &gt; bU; --i)</span><br><span class="line">                    ret.push_back(matrix[i][bL]);                </span><br><span class="line">            &#125;</span><br><span class="line">            ++bL;</span><br><span class="line">            --bR;</span><br><span class="line">            ++bU;</span><br><span class="line">            --bB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>螺旋</p>
<p>T(n) : O(n) <br> S(n) : O(n)</p>
<p>还有一种思路是把走过的路都设为障碍，每次要撞过去了就改变方向。不管如何，就是直接撞过去，撞到就变向，四个方向依次变 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visisted(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">4</span>]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> dr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nexti = i + d[dr][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nextj = j + d[dr][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nexti &lt; <span class="number">0</span> || nextj &lt; <span class="number">0</span> || nexti &gt;= n || nextj &gt;= m || visisted[nexti][nextj])</span><br><span class="line">                dr = (dr + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            ret.push_back(matrix[i][j]);</span><br><span class="line">            visisted[i][j] = <span class="number">1</span>;</span><br><span class="line">            i += d[dr][<span class="number">0</span>];</span><br><span class="line">            j += d[dr][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ret.size() == m * n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> T(n) : O(n) <br> S(n) : O(n * m)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>543. Diameter of Binary Tree</title>
    <url>/2021/04/13/543-Diameter-of-Binary-Tree/</url>
    <content><![CDATA[<h4 id="diameter-of-binary-tree"><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4>
<h5 id="遍历">遍历</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> dL = <span class="number">0</span>, dR = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">                maxDepth(p-&gt;left, dL, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">                maxDepth(p-&gt;right, dR, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, dL + dR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth, <span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ++tmp;</span><br><span class="line">        depth = max(tmp, depth);</span><br><span class="line">        maxDepth(root-&gt;left, depth, tmp);</span><br><span class="line">        maxDepth(root-&gt;right, depth, tmp);</span><br><span class="line">        --tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="顺路计算完所有的点">顺路计算完所有的点</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        longest(root, maxDepth);</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;maxDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = longest(root-&gt;left, maxDepth);</span><br><span class="line">        <span class="keyword">int</span> right = longest(root-&gt;right, maxDepth);</span><br><span class="line">        </span><br><span class="line">        maxDepth = max(maxDepth, left + right);</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>55. Jump Game</title>
    <url>/2021/04/05/55-Jump-Game/</url>
    <content><![CDATA[<h4 id="jump-game"><a href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></h4>
<p>这段话很好 <img src="https://image.cinte.cc/2021/04/05/c9c053e133132.png" /></p>
<p>跟着答案走</p>
<h5 id="动态规划">动态规划</h5>
<p>首先，确定网格中最后一个元素可以到达他本身，自上而下，进行判断前一个可以到达他的元素是什么<br> 由此，慢慢的，从后面开始，可以到达最后一块的坐标都被用good填充，这样一来，其他的回溯只需要判断能否到达这些good的点即可，而无需全都走到最后一个 <img src="https://image.cinte.cc/2021/04/05/b1c1941e9d0db.png" /> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span></span><br><span class="line">    GOOD,</span><br><span class="line">    BAD,</span><br><span class="line">    UNKNOW</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> status[nums.size()];</span><br><span class="line">        fill(dp, dp + nums.size(), UNKNOW);</span><br><span class="line">        dp[nums.size() - <span class="number">1</span>] = GOOD;</span><br><span class="line">        <span class="keyword">return</span> backTrack(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    status* dp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[start] != UNKNOW)</span><br><span class="line">            <span class="keyword">return</span> dp[start] == GOOD;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxPos = (start + nums[start] &gt; nums.size() - <span class="number">1</span>) ? nums.size() - <span class="number">1</span> : start + nums[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos = start + <span class="number">1</span>; pos &lt;= maxPos; ++pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(nums, pos))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[start] = GOOD;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start] = BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> T(n) : O(n^2)<br> S(n) : O(n)</p>
<h5 id="bottom-up">bottom Up</h5>
<p>从最后出发，判断前一步可不可以走到一个good，依次回去。 <img src="https://image.cinte.cc/2021/04/05/346916d90fd9a.png" alt="image.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UNKNOW,</span><br><span class="line">    GOOD</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        status* dp = <span class="keyword">new</span> status[nums.size()];</span><br><span class="line">        fill(dp, dp + nums.size(), UNKNOW);</span><br><span class="line">        dp[nums.size() - <span class="number">1</span>] = GOOD;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos = nums.size() - <span class="number">2</span>; pos &gt;= <span class="number">0</span>; --pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> maxPos = pos + nums[pos] &gt; nums.size() - <span class="number">1</span> ? nums.size() - <span class="number">1</span> : pos + nums[pos];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> cur = maxPos; cur &gt; pos; --cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[cur] == GOOD)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[pos] = GOOD;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>] == GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2)<br> S(n) : O(n)</p>
<h5 id="greedy">greedy</h5>
<p>对于一路上的所有good，我能走到右边的就能走到左边的一个good，因此 只需要记录最左边的一个的坐标，空间复杂度降为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos = nums.size() - <span class="number">2</span>; pos &gt;=<span class="number">0</span> ; --pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos + nums[pos] &gt;= lastPos)</span><br><span class="line">                lastPos = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)<br> S(n) : O(1)</p>
<h5 id="更greedy">更greedy</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i; i &lt; nums.size() &amp;&amp; maxReach &gt;= i; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxReach = max(i + nums[i], maxReach);</span><br><span class="line">            <span class="keyword">if</span>(maxReach &gt;= nums.size() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxReach &gt;= nums.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每步都贪，贪不了了就停了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>leetcode favorite</tag>
      </tags>
  </entry>
  <entry>
    <title>56. Merge Intervals</title>
    <url>/2021/04/05/56-Merge-Intervals/</url>
    <content><![CDATA[<h4 id="merge-intervals"><a href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mySort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), mySort);</span><br><span class="line">        re.push_back(intervals[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        re.push_back(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = intervals.begin() + <span class="number">1</span>; i != intervals.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((*i)[<span class="number">0</span>] &lt;= re[index - <span class="number">1</span>])</span><br><span class="line">                re[index - <span class="number">1</span>] = max(re[index - <span class="number">1</span>], (*i)[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                re.push_back((*i)[<span class="number">0</span>]);</span><br><span class="line">                re.push_back((*i)[<span class="number">1</span>]);</span><br><span class="line">                index += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re.size(); i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(&#123;re[i], re[i + <span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn) <br> S(n) : O(n)</p>
<h5 id="同样思路的一个solution">同样思路的一个Solution</h5>
<p>空间和时间占用更少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret.empty() || interval[<span class="number">0</span>] &gt; ret.back()[<span class="number">1</span>])</span><br><span class="line">                ret.push_back(interval);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret.back()[<span class="number">1</span>] = max(interval[<span class="number">1</span>], ret.back()[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>560. Subarray Sum Equals K</title>
    <url>/2021/04/28/560.%20Subarray%20Sum%20Equals%20K/</url>
    <content><![CDATA[<h4 id="subarray-sum-equals-k"><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></h4>
<h5 id="和httpsleetcode.comproblemspath-sum-iii思路相同">和<a href="https://leetcode.com/problems/path-sum-iii/">https://leetcode.com/problems/path-sum-iii/</a>思路相同</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum += num;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(curSum - k) != <span class="built_in">map</span>.end())</span><br><span class="line">                count += <span class="built_in">map</span>[curSum - k];</span><br><span class="line">            <span class="built_in">map</span>[curSum] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>57. Insert Interval</title>
    <url>/2021/05/14/57.%20Insert%20Interval/</url>
    <content><![CDATA[<h4 id="insert-interval"><a href="https://leetcode.com/problems/insert-interval/">57. Insert Interval</a></h4>
<p>My vegetable exploded</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = newInterval[<span class="number">0</span>], r = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) <span class="comment">// 添加所有没有交叠的</span></span><br><span class="line">            ret.push_back(intervals[i++]);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= r) <span class="comment">// 合并所有交叠的</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = min(l, intervals[i][<span class="number">0</span>]);</span><br><span class="line">            r = max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push_back(&#123;l, r&#125;);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size()) <span class="comment">// 添加剩下的</span></span><br><span class="line">            ret.push_back(intervals[i++]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三步走，先处理交叠前的，在处理正在交叠的，再添加剩下的</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>58. 最后一个单词的长度</title>
    <url>/2021/08/31/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="最后一个单词的长度"><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[end] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            --end;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; s[end--] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>581. Shortest Unsorted Continuous Subarray</title>
    <url>/2021/04/28/581.%20Shortest%20Unsorted%20Continuous%20Subarray/</url>
    <content><![CDATA[<h4 id="shortest-unsorted-continuous-subarray"><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">581. Shortest Unsorted Continuous Subarray</a></h4>
<h5 id="brute-force">Brute Force</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.size();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    r = max(r, j);</span><br><span class="line">                    l = min(l, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == nums.size() ? <span class="number">0</span> : r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次遍历过程中，当<code>nums[j] &lt; nums[i]</code>，意味着2者都不在其正确位置，若要得到正确排序，需要进行位置的交换，但此处不要求交换，因此将i标记为<code>Unsorted Array</code>的最底端，j标记为<code>Unsorted Array</code>的最顶端</p>
<h5 id="sort">sort</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsCopy</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> l = nums.size();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != numsCopy[i])</span><br><span class="line">            &#123;</span><br><span class="line">                l = min(i, l);</span><br><span class="line">                r = max(i, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == nums.size() ? <span class="number">0</span> : r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>排序后比较不同处的两个端点</p>
<h5 id="stack">stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> l = nums.size();</span><br><span class="line">        <span class="keyword">int</span> r = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; num &lt; s.top())</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                l = min(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size()), l);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.end() - <span class="number">1</span>; i &gt;= nums.begin(); --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty() &amp;&amp; *i &gt; s1.top())</span><br><span class="line">            &#123;</span><br><span class="line">                s1.pop();</span><br><span class="line">                r = min(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s1.size()), r);</span><br><span class="line">            &#125;</span><br><span class="line">            s1.push(*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == nums.size() ? <span class="number">0</span> : nums.size() - r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="tnon-sno1">T(n):O(n) S(n):O(1)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.size(), r = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                --j;</span><br><span class="line">                l = min(j, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[i] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                r = max(j, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == nums.size() ? <span class="number">0</span> : r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="tnon-sno1-1">T(n):O(n) S(n):O(1)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minNum = INT_MAX, maxNum = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.begin() + <span class="number">1</span>; i != nums.end(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*i &lt; *(i - <span class="number">1</span>))</span><br><span class="line">                minNum = min(minNum, *i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums.end() - <span class="number">2</span>; i &gt;= nums.begin(); --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*i &gt; *(i + <span class="number">1</span>))</span><br><span class="line">                maxNum = max(maxNum, *i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; nums.size(); ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &gt; minNum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(r = nums.size() - <span class="number">1</span>; r &gt;= <span class="number">0</span>; --r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] &lt; maxNum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum == INT_MAX ? <span class="number">0</span> : r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>59. Spiral Matrix II</title>
    <url>/2021/05/14/59.%20Spiral%20Matrix%20II/</url>
    <content><![CDATA[<h4 id="spiral-matrix-ii"><a href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= n * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">                ret[top][i] = num++;</span><br><span class="line">            ++top;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &lt;= bottom; ++i)</span><br><span class="line">                ret[i][right] = num++;</span><br><span class="line">            --right;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left; --i)</span><br><span class="line">                ret[bottom][i] = num++;</span><br><span class="line">            --bottom;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom; i &gt;= top; --i)</span><br><span class="line">                ret[i][left] = num++;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="section">2</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, di = <span class="number">0</span>, dj = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= n * n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][j] = num++;</span><br><span class="line">            <span class="keyword">if</span>(ret[(i + di + n) % n][(j + dj + n) % n]) <span class="comment">// 加n再取余是防止负号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = dj;</span><br><span class="line">                dj = -di;</span><br><span class="line">                di = t;</span><br><span class="line">            &#125;</span><br><span class="line">            i += di;</span><br><span class="line">            j += dj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2021/03/08/6-ZigZag-Conversion/</url>
    <content><![CDATA[<h4 id="zigzag-conversion"><a href="https://leetcode.com/problems/zigzag-conversion/">6. ZigZag Conversion</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> col = size / (numRows + numRows - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> addon = size - col * (numRows + numRows - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numRows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bias;</span><br><span class="line">            <span class="keyword">if</span> (i == numRows - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = col + (addon &gt;= numRows ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    result += <span class="built_in">string</span>(<span class="number">1</span>, s[location + i*(numRows+numRows<span class="number">-2</span>)]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++location;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = col + (addon ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    result += <span class="built_in">string</span>(<span class="number">1</span>, s[location + i * (numRows + numRows - <span class="number">2</span>)]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++location;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (addon &gt;= <span class="number">2</span> * numRows - <span class="number">2</span> - (i - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                bias = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (addon &gt;= i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bias = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                bias = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = col + col + bias;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    result += <span class="built_in">string</span>(<span class="number">1</span>, s[location + (i/<span class="number">2</span>) * (numRows + numRows - <span class="number">2</span>)]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    result += <span class="built_in">string</span>(<span class="number">1</span>, s[location + (i/<span class="number">2</span>) * (numRows + numRows - <span class="number">2</span>)+<span class="number">2</span>*numRows<span class="number">-4</span><span class="number">-2</span>*(location<span class="number">-1</span>)]);</span><br><span class="line">            &#125;   </span><br><span class="line">            ++location;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>61. 旋转链表</title>
    <url>/2021/08/19/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="旋转链表"><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* point = head;</span><br><span class="line">        ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(point)</span><br><span class="line">        &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            tail = point;</span><br><span class="line">            point = point-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= length;</span><br><span class="line">        <span class="keyword">if</span>(!k)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k = length - k - <span class="number">1</span>;</span><br><span class="line">        point = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            point = point-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ret = point-&gt;next;</span><br><span class="line">        point-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        tail-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>617. Merge Two Binary Trees</title>
    <url>/2021/07/18/617.%20Merge%20Two%20Binary%20Trees/</url>
    <content><![CDATA[<h4 id="merge-two-binary-trees"><a href="https://leetcode-cn.com/problems/burst-balloons/">617. Merge Two Binary Trees</a></h4>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1)</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="还有迭代">还有迭代</h5>
<p>用队列可以记录2个对应的节点进行操作</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>62. Unique Paths</title>
    <url>/2021/03/26/62-Unique-Paths/</url>
    <content><![CDATA[<h4 id="unique-paths"><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path(m, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path(m - <span class="number">1</span>, n) + path(m, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time Limit Exceeded</p>
<h5 id="动态规划划分为子路径">动态规划，划分为子路径</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>621. Task Scheduler</title>
    <url>/2021/07/18/621.%20Task%20Scheduler/</url>
    <content><![CDATA[<h4 id="task-scheduler"><a href="https://leetcode.com/problems/task-scheduler">621. Task Scheduler</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxFreqNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> taskCount[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; task : tasks)</span><br><span class="line">        &#123;</span><br><span class="line">            ++taskCount[task - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(maxVal == taskCount[task - <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">                ++maxFreqNum;</span><br><span class="line">            <span class="keyword">if</span>(taskCount[task - <span class="string">&#x27;A&#x27;</span>] &gt; maxVal)</span><br><span class="line">            &#123;</span><br><span class="line">                maxFreqNum = <span class="number">1</span>;</span><br><span class="line">                maxVal = taskCount[task - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSpace = (maxVal - <span class="number">1</span>) * (n - maxFreqNum + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> leftTasks = tasks.size() - maxFreqNum * maxVal;</span><br><span class="line">        <span class="keyword">int</span> idle = max(<span class="number">0</span>, leftSpace - leftTasks);</span><br><span class="line">        <span class="keyword">return</span> idle + tasks.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先对于AAABBCC的情况，先获得出现最多的任务</p>
<p>然后假设n=2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A??A??A</span><br></pre></td></tr></table></figure>
<p>先放A，然后把中间空余的用其他的来填满，因为其他的如果有多个，那么只需要依次填入到每个间隔中去就可以了，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AB?AB?A</span><br></pre></td></tr></table></figure>
<p>依旧可以保证他们的间隔符合要求。</p>
<p>如果有多个出现最多次数的任务，比如AAABBBC，n=2那就</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A??A??A-&gt;AB?AB?AB</span><br></pre></td></tr></table></figure>
<p>把AB视为一个整体X</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X?X?X</span><br></pre></td></tr></table></figure>
<p>此时就转化为一个XXXC,n=1的问题</p>
<p>由此我们可以先计算出出现最多的任务的出现次数<code>maxVal</code>，和出现最多的任务同时有几个<code>maxFreqNum</code>。</p>
<p>可以计算得到把这些任务放置后，空余的空间就是</p>
<p><code>leftSpace = (maxVal - 1) * (n - maxFreqNum + 1)</code></p>
<p>剩余的任务就是<code>leftTasks = tasks.size() - maxFreqNum * maxVal</code></p>
<p>然后把其他的元素排放进空余的空间中去，如果空余的空间足够。那么需要填充idle空间就是</p>
<p><code>leftSpace - leftTasks</code>，如果空余的空间不够了,那么上面算式结果是负，那么idle的空间是0，然后将剩余的任务填充进入之前每个分块的末尾即可。所以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max(0, leftSpace - leftTasks)</span><br></pre></td></tr></table></figure>
<p>例如</p>
<p>AAABBBCC,n=1。放完最高频率后是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABABAB</span><br></pre></td></tr></table></figure>
<p>那么下一步只需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCABCAB</span><br></pre></td></tr></table></figure>
<p>如果<code>maxFreqNum &gt; n</code></p>
<p>例如AAABBBCCCDD,n = 1</p>
<p>只需要这样排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCABCABC-&gt;ABCDABCDABC</span><br></pre></td></tr></table></figure>
<p>因为<code>maxFreqNum &gt; n</code>可以保证符合要求</p>
<p>排列后由于<code>n - maxFreqNum + 1</code>是负数，所以剩余空间是负数，最终idle还是0，所以结果不变。</p>
<p>所有情况下的结果都是任务数和需要填充的idle数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>63. Unique Paths II</title>
    <url>/2021/03/31/63-Unique-Paths-II/</url>
    <content><![CDATA[<h4 id="unique-paths-ii"><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h4>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">size_t</span> m = obstacleGrid.size();</span><br><span class="line">        <span class="keyword">size_t</span> n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] ? <span class="number">0</span> : obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i] ? <span class="number">0</span> : obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                obstacleGrid[i][j] = obstacleGrid[i][j] ? <span class="number">0</span> : obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(m * n)</p>
<p>S(n) : O(1)</p>
<p>动态规划问题可以归结为网格，此处网格中元素为每个块对路径的贡献度，当本块为障碍时则贡献为0，当本块无障碍，则上方和左方的方块可以走过来，贡献的路径就是上和左相加</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>64. Minimum Path Sum</title>
    <url>/2021/03/29/64-Minimum-Path-Sum/</url>
    <content><![CDATA[<h4 id="minimum-path-sum"><a href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum</a></h4>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(m * n)</p>
<p>S(n) : O(m * n)</p>
<h5 id="尝试对sn-优化">尝试对S(n) 优化</h5>
<p>观察代码，发现每次用到的数据只有dp[i][j], dp[i][j - 1]和dp[i - 1][j]，考虑dp[i][j], dp[i][j - 1]合并到一个一维数组，剩下的再生产一个一维数组。</p>
<p>参考<a href="https://leetcode.com/problems/unique-paths/discuss/22954/C%2B%2B-DP">unique path</a>中的方法 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span>* cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>* pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = cur[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = pre[j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur[j] = min(pre[j], cur[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            swap(cur, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> T(n) : O(m * n)</p>
<p>S(n) : O(2 * n)</p>
<h5 id="再优化">再优化</h5>
<p>pre[j] 与 cur[j] 可以合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span>* cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = cur[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    cur[j] = cur[j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur[j] = min(cur[j], cur[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(m * n)</p>
<p>S(n) : O(n)</p>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                dp[j] = (j &gt; <span class="number">0</span> ? min(dp[j], dp[j - <span class="number">1</span>]) : dp[j]) + grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>647. Palindromic Substrings</title>
    <url>/2021/07/18/647.%20Palindromic%20Substrings/</url>
    <content><![CDATA[<h4 id="palindromic-substrings"><a href="%5BPalindromic%20Substrings%20-%20LeetCode%5D(https://leetcode.com/problems/palindromic-substrings/)">647. Palindromic Substrings</a></h4>
<h5 id="自下而上从单个字母和相邻两个字母相同的条件出发">自下而上，从单个字母和相邻两个字母相同的条件出发</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += check(s, i, i); <span class="comment">// 奇数的情况，从单个字母向外开展</span></span><br><span class="line">            ret += check(s, i, i + <span class="number">1</span>); <span class="comment">// 偶数的情况，从相邻2个向外开展</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &gt;= <span class="number">0</span> &amp;&amp; hi &lt; s.size() &amp;&amp; s[lo--] == s[hi++])</span><br><span class="line">            ++ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> ret = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>; <span class="comment">// 单个字母的base</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = s[i] == s[i + <span class="number">1</span>]; <span class="comment">// 相邻两个字母相同的base</span></span><br><span class="line">            ret += dp[i][i + <span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，由于每次的dp是基于长度缩小的区间，所以需要根据长度大小来遍历，从较短的长度遍历到较长的长度。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">3</span>; len &lt;= s.size(); ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len - <span class="number">1</span>; j &lt; s.size(); ++i, ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                ret += dp[i][j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>650. 2 Keys Keyboard</title>
    <url>/2021/04/03/650-2-Keys-Keyboard/</url>
    <content><![CDATA[<h4 id="keys-keyboard"><a href="https://leetcode.com/problems/2-keys-keyboard/">650. 2 Keys Keyboard</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = i - <span class="number">1</span>; j &gt; <span class="number">1</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i % j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + i / j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">````</span><br><span class="line">T(n) : O(n^<span class="number">2</span>) ? &lt;br&gt;</span><br><span class="line">S(n) : O(n)</span><br><span class="line"></span><br><span class="line">寻找当前的最大除以<span class="number">2.</span>..的数，然后将那个数对应的操作翻倍</span><br><span class="line"></span><br><span class="line">####<span class="meta"># solution数学方法 </span></span><br><span class="line"></span><br><span class="line">[Prime Factorization 整数分解](https:<span class="comment">//zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3)</span></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> minSteps(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!(n % d))</span><br><span class="line">            &#123;</span><br><span class="line">                ret += d;</span><br><span class="line">                n /= d;</span><br><span class="line">            &#125;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n) worst <br> S(n) : O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>66. Plus One</title>
    <url>/2021/04/07/66-Plus-One/</url>
    <content><![CDATA[<h4 id="plus-one"><a href="https://leetcode.com/problems/plus-one/">66. Plus One</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = digits.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ++digits[i];</span><br><span class="line">        <span class="keyword">while</span>(digits[i] &gt; <span class="number">9</span> &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = digits[i] / <span class="number">10</span>;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            --i;</span><br><span class="line">            digits[i] += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(digits.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>69. Sqrt(x)</title>
    <url>/2021/05/02/69.%20Sqrt(x)/</url>
    <content><![CDATA[<h4 id="sqrtx"><a href="https://leetcode.cinte.cc/index.html">69. Sqrt(x)</a></h4>
<h5 id="newtons-method"><a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division">Newton's method</a></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = x;</span><br><span class="line">        <span class="keyword">while</span>(r * r &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            r = (r + x / r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="binary-search">binary search</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> || x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &gt; x / mid)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid + <span class="number">1</span> &gt; x / (mid + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>:use<code>mid &gt; x / mid</code> instead of <code>mid * mid &gt; x</code>, because of the overflow</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2021/03/03/7-Reverse-Integer/</url>
    <content><![CDATA[<h4 id="reverse-integer"><a href="https://leetcode.com/problems/reverse-integer/">7. Reverse Integer</a></h4>
<h5 id="第一次">第一次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX / <span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span>) &amp;&amp; (pop &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span>) &amp;&amp; (pop &lt; INT_MIN % <span class="number">10</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>70. Climbing Stairs</title>
    <url>/2021/03/26/70-Climbing-Stairs/</url>
    <content><![CDATA[<h4 id="climbing-stairs"><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h4>
<h5 id="动态规划每一步都可分为1-剩余n-1-2-剩余n-2">动态规划，每一步都可分为1 + 剩余n-1 + 2 + 剩余n-2</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        dp.push_back(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="优化sn">优化S(n)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            swap(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>72. Edit Distance</title>
    <url>/2021/05/05/72.%20Edit%20Distance/</url>
    <content><![CDATA[<h4 id="edit-distance"><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(word1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(word2.size() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.size(); ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word2.size(); ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = min(min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2) <br> S(n) : O(n^2)</p>
<p>动态规划</p>
<p>设<code>dp[i][j]</code>代表从<code>word1[0...i)</code>转到<code>word2[0...j)</code>所需的最小次数。假设已知<code>dp[i - 1][j - 1]</code>，即<code>word1[0...i - 1)</code>转到<code>word2[0...j - 1)</code>所需的最小步数，此时可保证，将面临一些几种情况，此时可保证<code>word1[0...i - 1) == word2[0...j - 1)</code>。</p>
<ol type="1">
<li>当<code>word1[i - 1] == word2[j - 1]</code>, 则<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li>
<li>当<code>word1[i - 1] != word2[j - 1]</code>, 则需要<code>replace(word1[i - 1], word2[j - 1])</code>，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>。</li>
<li>当<code>word1[0...i - 1) == word2[0...j)</code>，则需要<code>delete(word1[i - 1])</code>，<code>dp[i][j] = dp[i - 1][j] + 1</code>。</li>
<li>当<code>word1[0...i - 1) + word2[j - 1] == word2[0...j)</code>，则需要<code>insert(word2[j - 1])</code>，<code>dp[i][j] = dp[i][j - 1] + 1</code>。 对于后三种情况，取最小值即可忽略复杂的判断(考虑replace，insert，delete)三种操作</li>
</ol>
<p>base:</p>
<ol type="1">
<li><code>dp[i][0] = i</code>，所有<code>word[0...i)</code>转到0长度都需要删掉i个数字</li>
<li><code>dp[0][j] = j</code>，同理</li>
</ol>
<h5 id="optimize-space">optimize space</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(word2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word2.size(); ++i)</span><br><span class="line">            dp[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[j] = prev;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[j] = min(min(dp[j - <span class="number">1</span>], dp[j]), prev) + <span class="number">1</span>;</span><br><span class="line">                prev = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化方式参考<a href="https://leetcode.cinte.cc/2021/04/19/221-Maximal-Square/">221. Maximal Square</a></p>
<p>注意这里需要每次更新dp[0]用做base</p>
<iframe width="300" height="150" src="https://www.youtube.com/embed/We3YDTzNXEk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>73. Set Matrix Zeroes</title>
    <url>/2021/05/15/73.%20Set%20Matrix%20Zeroes/</url>
    <content><![CDATA[<h4 id="set-matrix-zeroes"><a href="https://leetcode.com/problems/set-matrix-zeroes/">73. Set Matrix Zeroes</a></h4>
<p>我好菜</p>
<h5 id="space-compelexity-om-n">space compelexity O(m + n)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    row.insert(i);</span><br><span class="line">                    col.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(row.find(i) != row.end() || col.find(j) != col.end())</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="space-compelexity-o1">space compelexity O1)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line">        <span class="keyword">bool</span> isCol = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                isCol = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cols; ++i)</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isCol)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为第一行和第一列为0都由一个matrix[0][0]指定，将导致二者无法区分，所以用matrix[0][0]指定第一行，isCol这个额外的变量指定第一列。</p>
<p><strong>注意要先填充第一行第一列以外的内容再去填充第一行第一列，不然后面数据会被填充的0所干扰</strong></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>739. Daily Temperatures</title>
    <url>/2021/04/14/739-Daily-Temperatures/</url>
    <content><![CDATA[<h4 id="daily-temperatures"><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="number">101</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(T.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> warmer = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = T[i] + <span class="number">1</span>; j &lt;= <span class="number">100</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[j] &lt; warmer)</span><br><span class="line">                &#123;</span><br><span class="line">                    warmer = next[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(warmer &lt; INT_MAX)</span><br><span class="line">                ret[i] = warmer - i;</span><br><span class="line">            next[T[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从后开始，对于温度为70的，接下来只会出现71~100的温度，只需要记录这些温度出现的天数，然后寻求一个最近的天数即可。由于是从后面开始更新的，所以不用怕前面的天数出来扰乱我</p>
<h5 id="使用堆栈">使用堆栈</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(T.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[i] &gt;= T[s.top()])</span><br><span class="line">                s.pop();</span><br><span class="line">            ret[i] = s.empty() ? <span class="number">0</span> : s.top() - i;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设，对于位于i = 1处的天气为30度，若i = 2处的天气为50，而i = 4处的天气为30，显然，对于I = 1来说，i = 4是对他没有任何意义的，因此可以舍弃掉i = 4; <br> 反之，若T[1] = 30, T[2] = 50, T[4] = 100, 则无法舍弃T[4] 因为若1和2之间出现一个60，则T[4]必须留着。</p>
<p>对于这种次序，只保留从大到小的序列，前面一个如果比后面大，后面的对于前面一个就无用了，就出栈，然后自己算完自己的后，入栈，一人就可以遮蔽后买你的所有效果</p>
<p>另一种堆栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = s.top();</span><br><span class="line">                ret[tmp] = i - tmp;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>75. Sort Colors</title>
    <url>/2021/04/05/75-Sort-Colors/</url>
    <content><![CDATA[<h4 id="sort-colors"><a href="https://leetcode.com/problems/sort-colors/">75. Sort Colors</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        sort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; nums[++i] &lt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; j &amp;&amp; nums[--j] &gt; v) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;=j ) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>快速排序算法，每次取一个数为v，将所有大于v的数放在v右边，小于V的数放在v左边，最后将选择的数放到正确位置上，再对剩下的2个进行分而治之</p>
<h5 id="针对具体问题的解决方法">针对具体问题的解决方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> second = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] == <span class="number">2</span> &amp;&amp; i &lt; second)</span><br><span class="line">                swap(nums[i], nums[second--]);</span><br><span class="line">            <span class="keyword">while</span>(nums[i] == <span class="number">0</span> &amp;&amp; i &gt; zero)</span><br><span class="line">                swap(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体思路是将0移到最前面，将2移到最后面</p>
<p>这里<code>==2</code>必须放在<code>==0</code>之前，因为2为最大的，将2换到最后去，换回来的只可能比2小，会有可能是0，需要处理。若0在前，则2换完后的0得不到处理。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>76. Minimum Window Substring</title>
    <url>/2021/05/08/76.%20Minimum%20Window%20Substring/</url>
    <content><![CDATA[<h4 id="minimum-window-substring"><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></h4>
<h5 id="使用了之前sliding-window的范式">使用了之前sliding window的范式</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> curMax = s.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : t)</span><br><span class="line">            <span class="built_in">map</span>[ch] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="built_in">map</span>.size();</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[end]) != <span class="built_in">map</span>.end())</span><br><span class="line">            &#123;</span><br><span class="line">                --<span class="built_in">map</span>[s[end]];</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>[s[end]])</span><br><span class="line">                    --count; </span><br><span class="line">            &#125;</span><br><span class="line">            ++end;</span><br><span class="line">            <span class="keyword">while</span>(!count)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[begin]) != <span class="built_in">map</span>.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    ++<span class="built_in">map</span>[s[begin]];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin]] &gt; <span class="number">0</span>)</span><br><span class="line">                        ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(end - begin &lt; curMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    curMax = end - begin;</span><br><span class="line">                    ret.first = begin;</span><br><span class="line">                    ret.second = curMax;</span><br><span class="line">                &#125;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(ret.first, ret.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="filtered">filtered</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : t)</span><br><span class="line">            <span class="built_in">map</span>[ch] += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; newS;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[i]) != <span class="built_in">map</span>.end())</span><br><span class="line">                newS.push_back(<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&#123;s[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="built_in">map</span>.size();</span><br><span class="line">        <span class="keyword">int</span> curWindow = s.size();</span><br><span class="line">        <span class="keyword">int</span> ansL = <span class="number">0</span>, ansR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; newS.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--<span class="built_in">map</span>[newS[end].first] == <span class="number">0</span>)</span><br><span class="line">                --count;</span><br><span class="line">            <span class="keyword">while</span>(!count)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(newS[end].second - newS[begin].second &lt; curWindow)</span><br><span class="line">                &#123;</span><br><span class="line">                    ansL = newS[begin].second;</span><br><span class="line">                    ansR = newS[end].second + <span class="number">1</span>;</span><br><span class="line">                    curWindow = ansR - ansL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(++<span class="built_in">map</span>[newS[begin].first] &gt; <span class="number">0</span>)</span><br><span class="line">                    ++count;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(ansL, ansR - ansL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>763. Partition Labels</title>
    <url>/2021/04/14/763-Partition-Labels/</url>
    <content><![CDATA[<h4 id="partition-labels"><a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels</a></h4>
<h5 id="我好菜">我好菜</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c[S[i] - <span class="string">&#x27;a&#x27;</span>] = i; <span class="comment">// 记录每个元素最后出现的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            last = max(last, c[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 计算之前子串中出现的字母的最后的位置</span></span><br><span class="line">            <span class="keyword">if</span>(i == last) <span class="comment">// 如果这个条件成立了，表示当前子串(anchor - i)中的所有字母都只出现过了一次，并且之后不会再出现了，所以开始i计算并保存结果。</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(last + <span class="number">1</span> - anchor);</span><br><span class="line">                anchor = last + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每走到一步就判断他的最后一位，差不多就寻求一个最大区间</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>78. Subsets</title>
    <url>/2021/03/23/78-Subsets/</url>
    <content><![CDATA[<h4 id="subsets"><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></h4>
<h5 id="backtrack"><a href="https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)">backTrack</a></h5>
<blockquote>
<p>摘自wiki: 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案</p>
</blockquote>
<h5 id="原">原</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        ret.push_back(&#123;&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)</span><br><span class="line">            backTrack(ret, temp, nums, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size() == n)</span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">        <span class="keyword">if</span>(temp.size() &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            backTrack(ret, temp, nums, n, i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="改">改</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        backTrack(ret, temp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ret.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            backTrack(ret, temp, nums, i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>79. Word Search</title>
    <url>/2021/04/07/79-Word-Search/</url>
    <content><![CDATA[<h4 id="word-search"><a href="https://leetcode.com/problems/word-search/">79. Word Search</a></h4>
<h5 id="backtrack">backtrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word[<span class="number">0</span>] == board[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] -= <span class="number">65</span>;</span><br><span class="line">                    <span class="keyword">if</span>(backTrack(board, word.substr(<span class="number">1</span>), i ,j))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    board[i][j] += <span class="number">65</span>;</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; word[<span class="number">0</span>] == board[i - <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            board[i - <span class="number">1</span>][j] -= <span class="number">65</span>;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word.substr(<span class="number">1</span>), i - <span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[i - <span class="number">1</span>][j] += <span class="number">65</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; word[<span class="number">0</span>] == board[i][j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            board[i][j - <span class="number">1</span>] -= <span class="number">65</span>;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word.substr(<span class="number">1</span>), i, j - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[i][j - <span class="number">1</span>] += <span class="number">65</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; board.size() - <span class="number">1</span> &amp;&amp; word[<span class="number">0</span>] == board[i + <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            board[i + <span class="number">1</span>][j] -= <span class="number">65</span>;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word.substr(<span class="number">1</span>), i + <span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[i + <span class="number">1</span>][j] += <span class="number">65</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; word[<span class="number">0</span>] == board[i][j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            board[i][j + <span class="number">1</span>] -= <span class="number">65</span>;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word.substr(<span class="number">1</span>), i, j + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[i][j + <span class="number">1</span>] += <span class="number">65</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2)<br> S(n) : O(1)</p>
<p>一点开始搜索其周围</p>
<h5 id="优化">优化</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word[<span class="number">0</span>] == board[i][j])</span><br><span class="line">                    <span class="keyword">if</span>(backTrack(board, word, i ,j, <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] -= <span class="number">65</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; word[index] == board[i - <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word, i - <span class="number">1</span>, j, index + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; word[index] == board[i][j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word, i, j - <span class="number">1</span>, index + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; board.size() - <span class="number">1</span> &amp;&amp; word[index] == board[i + <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word, i + <span class="number">1</span>, j, index + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; word[index] == board[i][j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrack(board, word, i, j + <span class="number">1</span>, index + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] += <span class="number">65</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review">review</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backTrack(board, i, j, word, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] &lt; <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == word[index])</span><br><span class="line">        &#123;</span><br><span class="line">            board[i][j] -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">bool</span> ret = (i &gt; <span class="number">0</span> &amp;&amp; backTrack(board, i - <span class="number">1</span>, j, word, index + <span class="number">1</span>))</span><br><span class="line">                    || (i &lt; board.size() - <span class="number">1</span> &amp;&amp; backTrack(board, i + <span class="number">1</span>, j, word, index + <span class="number">1</span>))</span><br><span class="line">                    || (j &gt; <span class="number">0</span> &amp;&amp; backTrack(board, i, j - <span class="number">1</span>, word, index + <span class="number">1</span>))</span><br><span class="line">                    || (j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; backTrack(board, i, j + <span class="number">1</span>, word, index + <span class="number">1</span>))</span><br><span class="line">                    || (index == word.size() - <span class="number">1</span>);</span><br><span class="line">            board[i][j] += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="review-again">review again</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(search(board, i, j, m, n, word, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= word.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || i &lt; <span class="number">0</span> || j &gt;= n || j &lt; <span class="number">0</span> || board[i][j] &lt; <span class="string">&#x27;A&#x27;</span> || word[index] != board[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        board[i][j] -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = search(board, i + <span class="number">1</span>, j, m, n, word, index + <span class="number">1</span>)</span><br><span class="line">                || search(board, i - <span class="number">1</span>, j, m, n, word, index + <span class="number">1</span>)</span><br><span class="line">                || search(board, i, j + <span class="number">1</span>, m, n, word, index + <span class="number">1</span>)</span><br><span class="line">                || search(board, i, j - <span class="number">1</span>, m, n, word, index + <span class="number">1</span>);</span><br><span class="line">        board[i][j] += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
      </tags>
  </entry>
  <entry>
    <title>797. 所有可能的路径</title>
    <url>/2021/08/25/797.%20%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="所有可能的路径"><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allPathsSourceTarget(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cannotReach</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(graph, ret, tmp, cannotReach, <span class="number">0</span>, graph.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cannotReach, <span class="keyword">int</span> node, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cannotReach[node])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        tmp.push_back(node);</span><br><span class="line">        <span class="keyword">if</span>(node == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(graph[node].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; next : graph[node])</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph, ret, tmp, cannotReach, next, target))</span><br><span class="line">                cannotReach[node] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="简洁">简洁</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allPathsSourceTarget(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        dfs(graph, ret, tmp, <span class="number">0</span>, graph.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> node, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; next : graph[node])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(next);</span><br><span class="line">            dfs(graph, ret, tmp, next, target);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>8. String to Integer (atoi)</title>
    <url>/2021/02/05/8-String-to-Integer-(atoi)/</url>
    <content><![CDATA[<h4 id="string-to-integer-atoi"><a href="https://leetcode.com/problems/string-to-integer-atoi/">8. String to Integer (atoi)</a></h4>
<h5 id="第一次">第一次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> positive = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> isEntered = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!isEntered)</span><br><span class="line">                &#123;</span><br><span class="line">                    positive = <span class="number">1</span>;</span><br><span class="line">                    isEntered = <span class="literal">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> positive * sum;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!isEntered)</span><br><span class="line">                &#123;</span><br><span class="line">                    positive = <span class="number">-1</span>;</span><br><span class="line">                    isEntered = <span class="literal">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> positive * sum;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (ch &gt;= <span class="number">48</span> &amp;&amp; ch &lt;= <span class="number">57</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isEntered)</span><br><span class="line">                        isEntered = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> pop = ch - <span class="number">48</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (positive)</span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> (sum &gt; INT_MAX / <span class="number">10</span> || (sum == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>))</span><br><span class="line">                            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">if</span> (-sum &lt; INT_MIN / <span class="number">10</span> || (-sum == INT_MIN / <span class="number">10</span> &amp;&amp; pop &gt;= <span class="number">8</span>))</span><br><span class="line">                            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum = sum * <span class="number">10</span> + pop;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ch != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> positive * sum;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span> &amp;&amp; isEntered)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> positive * sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> positive * sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>坑有点多，起初忽视了很多种情况</p>
<p>其中判断是否溢出参考了https://leetcode.com/problems/reverse-integer/solution/</p>
<p><img src="https://image.cinte.cc/2021/02/05/4cbcd1e8425be.png" /></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>821. 字符的最短距离</title>
    <url>/2021/08/26/821.%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h4 id="字符的最短距离"><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821. 字符的最短距离</a></h4>
<h5 id="两次遍历">两次遍历</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prelocation = <span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(s.size(), INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz = s.size(); i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">                prelocation = i;</span><br><span class="line">            <span class="keyword">if</span>(prelocation &gt;= <span class="number">0</span>)</span><br><span class="line">                ret[i] = min(ret[i], i - prelocation);</span><br><span class="line">        &#125;</span><br><span class="line">        prelocation = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">                prelocation = i;</span><br><span class="line">            <span class="keyword">if</span>(prelocation &gt;= <span class="number">0</span>)</span><br><span class="line">                ret[i] = min(ret[i], prelocation - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2021/08/26/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="删除排序链表中的重复元素"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pt = head;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">-101</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val == pt-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(pt &amp;&amp; pre-&gt;val == pt-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = pt;</span><br><span class="line">                    pt = pt-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;next = pt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pt)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pre = pt;</span><br><span class="line">            pt = pt-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pt = head;</span><br><span class="line">        <span class="keyword">while</span>(pt-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;val == pt-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = pt-&gt;next;</span><br><span class="line">                pt-&gt;next = pt-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                pt = pt-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>84. Largest Rectangle in Histogram</title>
    <url>/2021/05/08/84.%20Largest%20Rectangle%20in%20Histogram/</url>
    <content><![CDATA[<h4 id="largest-rectangle-in-histogram"><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = heights.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(sz)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(sz)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        right.back() = sz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p &gt;= <span class="number">0</span> &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = left[p];</span><br><span class="line">            left[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">2</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; sz &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = right[p];</span><br><span class="line">            right[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">            ret = max(ret, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个位置的最大矩形是其<code>(right - left) * cur_height</code>，而左边可以通过遍历查找离他最远且值&gt;=他本身的坐标，右边也可通过遍历查找离他最远的且一路上值&gt;=它本身的坐标。但如果对每个坐标都进行一次左右遍历就会消耗太多计算量。</p>
<p>此时可以采用dp</p>
<p><strong>设想，对于先前查找过的元素，比如<code>p&lt;i</code>，如果p是符合条件<code>heights[p] &gt;= heights[i]</code>的，那么p的左边界也必然是符合这个条件的，由此可以进行坐标的跳跃，将下一迭代的<code>p = left[p]</code>，道理则依次。所以每个查找都可以运用到之前到查找的信息。总体来说仅仅为O(n)，对于右边界来说则同理。</strong></p>
<h5 id="使用stack">使用stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">-1</span>); <span class="comment">// 这里的-1是为了在最后计算所有横跨许多块的长度</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; heights[i] &lt; heights[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> h = heights[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                ret = max(ret, (i - (s.empty() ? <span class="number">-1</span> : s.top()) - <span class="number">1</span>) * h);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>维持stack为上升序列，每碰到之前比他大的就pop掉，因为你如果比他小了，那么对于你这个柱子来说的最大矩形的高度必定受限于你而不是他，之前所有比你大的pop掉后的真空区域就是这个的面积。而循环中的i为右界，取不到，stack.top()，为左界，也取不到，中间的就是所有比你大的。上升队列的每2个之间都会有一个真空区域，而面积必定为区域宽度x右边。 <img src="https://image.cinte.cc/2021/05/08/41df4c0a04bc7.png" alt="1620478443908.png" /></p>
<p><a href="https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html">why stack?</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>85. Maximal Rectangle</title>
    <url>/2021/05/07/85.%20Maximal%20Rectangle/</url>
    <content><![CDATA[<h4 id="maximal-rectangle"><a href="https://leetcode.com/problems/maximal-rectangle/">85. Maximal Rectangle</a></h4>
<p>太难理解了！！！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 每个点具有三个信息，左界，右界和高度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curL = <span class="number">0</span>, curR = n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    right[j] = min(right[j], curR);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[j] = n;</span><br><span class="line">                    curR = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++height[j];</span><br><span class="line">                    left[j] = max(curL, left[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">                    left[j] = <span class="number">0</span>;</span><br><span class="line">                    curL = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxA = max(maxA, (right[j] - left[j]) * height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有信息会进行传递</p>
<p>出现如下这种时[1][4]元素左界会有上面那个来界定，高度也会随之更新，但不必担心由此扰乱更大的矩形的判断，因为这个元素处curR为5，若这个竖着的矩形不是最大矩形，那么这个右界限会保持住传给他的左边隔壁，如果他左边隔壁也不要这个右界限，说明左边隔壁也继承了上一层的信息。那么继续传递过去，如果都不要，那么2是有2层的，不要也无所谓了，肯定比一层长。同理左界限也会传递。由此这一层中的每个元素都会记录他本身所在的矩形，并且是所有局部最大矩形。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000010</span><br><span class="line">011111</span><br></pre></td></tr></table></figure> 还是有点绕</p>
<p><del>明天去画个图</del></p>
<figure>
<img src="https://image.cinte.cc/2021/05/08/c53ef4b66adbe.png" alt="1620472343565.png" /><figcaption aria-hidden="true">1620472343565.png</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>876. Middle of the Linked List</title>
    <url>/2021/04/30/876.%20Middle%20of%20the%20Linked%20List/</url>
    <content><![CDATA[<h4 id="middle-of-the-linked-list"><a href="https://leetcode.com/problems/middle-of-the-linked-list/">876. Middle of the Linked List</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* walker = head;</span><br><span class="line">        ListNode* runner = head;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> walker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2021/06/08/88.%20Merge%20Sorted%20Array/</url>
    <content><![CDATA[<h4 id="merge-sorted-array"><a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大的全放后面，小的就留在前面</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>881. 救生艇</title>
    <url>/2021/08/23/881.%20%E6%95%91%E7%94%9F%E8%89%87/</url>
    <content><![CDATA[<h4 id="救生艇"><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></h4>
<p>如果最轻的人可以和任何人配对，那么它也可以和最重的人配对。而如果不行，那最重的人无论如何都只能一个人做了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        sort(people.begin(), people.end());</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = people.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end) <span class="comment">// 当相等时表示最后只有1个人了，无论什么情况都需要再加一艘船。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(people[begin] + people[end] &lt;= limit)</span><br><span class="line">                ++begin;</span><br><span class="line">            --end;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最重的走的时候，如果能带，一定要带个人走，这才是合理的，否则，例如【1,3】，limit = 4，这种，3先自己坐船走，1只能再乘一条船。显然不合理。 那最终的走的时候，带谁走呢，显然是最轻的（当然他也可能能够次轻的同乘一条船），反证下，如果因为它带了最轻的，导致次轻的无法跟其他人同船，那么次轻的也一定无法跟最重的乘船。如果次轻的可以跟其他人同船，则反正同船了，跟谁效果都一样。所以 不会因为最重的选择了最轻的同船，导致后面的配对结果更坏。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>89. 格雷编码</title>
    <url>/2021/08/19/89.%20%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h4 id="格雷编码"><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a></h4>
<p>挨个遍历，傻方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">set</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">set</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        helper(n, ret, <span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret.size() == <span class="number">1</span> &lt;&lt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = ret.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = preNum ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>[tmp])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>[tmp] = <span class="number">1</span>;</span><br><span class="line">                ret.push_back(tmp);</span><br><span class="line">                helper(n, ret, <span class="built_in">set</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="大佬的仙法">大佬的仙法</h5>
<p>镜像构造</p>
<p>贴题解</p>
<p><a href="https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/">Gray Code （镜像反射法，图解） - 格雷编码 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = ret.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                ret.push_back(ret[j] ^ head);</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="公式">公式</h5>
<p>格雷码的每一位</p>
<p><code>G(i) = Bi ^ (Bi + 1)</code>换言之就是<code>G(i) = Bi ^ (Bi &gt;&gt; 1)</code></p>
<p>对于一位如此，对于所有位都如此。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</span><br><span class="line">            ret.push_back(i ^ (i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2021/03/03/9-Palindrome-Number/</url>
    <content><![CDATA[<h4 id="palindrome-number"><a href="https://leetcode.com/problems/palindrome-number/">9. Palindrome Number</a></h4>
<h5 id="第一次">第一次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(reverse(x) == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX / <span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span>) &amp;&amp; (pop &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span>) &amp;&amp; (pop &lt; INT_MIN % <span class="number">10</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>90. Subsets II</title>
    <url>/2021/06/14/90.%20Subsets%20II/</url>
    <content><![CDATA[<h4 id="subsets-ii"><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        ret.push_back(&#123;&#125;);</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">// 把重复的放到一起</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(count + i &lt; nums.size() &amp;&amp; nums[i] == nums[count + i])  <span class="comment">// 记录重复的数字，对于一个i开始，如果i+count处的值和i一样，那么++</span></span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">int</span> n = ret.size(); <span class="comment">// 获得ret中的元素个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="comment">// 依次从ret中取出所有的列，为了给他们结尾增加</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = ret[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.push_back(nums[i]); <span class="comment">// 对于重复的个数，每种个数添加一次防止重复</span></span><br><span class="line">                    ret.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i += count; <span class="comment">// 跳到没有重复的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        backTrack(ret, nums, &#123;&#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ret.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != start &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="comment">// 对于重复的每个位置，都只添加一次，绝不添加多次重复部分的多个位置</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backTrack(ret, nums, tmp, i + <span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>91. Decode Ways</title>
    <url>/2021/06/08/91.%20Decode%20Ways/</url>
    <content><![CDATA[<h4 id="decode-ways"><a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(memo[i] &amp;&amp; s[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                memo[i + <span class="number">1</span>] += memo[i];</span><br><span class="line">            <span class="keyword">if</span>(memo[i - <span class="number">1</span>] &amp;&amp; <span class="built_in">map</span>.find(s.substr(i - <span class="number">1</span>, <span class="number">2</span>)) != <span class="built_in">map</span>.end())</span><br><span class="line">                memo[i + <span class="number">1</span>] += memo[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">map</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>, </span><br><span class="line">        <span class="string">&quot;3&quot;</span>, </span><br><span class="line">        <span class="string">&quot;4&quot;</span>, </span><br><span class="line">        <span class="string">&quot;5&quot;</span>, </span><br><span class="line">        <span class="string">&quot;6&quot;</span>, </span><br><span class="line">        <span class="string">&quot;7&quot;</span>, </span><br><span class="line">        <span class="string">&quot;8&quot;</span>, </span><br><span class="line">        <span class="string">&quot;9&quot;</span>, </span><br><span class="line">        <span class="string">&quot;10&quot;</span>, </span><br><span class="line">        <span class="string">&quot;11&quot;</span>, </span><br><span class="line">        <span class="string">&quot;12&quot;</span>, </span><br><span class="line">        <span class="string">&quot;13&quot;</span>, </span><br><span class="line">        <span class="string">&quot;14&quot;</span>, </span><br><span class="line">        <span class="string">&quot;15&quot;</span>, </span><br><span class="line">        <span class="string">&quot;16&quot;</span>, </span><br><span class="line">        <span class="string">&quot;17&quot;</span>, </span><br><span class="line">        <span class="string">&quot;18&quot;</span>, </span><br><span class="line">        <span class="string">&quot;19&quot;</span>,</span><br><span class="line">        <span class="string">&quot;20&quot;</span>, </span><br><span class="line">        <span class="string">&quot;21&quot;</span>, </span><br><span class="line">        <span class="string">&quot;22&quot;</span>, </span><br><span class="line">        <span class="string">&quot;23&quot;</span>,</span><br><span class="line">        <span class="string">&quot;24&quot;</span>, </span><br><span class="line">        <span class="string">&quot;25&quot;</span>, </span><br><span class="line">        <span class="string">&quot;26&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每步检查当前的是否符合，如果符合，继承前一个的路数。</p>
<p>当前和前一个叠加的是否符合，如果符合，继承前前的路数</p>
<p>路数是相加的，因为这里分叉了</p>
<h5 id="不用set">不用set</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(memo[i] &amp;&amp; s[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                memo[i + <span class="number">1</span>] += memo[i];</span><br><span class="line">            <span class="keyword">if</span>(memo[i - <span class="number">1</span>] &amp;&amp; stoi(s.substr(i - <span class="number">1</span>, <span class="number">2</span>)) &lt;= <span class="number">26</span> &amp;&amp; stoi(s.substr(i - <span class="number">1</span>, <span class="number">2</span>)) &gt;= <span class="number">10</span>)</span><br><span class="line">                memo[i + <span class="number">1</span>] += memo[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.back();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>912. Sort an Array</title>
    <url>/2021/03/15/912-Sort-an-Array/</url>
    <content><![CDATA[<h4 id="sort-an-array"><a href="https://leetcode.com/problems/sort-an-array/">912. Sort an Array</a></h4>
<h5 id="quicksort">QuickSort</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(v &gt; nums[++i] &amp;&amp; i != hi);</span><br><span class="line">            <span class="keyword">while</span>(v &lt; nums[--j] &amp;&amp; j != lo);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        sort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <url>/2021/04/07/94-Binary-Tree-Inorder-Traversal/</url>
    <content><![CDATA[<h4 id="binary-tree-inorder-traversal"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        traversal(ret, root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        traversal(ret, root-&gt;left);  </span><br><span class="line">        ret.push_back(root-&gt;val);        </span><br><span class="line">        traversal(ret, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)<br> S(n) : O(n)</p>
<h5 id="stack">stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ret.push_back(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>95. Unique Binary Search Trees II</title>
    <url>/2021/04/04/95-Unique-Binary-Search-Trees-II/</url>
    <content><![CDATA[<h4 id="unique-binary-search-trees-ii"><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees II</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; nodeLeft : dp[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; nodeRight : dp[i - j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        TreeNode* tmp = <span class="keyword">new</span> TreeNode(j);</span><br><span class="line">                        tmp-&gt;left = nodeLeft;</span><br><span class="line">                        tmp-&gt;right = clone(nodeRight, j);</span><br><span class="line">                        dp[i].push_back(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">clone</span><span class="params">(TreeNode* root, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> TreeNode(root-&gt;val + offset);</span><br><span class="line">        newNode-&gt;left = clone(root-&gt;left, offset);</span><br><span class="line">        newNode-&gt;right = clone(root-&gt;right, offset);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和<a href="https://leetcode.cinte.cc/2021/03/31/96-Unique-Binary-Search-Trees/">Unique Binary Search Trees</a>相似，只不过这个要列举出所有节点</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <url>/2021/03/31/96-Unique-Binary-Search-Trees/</url>
    <content><![CDATA[<h4 id="unique-binary-search-trees"><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></h4>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抄了<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i)">discussion</a></p>
<p>将问题分解为每个小小的n会生成多少的树，最后左树数 * 右树数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>97. Interleaving String</title>
    <url>/2021/05/16/97.%20Interleaving%20String/</url>
    <content><![CDATA[<h4 id="interleaving-string"><a href="https://leetcode.com/problems/interleaving-string/">97. Interleaving String</a></h4>
<p>dp:</p>
<ol type="1">
<li>递归</li>
<li>带memory的递归top-down</li>
<li>bottom-up</li>
</ol>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2, <span class="built_in">string</span>&amp; s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= s1.size())</span><br><span class="line">            <span class="keyword">return</span> isEquel(s2, s3, j, k);</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= s2.size())</span><br><span class="line">            <span class="keyword">return</span> isEquel(s1, s3, i, k);</span><br><span class="line">        <span class="keyword">return</span> (s1[i] == s3[k] &amp;&amp; helper(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>)) || (s2[j] == s3[k] &amp;&amp; helper(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEquel</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() - i != s2.size() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.size() &amp;&amp; j &lt; s2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i++] != s2[j++])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是在递归过程中，如果有些部分有几个重复的连续串，那么就会产生运算的交叠，所以使用memo来规避已经计算过的内容</p>
<p>sample: <img src="https://image.cinte.cc/2021/05/17/64527a37943ab.png" alt="1621222087208.png" /></p>
<h5 id="top-down">top-down</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(s1.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size(), - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(s1.size() + s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2, <span class="built_in">string</span>&amp; s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= s1.size())</span><br><span class="line">            <span class="keyword">return</span> isEquel(s2, s3, j, k);</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= s2.size())</span><br><span class="line">            <span class="keyword">return</span> isEquel(s1, s3, i, k);</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][j] == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((s1[i] == s3[k] &amp;&amp; helper(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>)) || (s2[j] == s3[k] &amp;&amp; helper(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>)))</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        dp[i][j] = ans ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEquel</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() - i != s2.size() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i++] != s2[j++])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="bottom-up">bottom-up</h5>
<p>dp[i][j]表示(0..i)的s1子串和(0..j)的s2子串，如果他们可以交错成一个(0...i+j+1)的s3子串，那么就是true</p>
<p>2种情况</p>
<ol type="1">
<li>当<code>s1[i]!=s3[i+j+1] &amp;&amp; s2[j]!=s3[i+j+1]</code>，那么绝对为false，因为某尾匹配不了</li>
<li>当<code>s1[i]==s3[i+j+1]</code>时，那么结果等同于<code>dp[i-1][j]</code>，最后一位把s1[i]匹配走了，那么如果之前都匹配成功，就是true了，当<code>s2[j]==s3[i+j+1]</code>时同理</li>
</ol>
<p>base: <br> 当一个子串为空串时候的匹配结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() + s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s2.size() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() + s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s2.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>98. Validate Binary Search Tree</title>
    <url>/2021/05/05/98.%20Validate%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h4 id="validate-binary-search-tree"><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h4>
<h5 id="中序遍历bst是元素从小到达排列的因此如果未严格单调递增就是无效的bst">中序遍历BST是元素从小到达排列的，因此如果未严格单调递增，就是无效的BST</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;val &gt;= p-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            root = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="每个左点的上界为父节点下界则沿用上一节点右点的下界为父节点上界则沿用上衣节点这样可以保证界限是由上面传递下来的">每个左点的上界为父节点，下界则沿用上一节点，右点的下界为父节点，上界则沿用上衣节点，这样可以保证界限是由上面传递下来的</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MAX, LONG_MIN);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt;= max || node-&gt;val &lt;= min)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(node-&gt;left, node-&gt;val, min) &amp;&amp; helper(node-&gt;right, max, node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>99. Recover Binary Search Tree</title>
    <url>/2021/06/13/99.%20Recover%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h4 id="recover-binary-search-tree"><a href="https://leetcode.com/problems/recover-binary-search-tree/">99. Recover Binary Search Tree</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* first = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* second = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(!first &amp;&amp; (pre &amp;&amp; pre-&gt;val &gt;= node-&gt;val))</span><br><span class="line">            first = pre;</span><br><span class="line">        <span class="keyword">if</span>(first &amp;&amp; (pre &amp;&amp; pre-&gt;val &gt;= node-&gt;val))</span><br><span class="line">            second = node;</span><br><span class="line">        pre = node;</span><br><span class="line">        traverse(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>S(n) : O(logn)</p>
<p>由inorder的顺序来看，很神奇，找规律</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nice work. However, I think it&#39;d better to make this part more clear: the number of times that you will find prev.val &gt;&#x3D; root.val depends on whether the two nodes that get swapped are next to each other in the sequence of in-order traversal.</span><br><span class="line">Let&#39;s assume this is the original in-order traversal sequence of BST: 1 2 3 4 5</span><br><span class="line">If 2 and 3 get swapped, it becomes 1 3 2 4 5 and there is only one time that you will have prev.val &gt;&#x3D; root.val</span><br><span class="line">If 2 and 4 get swapped, it becomes 1 4 3 2 5 and there are two times that you will have prev.val &gt;&#x3D; root.val</span><br><span class="line"></span><br><span class="line">If during the first time when you find prev.val &gt;&#x3D; root.val, the previous node &quot;prev&quot; MUST be one of two nodes that get swapped. However, the current node MAY OR MAY NOT be another node that gets swapped, which will depend on whether later during in-order traversal, there is another prev.val &gt;&#x3D; root.val or not. If there is, then the current node &quot;root&quot; during the 2nd time of prev.val &gt;&#x3D; root.val will be the other node that gets swapped</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">How do we find these two elements? For example, we have the following tree that is printed as in order traversal:</span><br><span class="line"></span><br><span class="line">6, 3, 4, 5, 2</span><br><span class="line"></span><br><span class="line">We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5.</span><br></pre></td></tr></table></figure>
<h5 id="使用morris-traversal">使用morris Traversal</h5>
<p>https://leetcode.com/problems/recover-binary-search-tree/discuss/32559/Detail-Explain-about-How-Morris-Traversal-Finds-two-Incorrect-Pointer</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/2021/06/15/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-03.-数组中重复的数字"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4>
<h5 id="记录">记录</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(memo[num])</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                memo[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
<h5 id="排序">排序</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(nlogn)</p>
<p>S(n) : O(1)</p>
<h5 id="用swap">用swap</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于当走到i时，如果i处的数字不是i的话，就把这个数字移动到正确的位置nums[nums[i]]，然后对交换过来的数字继续判断是不是==i。</p>
<p>这样一来所有的数字都会被交换到正确的位置，当碰到重复数字时，那他一定不在正确的位置，这时候想把它交换过去的话，就会发现，唉！交换过去的位置已经有他了，那么就可以判断出来时重复了</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/2021/06/17/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h4 id="剑指-offer-05.-替换空格"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4>
<h5 id="遍历替换">遍历替换</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ret += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret += ch;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="原地替换">原地替换</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ++spaceCount;</span><br><span class="line">        s.resize(s.size() + <span class="number">2</span> * spaceCount);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>,j = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i, --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/2021/06/17/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="剑指-offer-06.-从尾到头打印链表"><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4>
<h5 id="先反转链表再打印">先反转链表再打印</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">auto</span> node = reverse(head);</span><br><span class="line">        <span class="keyword">while</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* newNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = node-&gt;next;</span><br><span class="line">            node-&gt;next = newNext;</span><br><span class="line">            newNext = node;</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) = O(n)</p>
<h5 id="遍历获取大小再倒着来">遍历获取大小再倒着来</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">不想写</span><br></pre></td></tr></table></figure>
<h5 id="递归时候返回">递归时候返回</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        re(ret, head);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">re</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        re(ret, node-&gt;next);</span><br><span class="line">        ret.push_back(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="用堆栈">用堆栈</h5>
<p>不想写</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/2021/06/15/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-09.-用两个栈实现队列"><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4>
<h5 id="倒来倒去">倒来倒去</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;  <span class="comment">// s2中的最上面必定为最后的，如果s2空 把s2倒过去</span></span><br><span class="line">        <span class="keyword">if</span>(s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/2021/06/15/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-10--i.-斐波那契数列"><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4>
<h5 id="一个初级dp">一个初级dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> memo[<span class="number">2</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = memo[<span class="number">0</span>];</span><br><span class="line">            memo[<span class="number">0</span>] += memo[<span class="number">1</span>];</span><br><span class="line">            memo[<span class="number">0</span>] %= <span class="number">1000000007</span>;</span><br><span class="line">            swap(memo[<span class="number">0</span>], memo[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="题解中的">题解中的</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memo[<span class="number">2</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; ++i) <span class="comment">// 为了少判断一下0和1的情况，他就多算一次，6的时候，保留5的计算结果，此时5的计算结果回到了memo[0]，但是多算了一次，没意思</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = memo[<span class="number">0</span>];</span><br><span class="line">            memo[<span class="number">0</span>] += memo[<span class="number">1</span>];</span><br><span class="line">            memo[<span class="number">0</span>] %= <span class="number">1000000007</span>;</span><br><span class="line">            swap(memo[<span class="number">0</span>], memo[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/2021/06/16/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-11.-旋转数组的最小数字"><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[hi]) <span class="comment">// 之所以和hi判断，是因为当numbers[mid] &gt; numbers[lo] 时候，具有多种情况，而和hi判断只有一种。</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[hi]) <span class="comment">// 因为numbers[mid] &lt; numbers[hi] 所以mid这个位置可能会最小，所以hi=mid</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --hi;   <span class="comment">// 主要难点是这种情况，当相等时，无法判断最小点是在左半边还是右半边。此时--hi，当旋转点&lt;hi时，易得--hi后旋转点依旧存在，当旋转点==hi时，因为中点值=旋转点值，因此即便删除了，和旋转点相等的值依旧流了下来，以后用得到。   ps: 碰到这种情况也可以直接遍历了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[hi];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <url>/2021/06/17/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="剑指-offer-12.-矩阵中的路径"><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/07/79-Word-Search/">79. Word Search</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <url>/2021/06/17/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h4 id="剑指-offer-13.-机器人的运动范围"><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStep = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; memo(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        backTrack(m, n, k, maxStep, <span class="number">0</span>, <span class="number">0</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> maxStep;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; maxStep, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || i &lt; <span class="number">0</span> || j &gt;= n || j &lt; <span class="number">0</span> || memo[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        memo[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> it = i, ij = j;</span><br><span class="line">        <span class="keyword">while</span>(it)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += it % <span class="number">10</span>;</span><br><span class="line">            it /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ij)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += ij % <span class="number">10</span>;</span><br><span class="line">            ij /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++maxStep;</span><br><span class="line">            backTrack(m, n, k, maxStep, i + <span class="number">1</span>, j, memo);</span><br><span class="line">            backTrack(m, n, k, maxStep, i - <span class="number">1</span>, j, memo);</span><br><span class="line">            backTrack(m, n, k, maxStep, i, j + <span class="number">1</span>, memo);</span><br><span class="line">            backTrack(m, n, k, maxStep, i, j - <span class="number">1</span>, memo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="优化sum的计算方法">优化sum的计算方法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxStep = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; memo(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        backTrack(m, n, k, maxStep, <span class="number">0</span>, <span class="number">0</span>, memo, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxStep;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; maxStep, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; memo,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || i &lt; <span class="number">0</span> || j &gt;= n || j &lt; <span class="number">0</span> || memo[i][j] || sum &gt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        memo[i][j] = <span class="literal">true</span>;</span><br><span class="line">        ++maxStep;</span><br><span class="line">        backTrack(m, n, k, maxStep, i + <span class="number">1</span>, j, memo, ((i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-8</span>) + sum);</span><br><span class="line">        backTrack(m, n, k, maxStep, i, j + <span class="number">1</span>, memo, ((j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-8</span>) + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/06/17/5f549df3dac5e.png" alt="1623937126537.png" /><figcaption aria-hidden="true">1623937126537.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <url>/2021/06/18/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h4 id="剑指-offer-14--i.-剪绳子"><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/submissions/">剑指 Offer 14- I. 剪绳子</a></h4>
<h5 id="dp">dp</h5>
<p>参考<a href="https://leetcode.cinte.cc/2021/05/19/343.%20Integer%20Break/">343. Integer Break</a></p>
<h5 id="数学方法-taifuzale">数学方法 TAIFUZALE</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 14- II. 剪绳子 II</title>
    <url>/2021/06/18/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    <content><![CDATA[<h4 id="剑指-offer-14--ii.-剪绳子-ii"><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4>
<p>这题由于n的范围加大 <img src="https://image.cinte.cc/2021/06/18/0c502a5a8b2f5.png" alt="1624010226494.png" /></p>
<h5 id="数学方法-taifuzale">数学方法 TAIFUZALE</h5>
<p>循环求余 <strong>这是使得中间值取余不影响结果取余的理论保证</strong> x^a % p = (x^(a-1) % p)<em>(x % p) = ((x^(a-1) % p) </em> x) % p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; ++i)</span><br><span class="line">    ret = ret * x % p</span><br></pre></td></tr></table></figure>
<p>完整代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (b == <span class="number">1</span> ? a - <span class="number">1</span> : a); ++i)</span><br><span class="line">            ret = ret * <span class="number">3</span> % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ret * <span class="number">4</span> % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ret * <span class="number">2</span> % p;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 15. 二进制中1的个数</title>
    <url>/2021/06/23/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-15.-二进制中1的个数"><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="骚方法太优秀了">骚方法（太优秀了</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/06/23/920f8c9f62526.png" alt="1624447689192.png" /><figcaption aria-hidden="true">1624447689192.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 16. 数值的整数次方</title>
    <url>/2021/06/24/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-16.-数值的整数次方"><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4>
<h5 id="二分法ologn">二分法O(logn)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(n);</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = -b;   <span class="comment">// 先反转成全是正数</span></span><br><span class="line">            x = <span class="number">1</span>/x;  <span class="comment">// 基准</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">                ret *= x;  <span class="comment">// 如果次数为奇数 那么先乘一个x, 如果结束前的一次迭代b = 2，那么会进入1，如果b = 1，那此时已经进入了，最后b=0时，因为0次方=0，所以没影响。</span></span><br><span class="line">            x *= x; <span class="comment">// 转为x^2</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>; <span class="comment">// 转为n/2</span></span><br><span class="line">            <span class="comment">// 操作过后 基准变为x^2，x^2成为了下一个x，而n/2成为了下一个n，由此迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当输入的次数n为<strong>奇数</strong>时</p>
<p><span class="math display">\[ X^n=X*(X^2)^{n/2}\]</span></p>
<p>当输入的次数n为<strong>偶数</strong>时</p>
<p><span class="math display">\[ X^n=(X^2)^{n/2}\]</span></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 17. 打印从1到最大的n位数</title>
    <url>/2021/08/30/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-17.-打印从1到最大的n位数"><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4>
<p>不考虑大数的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="built_in">pow</span>(<span class="number">10</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxNum; ++i)</span><br><span class="line">            ret.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="考虑大数的情况">考虑大数的情况</h5>
<p>需要使用字符串来表示数字</p>
<p>首先通过回溯，对于特定的位数，衔接上0~9</p>
<p>再进行去除前导0，设字符串无前导0的起始点为start，n为3时</p>
<p>则</p>
<p>1~9时，start=2</p>
<p>10~99时，start = 1</p>
<p>100~999时，start=0</p>
<p>综上可以得出start=n-(9的个数)</p>
<p>所以当碰到9时，增加9的个数，而但start = n - nine时，这时的所有位都是9，使start-1，表示要进位了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">		<span class="built_in">string</span> tmp;</span><br><span class="line">		<span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">		backTrack(ret, n, <span class="number">0</span>, tmp, start);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, <span class="keyword">int</span> n, <span class="keyword">int</span> nine, <span class="built_in">string</span>&amp; tmp, <span class="keyword">int</span>&amp; start)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == tmp.size())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> res = tmp.substr(start);</span><br><span class="line">			<span class="keyword">if</span>(res != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">				ret.push_back(res);</span><br><span class="line">			<span class="keyword">if</span> (start == n - nine)</span><br><span class="line">				--start;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp += (<span class="keyword">char</span>)(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">9</span>)</span><br><span class="line">				nine += <span class="number">1</span>;</span><br><span class="line">			backTrack(ret, n, nine, tmp, start);</span><br><span class="line">			tmp.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <url>/2021/06/25/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-18.-删除链表的节点"><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/submissions/">剑指 Offer 18. 删除链表的节点</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* ret = pre;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = head-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 19. 正则表达式匹配</title>
    <url>/2021/06/24/%E5%89%91%E6%8C%87%20Offer%2019.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h4 id="剑指-offer-19.-正则表达式匹配"><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h4>
<h5 id="虽然做过-但还是难">虽然做过 但还是难</h5>
<p>参考<a href="https://leetcode.cinte.cc/2021/05/11/10.%20Regular%20Expression%20Matching/">10. Regular Expression Matching</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.size() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp.back().back() = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size(); i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> firstMatch = i &lt; s.size() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 空串是不可能和正则中的值匹配的，所以i==s.size()时匹配始终失败</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt;= p.size() - <span class="number">2</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>] || (firstMatch &amp;&amp; dp[i + <span class="number">1</span>][j]); <span class="comment">// 这里可以处理到空串的情况</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = firstMatch &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 20. 表示数值的字符串</title>
    <url>/2021/06/22/%E5%89%91%E6%8C%87%20Offer%2020.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="剑指-offer-20.-表示数值的字符串"><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4>
<h5 id="常规思路">常规思路</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; s[start] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++start;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; start &amp;&amp; s[end] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            --end;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[start] == <span class="string">&#x27;+&#x27;</span> || s[start] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ++start;</span><br><span class="line">        <span class="keyword">bool</span> isMeetDigital = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isMeetDot = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isMeetE = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigital(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                isMeetDigital = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !isMeetDot)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isMeetE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                isMeetDot = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!isMeetDigital)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= end)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!isDigital(s[++i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        isMeetDigital = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isMeetDigital)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!isMeetE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">bool</span> isSigned = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; end &amp;&amp; (s[++i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(isSigned)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        isSigned = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= end &amp;&amp; isDigital(s[i]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        isMeetE = <span class="literal">true</span>;</span><br><span class="line">                        isMeetDigital = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigital</span><span class="params">(<span class="keyword">char</span>&amp; ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="状态机">状态机</h5>
<p><img src="https://image.cinte.cc/2021/06/23/13ee451ce60e5.png" alt="1624440075950.png" /> <img src="https://image.cinte.cc/2021/06/23/c4e27f54b0503.png" alt="1624440089788.png" /></p>
<p>太烦了 不想做</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/06/23/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h4 id="剑指-offer-21.-调整数组顺序使奇数位于偶数前面"><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4>
<h5 id="首尾">首尾</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; end &amp;&amp; nums[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                swap(nums[i], nums[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin] &amp; <span class="number">1</span>)</span><br><span class="line">                ++begin;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!(nums[end] &amp; <span class="number">1</span>))</span><br><span class="line">                --end;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(nums[begin], nums[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="快慢">快慢</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 慢指针用来记录可以放奇数的位置，快指针用来搜索后面的所有奇数，如果是奇数，就把他换到前面去</span></span><br><span class="line">        <span class="keyword">int</span> walker = <span class="number">0</span>, runner = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(runner &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[runner] &amp; <span class="number">1</span>)</span><br><span class="line">                swap(nums[walker++], nums[runner]);</span><br><span class="line">            ++runner;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <url>/2021/06/24/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-22.-链表中倒数第k个节点"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* runner = head, *walker = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            runner = runner-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(runner)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> walker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <url>/2021/06/25/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="剑指-offer-24.-反转链表"><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 25. 合并两个排序的链表</title>
    <url>/2021/06/18/%E5%89%91%E6%8C%87%20Offer%2025.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="剑指-offer-25.-合并两个排序的链表"><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4>
<h5 id="递归">递归</h5>
<p>参考<a href="https://leetcode.cinte.cc/2021/03/14/21-Merge-Two-Sorted-Lists/">21. Merge Two Sorted Lists</a></p>
<h5 id="迭代">迭代</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* pesudoHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* head = pesudoHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pesudoHead-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pesudoHead-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pesudoHead = pesudoHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pesudoHead-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <url>/2021/06/18/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h4 id="剑指-offer-26.-树的子结构"><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4>
<h5 id="迭代">迭代</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B || !A)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val == B-&gt;val &amp;&amp; helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val != B-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遍历树，碰到A中值和B根相同的点就去递归判断是不是相同子树</p>
<p>情况如下</p>
<ol type="1">
<li>当A为空B非空，则<code>false</code></li>
<li>当B为空A非空，则便利结束，为<code>true</code></li>
<li>当A值!=B值，则<code>false</code></li>
<li>A值==B值，继续判断</li>
</ol>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <url>/2021/06/20/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h4 id="剑指-offer-27.-二叉树的镜像"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        mirrorTree(root-&gt;left);</span><br><span class="line">        mirrorTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="迭代">迭代</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return nullptr;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        while(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            auto p &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            if(p-&gt;left)</span><br><span class="line">                s.push(p-&gt;left);</span><br><span class="line">            if(p-&gt;right)</span><br><span class="line">                s.push(p-&gt;right);</span><br><span class="line">            swap(p-&gt;right, p-&gt;left);</span><br><span class="line">        &#125;        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <url>/2021/06/21/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="剑指-offer-28.-对称的二叉树"><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**</span></span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* node1, TreeNode* node2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node1 &amp;&amp; !node2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node1 || !node2 || node1-&gt;val != node2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(node1-&gt;left, node2-&gt;right) &amp;&amp; helper(node1-&gt;right, node2-&gt;left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="迭代">迭代</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">auto</span> p2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!p1 &amp;&amp; !p2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p1 || !p2 || p1-&gt;val != p2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(p1-&gt;left);</span><br><span class="line">            q.push(p2-&gt;right);</span><br><span class="line">            q.push(p1-&gt;right);</span><br><span class="line">            q.push(p2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <url>/2021/06/23/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="剑指-offer-29.-顺时针打印矩阵"><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/08/54-Spiral-Matrix/">54. Spiral Matrix</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <url>/2021/06/27/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h4 id="剑指-offer-30.-包含min函数的栈"><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4>
<h5 id="section"></h5>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/09/155-Min-Stack/">155. Min Stack</a></p>
<p>自建链表节点，节点中加入min属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() : head(<span class="keyword">new</span> node(<span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> n = <span class="keyword">new</span> node(x, head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>((n-&gt;next &amp;&amp; n-&gt;next-&gt;min &gt; x) || !n-&gt;next)</span><br><span class="line">            n-&gt;min = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n-&gt;min = n-&gt;next-&gt;min;</span><br><span class="line">        head-&gt;next = n;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = head-&gt;next;</span><br><span class="line">            head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next-&gt;min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        node* next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        node() = <span class="keyword">default</span>;</span><br><span class="line">        node(<span class="keyword">int</span> val) : val(val) &#123;&#125;</span><br><span class="line">        node(<span class="keyword">int</span> val, node* next) : val(val), next(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="辅助堆">辅助堆</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || s2.top() &gt;= x)</span><br><span class="line">            s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.top() == s1.top())</span><br><span class="line">            s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 31. 栈的压入、弹出序列</title>
    <url>/2021/06/28/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-31.-栈的压入弹出序列"><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4>
<h5 id="最直观的方式">最直观的方式</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt; popped.size() &amp;&amp; !s.empty() &amp;&amp; popped[j] == s.top())</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : 0(N)</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <url>/2021/07/01/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="剑指-offer-32---i.-从上到下打印二叉树"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <url>/2021/07/02/%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    <content><![CDATA[<h4 id="剑指-offer-32---iii.-从上到下打印二叉树-iii"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4>
<h5 id="双向队列">双向队列</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">false</span>;</span><br><span class="line">        dq.push_front(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = dq.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = dq.back();</span><br><span class="line">                    dq.pop_back();</span><br><span class="line">                    tmp.push_back(p-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                        dq.push_front(p-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                        dq.push_front(p-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = dq.front();</span><br><span class="line">                    dq.pop_front();</span><br><span class="line">                    tmp.push_back(p-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                        dq.push_back(p-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                        dq.push_back(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            left = !left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="省去多余判断">省去多余判断</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">false</span>;</span><br><span class="line">        dq.push_front(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = dq.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = dq.front();</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                tmp2.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    dq.push_back(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    dq.push_back(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp2);</span><br><span class="line">            <span class="keyword">if</span>(dq.empty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = dq.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = dq.back();</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                tmp.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    dq.push_front(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    dq.push_front(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
    <url>/2021/07/02/%E5%89%91%E6%8C%87%20Offer%2033.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-33.-二叉搜索树的后序遍历序列"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4>
<h5 id="dq">D&amp;Q</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verify(postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(nums[p] &lt; nums[j]) ++p;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(nums[p] &gt; nums[j]) ++p;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; (verify(nums, i, m - <span class="number">1</span>) &amp;&amp; verify(nums, m, j - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于一个序列，根在最右边，然后左边的左半边是左子树，右半边是右子树，他们的分界就是左子树全小于根，右子树全大于根，所以只需要通过一个个判断，就可以判断出其中的左子树和右子树，再对子树递归就可以判断了</p>
<h5 id="单调栈倒序">单调栈+倒序</h5>
<p>真的难，还是没想透为什么不管升序要管降序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> parent = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果升序，压栈，倒序，那么这个节点肯定是某个节点的左节点</span></span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; postorder[i] &lt; s.top()) <span class="comment">// 因为栈是递增的，所以找到一个刚刚好大于他本身的节点就是他的父亲节点。</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; parent)  <span class="comment">// 注意这个parent只有在遇到递减数列时候才会赋值，那么有几种情况。1、parent是某个左子节点的父亲，那么他必定大于节点 2、往回走，栈逐渐压入，那么parent成为当前节点所在树的某个祖先节点，并且由后序遍历的顺序，这个树肯定在parent的左边。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/di-gui-he-zhan-liang-chong-fang-shi-jie-jue-zui-ha/">题解</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
    <url>/2021/07/03/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="剑指-offer-34.-二叉树中和为某一值的路径"><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        helper(root, target, <span class="number">0</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span>&amp; target, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cur += root-&gt;val;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur == target &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;right, target, cur, tmp);</span><br><span class="line">        helper(root-&gt;left, target, cur, tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <url>/2021/06/25/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h4 id="剑指-offer-35.-复杂链表的复制"><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/28/138.%20Copy%20List%20with%20Random%20Pointer/">138. Copy List with Random Pointer</a></p>
<h5 id="建立新节点和老节点的映射">建立新节点和老节点的映射</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; <span class="built_in">map</span>;</span><br><span class="line">        Node* pre = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node* pseudoHead = pre;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            <span class="built_in">map</span>[head] = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : <span class="built_in">map</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it.first-&gt;random)</span><br><span class="line">                it.second-&gt;random = <span class="built_in">map</span>[it.first-&gt;random];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                it.second-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pseudoHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>换个写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[cur] = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[cur]-&gt;next = <span class="built_in">map</span>[cur-&gt;next];</span><br><span class="line">            <span class="built_in">map</span>[cur]-&gt;random = <span class="built_in">map</span>[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="拼拆">拼+拆</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">            cur-&gt;next-&gt;next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random)</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">auto</span> newL = head-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> ret = newL;</span><br><span class="line">        <span class="keyword">while</span>(newL-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            newL-&gt;next = newL-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            newL = newL-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <url>/2021/06/28/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="剑指-offer-36.-二叉搜索树与双向链表"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4>
<h5 id="中序遍历顺便产生双向链表记录头">中序遍历顺便产生双向链表，记录头</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            cur-&gt;left = pre;</span><br><span class="line">            <span class="keyword">if</span>(pre)</span><br><span class="line">                pre-&gt;right = cur;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                head = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 37. 序列化二叉树</title>
    <url>/2021/06/29/%E5%89%91%E6%8C%87%20Offer%2037.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="剑指-offer-37.-序列化二叉树"><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = q.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(p)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret += to_string(p-&gt;val);</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret += <span class="string">&quot;n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; data.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">bool</span> pos = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.front() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        pos = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        tmp = tmp * <span class="number">10</span> + s.front() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                ret = <span class="keyword">new</span> TreeNode(pos ? tmp : -tmp);</span><br><span class="line">                q.push(ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                s.push(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; data.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();              </span><br><span class="line">                TreeNode* node = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span>(s.front() == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">                    s.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">bool</span> pos = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(s.front() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                            pos = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tmp = tmp * <span class="number">10</span> + s.front() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        s.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = <span class="keyword">new</span> TreeNode(pos ? tmp : -tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur++ == <span class="number">0</span>)</span><br><span class="line">                    p-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;right = node;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node)</span><br><span class="line">                    q.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                s.push(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <url>/2021/06/29/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-38.-字符串的排列"><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4>
<p>本题的难点是处理中间的重复字符部分。</p>
<h5 id="使用set来记录最终结果粗暴的处理">使用set来记录最终结果，粗暴的处理</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        backTrack(s, <span class="string">&quot;&quot;</span>, ret, path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span> tmp, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == tmp.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(tmp) == <span class="built_in">set</span>.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(tmp);</span><br><span class="line">                ret.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path[i] = <span class="literal">true</span>;</span><br><span class="line">            backTrack(s, tmp + s[i], ret, path);</span><br><span class="line">            path[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="中心思想是对于每一位保证当前位置出现字符串中的每一种字符并且重复的字符只出现一次">中心思想是，对于每一位，保证当前位置出现字符串中的每一种字符并且重复的字符只出现一次</h5>
<p>抄的大佬</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        backTrack(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.size() - <span class="number">1</span>) <span class="comment">// 这里之所以用s.size() - 1而不是s.size()是因为当前面所有位置都固定完了后，最后一位已经板上钉钉了，所以可以直接结束。</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="comment">// 这里i如果从0开始的话，就会导致之前的固定结果被改变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(s[i]) != <span class="built_in">set</span>.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">set</span>.insert(s[i]); <span class="comment">// 防止当前位置上固定重复的字符</span></span><br><span class="line">            swap(s[i], s[index]); <span class="comment">// swap很巧妙，对于第一位来说，意味着后面所有位可以跑到第一位，而同时也意味着第一位可以跑到后面所有位，当index=后面任意一位时，不用担心这一位用不到index之前的，因为前面的已经有机会交换过来了</span></span><br><span class="line">            backTrack(s, index + <span class="number">1</span>);</span><br><span class="line">            swap(s[i], s[index]); <span class="comment">// 恢复回溯操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <url>/2021/06/30/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-39.-数组中出现次数超过一半的数字"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/08/169-Majority-Element/">169. Majority Element</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <url>/2021/06/26/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-40.-最小的k个数"><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4>
<h5 id="用优先队列">用优先队列</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(num);</span><br><span class="line">            <span class="keyword">if</span>(q.size() &gt; k)</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogk)?</p>
<h5 id="排序">排序</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(arr.begin(), arr.begin() + k)</span></span>; <span class="comment">// 可以避免空间多次分配带来的开销</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这里不用排所有，只需要排k个数 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>, k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            ret.push_back(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> c = nums[begin];</span><br><span class="line">        <span class="keyword">auto</span> i = begin, j = end + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; end &amp;&amp; nums[++i] &lt; c) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; begin &amp;&amp; nums[--j] &gt; c) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)  <span class="comment">// 这里关键，这个条件过后要防止交换了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[j], nums[begin]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = partition(arr, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(j == k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; k)</span><br><span class="line">            quickSort(arr, begin, j - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            quickSort(arr, j + <span class="number">1</span>, end, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 41. 数据流中的中位数</title>
    <url>/2021/06/27/%E5%89%91%E6%8C%87%20Offer%2041.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-41.-数据流中的中位数"><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof//">剑指 Offer 41. 数据流中的中位数</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/05/04/295.%20Find%20Median%20from%20Data%20Stream/">295. Find Median from Data Stream</a></p>
<h5 id="两个优先级队列">两个优先级队列</h5>
<p>有点忘了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.size() == q2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(num);</span><br><span class="line">            q2.push(q1.top());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(num);</span><br><span class="line">            q1.push(q2.top());</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.size() != q2.size())</span><br><span class="line">            <span class="keyword">return</span> q2.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (q1.top() + q2.top()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; q1;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <url>/2021/06/27/%E5%89%91%E6%8C%87%20Offer%2042.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h4 id="剑指-offer-42.-连续子数组的最大和"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/03/26/53-Maximum-Subarray/">53. Maximum Subarray</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 43. 1～n 整数中 1 出现的次数</title>
    <url>/2021/06/30/%E5%89%91%E6%8C%87%20Offer%2043.%201%EF%BD%9En%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-43.-1n-整数中-1-出现的次数"><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4>
<h5 id="brute-force">brute force</h5>
<p>但是超时了 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">while</span>(tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                ret += (tmp % <span class="number">10</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                tmp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### 用dp超内存了</p>
<h5 id="数学方法">数学方法</h5>
<p>（企及不到的境界）（又称为数位dp)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        int high &#x3D; n &#x2F; 10, cur &#x3D; n % 10, low &#x3D; 0;</span><br><span class="line">        long digit &#x3D; 1;</span><br><span class="line">        while(high || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur &#x3D;&#x3D; 0)</span><br><span class="line">                ret +&#x3D; high * digit;</span><br><span class="line">            else if(cur &#x3D;&#x3D; 1)</span><br><span class="line">                ret +&#x3D; high * digit + 1 + low;</span><br><span class="line">            else</span><br><span class="line">                ret +&#x3D; (high + 1) * digit;</span><br><span class="line">            low +&#x3D; cur * digit;</span><br><span class="line">            cur &#x3D; high % 10;</span><br><span class="line">            high &#x2F;&#x3D; 10;</span><br><span class="line">            digit *&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所求的是每一位1出现的次数，所有位加起来那就是总和了。</p>
<p>将当前位想象成密码锁</p>
<ol type="1">
<li>当前位为0，那么将这一位固定为1后，掰动其他位所能生成的组合的数量将会是<code>高位*数位</code>，例如，<code>2402</code>中的第三位为0，将这一位固定为1后，由于生成的数必须小于<code>2402</code>，所以上限将等于<code>2319</code>，可以发现高位是减了1的，则总数就是<code>0010~2319</code>，其他数有<code>000~239</code>种变化。</li>
<li>当前位为1，那么这一位固定为1后，可以为所欲为，例如，<code>2412</code>，对于第三位范围就是<code>0000~2412</code>范围就是<code>000~242</code>，也就是<code>高位*数位+低位+1</code></li>
<li>当前位为其他，那么把这一位固定为1后，范围就是这一位被压制为1后的值，例如<code>2432</code>，其范围就是<code>0000~2419</code>，最后范围就是<code>000~249</code>，也就是<code>(高位+1) * 数位</code>。</li>
</ol>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 44. 数字序列中某一位的数字</title>
    <url>/2021/07/02/%E5%89%91%E6%8C%87%20Offer%2044.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-44.-数字序列中某一位的数字"><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4>
<h5 id="又是一道数学的找规律类型的题好烦">又是一道数学的找规律类型的题，好烦</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>, count = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            ++digit;</span><br><span class="line">            count = <span class="number">9</span> * digit * start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = (n - <span class="number">1</span>) / digit + start;</span><br><span class="line">        <span class="keyword">return</span> to_string(num)[(n - <span class="number">1</span>) % digit] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.cinte.cc/2021/07/02/e8c38b67f4a9f.png" alt="1625218647824.png" /> <img src="https://image.cinte.cc/2021/07/02/8e35c23ecca2e.png" alt="1625218657922.png" /> <img src="https://image.cinte.cc/2021/07/02/bb1f38fce087f.png" alt="1625218664563.png" /></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-45.-把数组排成最小的数"><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4>
<h5 id="我可太太太太太菜了">我可太太太太太菜了</h5>
<p>本质上转换为一个排序问题，对于两个数字a1,b1。当<code>str(a1) + str(b1) &lt; str(b1) + str(a1)</code>时，表示a1因当刚在b1左边，反之则表示a1应当放在b1右边。以此为判断条件对数组进行排序，排序后重新组合成字符串就是所需</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            ret += to_string(num);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> c = to_string(nums[lo]);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; to_string(nums[++i]) + c &lt; c + to_string(nums[i])) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; lo &amp;&amp; to_string(nums[--j]) + c &gt; c + to_string(nums[j])) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[j], nums[lo]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = partition(nums, lo, hi);</span><br><span class="line">        sort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>v2 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            strs.push_back(to_string(num));</span><br><span class="line">        sort(strs, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : strs)</span><br><span class="line">            ret += str;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> c = nums[lo];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; hi &amp;&amp; nums[++i] + c &lt; c + nums[i]) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; lo &amp;&amp; nums[--j] + c &gt; c + nums[j]) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[j], nums[lo]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = partition(nums, lo, hi);</span><br><span class="line">        sort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> v3 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            strs.push_back(to_string(num));</span><br><span class="line">        sort(strs.begin(), strs.end(), [](<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span> str2)&#123; <span class="keyword">return</span> str1 + str2 &lt; str2 + str1; &#125;);</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : strs)</span><br><span class="line">            ret.append(str);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="剑指-offer-46.-把数字翻译成字符串"><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> strs = to_string(num);</span><br><span class="line">        backTrack(strs, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span>&amp; nums, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt;= nums.size() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(nums, cur + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> sum = (nums[cur] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + nums[cur + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[cur] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; sum &lt; <span class="number">26</span> &amp;&amp; sum &gt; <span class="number">0</span>)</span><br><span class="line">            backTrack(nums, cur + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dp">dp</h5>
<p>version.1 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(num);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(str.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> num = (str[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt; <span class="number">26</span>)</span><br><span class="line">                dp[i] += (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> version.2</p>
<p>优化dp的空间，但字符串还是占O(n) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> num = (str[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            a = (num &gt;= <span class="number">10</span> &amp;&amp; num &lt; <span class="number">26</span>) ? a + b : b;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> version.3</p>
<p>直接使用取余计算数位 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lastNum = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> curNum = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> sum = curNum * <span class="number">10</span> + lastNum;</span><br><span class="line">            a = (sum &gt;= <span class="number">10</span> &amp;&amp; sum &lt; <span class="number">26</span>) ? a + b : b;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            lastNum = curNum;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <url>/2021/07/07/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="剑指-offer-47.-礼物的最大价值"><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4>
<p>最简单的dp</p>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size(); ++i)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid[<span class="number">0</span>].size(); ++i)</span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                grid[i][j] += max(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">return</span> grid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2048.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="剑指-offer-48.-最长不含重复字符的子字符串"><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4>
<h5 id="滑动窗口">滑动窗口</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(s[end]) == <span class="built_in">set</span>.end())</span><br><span class="line">                <span class="built_in">set</span>.insert(s[end]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(s[begin] != s[end])</span><br><span class="line">                    <span class="built_in">set</span>.erase(s[begin++]);</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;          </span><br><span class="line">            ret = max(ret, end - begin + <span class="number">1</span>);</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="动态规划">动态规划</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[i]) != <span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[s[i]] &gt;= i - now)</span><br><span class="line">                now = i - <span class="built_in">map</span>[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                now = now + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>[s[i]] = i;</span><br><span class="line">            ret = max(now, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 49. 丑数</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2049.%20%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-49.-丑数"><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/05/17/264.%20Ugly%20Number%20II/">264. Ugly Number II</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <url>/2021/07/03/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="剑指-offer-50.-第一个只出现一次的字符"><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h4>
<h5 id="遍历两次">遍历两次</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memo[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            memo[ch - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            <span class="keyword">if</span>(memo[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="用vector记录插入的数据在有大量重复的情况下会笔第一种快">用vector记录插入的数据，在有大量重复的情况下会笔第一种快</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memo[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!memo[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                v.push_back(ch);</span><br><span class="line">            memo[ch - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : v)</span><br><span class="line">            <span class="keyword">if</span>(memo[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <url>/2021/07/03/%E5%89%91%E6%8C%87%20Offer%2051.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-51.-数组中的逆序对"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4>
<h5 id="用归并排序顺便计算逆序对tnl">用归并排序，顺便计算逆序对（tnl)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        merge(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 从中间截开来，划分</span></span><br><span class="line">        merge(nums, l, m); <span class="comment">// 递归排序左半边归并，排完后是从小到大的顺序</span></span><br><span class="line">        merge(nums, m + <span class="number">1</span>, r); <span class="comment">// 递归排序右半边归并，排完后是从小到大的顺序</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.begin() + l, nums.begin() + r + <span class="number">1</span>)</span></span>; <span class="comment">// 生成一个临时字符串，将排序区间内的内容复制进去</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m + <span class="number">1</span> - l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m + <span class="number">1</span> - l) <span class="comment">// 当i，也就是左半边的指针超过了中位数后，也就是说左半边元素用完了。那么把剩下的元素全都用右半边剩下的元素填充</span></span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == r + <span class="number">1</span> - l) <span class="comment">// 当右半边元素用完后，把剩下的空位全都用右半边元素填充</span></span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] &lt;= tmp[j]) <span class="comment">// 进行大小盘带按，填充较小的元素</span></span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[k] = tmp[j++]; <span class="comment">// 填充较大的元素</span></span><br><span class="line">                ret += m - i + <span class="number">1</span> - l; <span class="comment">// 当左边某个数&gt;右边某个数时，由于左边序列是从小到大排列，那么左边从这个数到结尾的所有数与右边那个数都构成了逆序对，依次遍历。将所有逆序对加上。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <url>/2021/07/06/%E5%89%91%E6%8C%87%20Offer%2052.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-52.-两个链表的第一个公共节点"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/12/160-Intersection-of-Two-Linked-Lists/">160. Intersection of Two Linked Lists</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <url>/2021/07/07/%E5%89%91%E6%8C%87%20Offer%2053%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/</url>
    <content><![CDATA[<h4 id="剑指-offer-53---i.-在排序数组中查找数字-i"><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/03/14/34.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/">34. Find First and Last Position of Element in Sorted Array</a></p>
<h5 id="直接遍历">直接遍历</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            ret += num == target ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n)</p>
<h5 id="二分">二分</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size(), mid;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ret;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i--] == target)</span><br><span class="line">            ++ret;</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= nums.size() - <span class="number">1</span> &amp;&amp; nums[i++] == target)</span><br><span class="line">            ++ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = hi; <span class="comment">// 最后保留一个等于目标的左边界</span></span><br><span class="line">        <span class="keyword">if</span>(nums[lo] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((lo + hi) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 偏向右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                lo = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保留一个等于左边的左边界</span></span><br><span class="line">        <span class="keyword">return</span> lo - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> v.2 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当他们相等时候，进入会出现hi在lo的前面一位，即hi是左边界而lo是左边界右边一个，hi!=target而lo==target</span></span><br><span class="line">        <span class="keyword">int</span> left = hi;</span><br><span class="line">        <span class="keyword">if</span>(lo &lt;= nums.size() - <span class="number">1</span> &amp;&amp; nums[lo] != target) <span class="comment">// lo如果不等于的话，那就直接跳出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后是lo == target 而 hi不等于，hi在lo后面一位</span></span><br><span class="line">        <span class="keyword">return</span> lo - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-53---ii.-0n-1中缺失的数字"><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4>
<h5 id="遍历">遍历</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>排序数组中的搜索问题，首先想到 二分法 解决。</p>
<h5 id="二分">二分</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] != mid)</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="剑指-offer-54.-二叉搜索树的第k大节点"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4>
<h5 id="左右反着来中序">左右反着来中序</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(--k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 55 - I. 二叉树的深度</title>
    <url>/2021/07/04/%E5%89%91%E6%8C%87%20Offer%2055%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="剑指-offer-55---i.-二叉树的深度"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/09/104-Maximum-Depth-of-Binary-Tree/">104. Maximum Depth of Binary Tree</a></p>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 55 - II. 平衡二叉树</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2055%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="剑指-offer-55---ii.-平衡二叉树"><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4>
<h5 id="dfs">dfs</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(dfs(root-&gt;left), dfs(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="剪枝">剪枝</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
    <url>/2021/07/04/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-56---i.-数组中数字出现的次数"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对于只有一个只出现一次的数字的情况，异或后结果就是那个值，而有两个的话，假设2个数字是x,y，则异或后结果为x^y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            n ^= num;</span><br><span class="line">        <span class="comment">// 设m为1，寻找x与y从左往右数不相同的第一个数字，异或中是相异为1，所以当m&amp;n==1时，表示n的这位为1了，于是就找到了这个不相同的第一个数字，并保存到m</span></span><br><span class="line">        <span class="keyword">while</span>((m &amp; n) == <span class="number">0</span>) <span class="comment">// 注意 == 的优先级比 &amp; 高</span></span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; m) == <span class="number">0</span>) <span class="comment">// 当且仅当m为1的这一位的数字为1时，与的结果才为1，因此那两个单独的数字必定不可能同时通过这个if条件，所以将原数列分成了两个子序列</span></span><br><span class="line">                x ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;x, x ^ n&#125;; <span class="comment">// x ^ n = x ^ x ^ y = 0 ^ y = y</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化技巧 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((m &amp; n) == <span class="number">0</span>)</span><br><span class="line">    m &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure> 可以优化为 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m = n &amp; (~n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure> <code>~n</code>将n的所有位取反，<code>~n + 1</code>则可以将<code>~n</code>的最低一个0变1，也就是把<code>n</code>的最低一个1标记出来，而其他的位<code>~n</code>保持与<code>n</code>相反，因此他们<code>与</code>之后的结果就是最低位的1保留，剩下全是0。</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
    <url>/2021/07/04/%E5%89%91%E6%8C%87%20Offer%2056%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/</url>
    <content><![CDATA[<h4 id="剑指-offer-56---ii.-数组中数字出现的次数-ii"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4>
<h5 id="hashmap">hashmap</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">            <span class="built_in">map</span>[num] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : <span class="built_in">map</span>)</span><br><span class="line">            <span class="keyword">if</span>(it.second == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> it.first;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
<h5 id="位运算">位运算</h5>
<p>因为其他数都出现三次，只有一个数出现一次，所以将所有数的每一位加起来后对3取余剩下的就是那个只出现一次的数字</p>
<p>对于每一位构建状态转换图，有三个状态0,1,2 <img src="https://image.cinte.cc/2021/07/05/78efdf2acd2da.png" alt="1625471528006.png" /> 其中三个状态为0,1,2表示除以3后的余数</p>
<p>求出来后的结果必然是00或01两个状态，因为所有出现三次的数都加完了取余完了，所以只剩下了这2种情况表示那个只出现一次的数的位为0或1，所以最后只需要返回one即可</p>
<p>对于每一位都是相同的方法，所以可以直接放到一起来用位运算</p>
<h6 id="根据状态转换图构建卡诺图化简">根据状态转换图，构建卡诺图，化简</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = one;</span><br><span class="line">            one = (one &amp; ~num) | (~two &amp; ~one &amp; num);</span><br><span class="line">            two = (two &amp; ~num) | (tmp &amp; num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="根据图观察获得">根据图观察获得</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            one = ~two &amp; (one ^ num);</span><br><span class="line">            two = ~one &amp; (two ^ num); <span class="comment">// 注意此处的两个运算并不是同时进行的，所以这里的two需要根据变化后的one的结果来运算。根据计算后的one的结果，见下图（还是卡诺图来的直观）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/07/05/b4ff9493e0303.png" alt="1625471719640.png" /><figcaption aria-hidden="true">1625471719640.png</figcaption>
</figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(1)</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-57---ii.-和为s的连续正数序列"><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4>
<h5 id="暴力">暴力</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target &gt;&gt; <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = i;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; target; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(j);</span><br><span class="line">                sum += j;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum == target)</span><br><span class="line">                    ret.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2)</p>
<h5 id="sliding-window">sliding window</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>, end = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; (target &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sum += end;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">                        tmp.push_back(i);</span><br><span class="line">                    ret.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= begin;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 57. 和为s的两个数字</title>
    <url>/2021/07/05/%E5%89%91%E6%8C%87%20Offer%2057.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-57.-和为s的两个数字"><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h4>
<h5 id="借助two-sum的思路">借助two sum的思路</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(target - num) != <span class="built_in">set</span>.end())</span><br><span class="line">                <span class="keyword">return</span> &#123;num, target - num&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">set</span>.insert(num);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
<h5 id="利用好递增顺序双指针">利用好递增顺序，双指针</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[lo] + nums[hi] &gt; target)</span><br><span class="line">                --hi;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; target)</span><br><span class="line">                ++lo;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> &#123;nums[lo], nums[hi]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提醒一下，判断条件最好不要用相加后的结果，应该用target - nums[i] 跟 nums[j]比较，这样保证不会溢出。虽然这题中不会出错。同样的例子还有二分查找，(left + right) &#x2F; 2 可以用left + ((rigth - left) &gt;&gt; 1))代替</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 58 - I. 翻转单词顺序</title>
    <url>/2021/07/07/%E5%89%91%E6%8C%87%20Offer%2058%20-%20I.%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="剑指-offer-58---i.-翻转单词顺序"><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/submissions/">剑指 Offer 58 - I. 翻转单词顺序</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; s[end] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            --end;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end; i &gt;= <span class="number">-1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">-1</span> || s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.append(s.substr(i + <span class="number">1</span>, end - i));</span><br><span class="line">                <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    --i;</span><br><span class="line">                end = i;</span><br><span class="line">                <span class="keyword">if</span>(end &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ret.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 58 - II. 左旋转字符串</title>
    <url>/2021/07/07/%E5%89%91%E6%8C%87%20Offer%2058%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="剑指-offer-58---ii.-左旋转字符串"><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4>
<p>和<a href="https://leetcode.cinte.cc/2021/07/01/189.%20Rotate%20Array/">189. Rotate Array</a>一样</p>
<h5 id="转转转">转转转</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.size() - n - <span class="number">1</span>);</span><br><span class="line">        reverse(s, s.size() - n, s.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">            swap(s[start++], s[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2059%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="剑指-offer-59---i.-滑动窗口的最大值"><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/submissions/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/05/06/239.%20Sliding%20Window%20Maximum/">239. Sliding Window Maximum</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <url>/2021/07/09/%E5%89%91%E6%8C%87%20Offer%2059%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="剑指-offer-59---ii.-队列的最大值"><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4>
<h5 id="维护一个辅助队列">维护一个辅助队列</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!helper.empty() &amp;&amp; value &gt; helper.back())</span><br><span class="line">            helper.pop_back();</span><br><span class="line">        helper.push_back(value);</span><br><span class="line">        nodes.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(helper.front() == nodes.front())</span><br><span class="line">            helper.pop_front();</span><br><span class="line">        <span class="keyword">auto</span> ret = nodes.front();</span><br><span class="line">        nodes.pop_front();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nodes; <span class="comment">// 其实这个直接用queue也行</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; helper;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 60. n个骰子的点数</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2060.%20n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-60.-n个骰子的点数"><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4>
<h5 id="dp真的妙">dp(真的妙)</h5>
<p>对于n个骰子来说，他们值的和最小值是所有骰子都是1，最大值是所有骰子都是6，所以他们和的范围是<code>[n, 6n]</code>，所以总共有<code>6n - n + ! = 5n + 1</code>种情况。</p>
<p>对于n个骰子的值x来说，设n-1个骰子值x的概率是<code>f(n - 1, x)</code>，则<code>f(n, x) = f(n - 1, x - 1) * 1 / 6 + f(n - 1, x - 2) * 1 / 6 ... f(n - 1, x - 6) * 1 / 6</code>，这个式子表示当第n个骰子取值为y时，概率就是前n个骰子取值为<code>x - y</code>乘上当前骰子取y的概率，这样子就形成了递推公式。</p>
<p>但是<code>x - y</code>会产生越界问题，由此转变思想，当n-1个骰子取值为x时，n个骰子的取值只能是<code>x+1 ~ x+6</code>。由此不用考虑越界。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">6</span>, <span class="number">1</span> / <span class="number">6.0</span>)</span></span>; <span class="comment">// 初始化一个骰子的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="comment">// 从第二个骰子开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// i个骰子可能的情况共有5n+1种</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pre.size(); ++j) <span class="comment">// 对i-1个骰子情况中可能的取值进行遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k) <span class="comment">// 对i-1个骰子可能的取值加上1到6，就是i个骰子情况，由于前面取值加上1到6可能会有重复情况，而把这些重复情况概率加起来就是最终概率。</span></span><br><span class="line">                    tmp[k + j] += pre[j] * <span class="number">1</span> / <span class="number">6.0</span>;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2061.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h4 id="剑指-offer-61.-扑克牌中的顺子"><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4>
<h5 id="section"></h5>
<p>两个条件</p>
<ol type="1">
<li><p>最大值减去最小值&lt;5</p></li>
<li><p>没有重复的数字</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ma = <span class="number">0</span>, mi = <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.emplace(num).second)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ma = max(ma, num);</span><br><span class="line">            mi = min(mi, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma - mi &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[nz] == <span class="number">0</span>)</span><br><span class="line">            ++nz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nz + <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.back() - nums[nz] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2062.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="剑指-offer-62.-圆圈中最后剩下的数字"><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫环</a></p>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = (pre + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://image.cinte.cc/2021/07/12/dcd4cf4ae07a7.jpg" alt="Screenshot_20210712-115540_Samsung Notes.jpg" /><figcaption aria-hidden="true">Screenshot_20210712-115540_Samsung Notes.jpg</figcaption>
</figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2063.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h4 id="剑指-offer-63.-股票的最大利润"><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/03/19/121-Best-Time-to-Buy-and-Sell-Stock/">121. Best Time to Buy and Sell Stock</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 64. 求1+2+…+n</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2064.%20%E6%B1%821+2+%E2%80%A6+n/</url>
    <content><![CDATA[<h4 id="剑指-offer-64.-求12n"><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4>
<h5 id="shuai">shuai</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> x = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>); <span class="comment">// n == 1时候终止递归，递归栈返回，从ret从n=1开始加上去。 此处使用逻辑符短路，代替了原本if(n &lt;= 1) return 1;</span></span><br><span class="line">        ret += n;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没题目限制使用递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        n += sumNums(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法</title>
    <url>/2021/07/08/%E5%89%91%E6%8C%87%20Offer%2065.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h4 id="剑指-offer-65.-不用加减乘除做加法"><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/submissions/">剑指 Offer 65. 不用加减乘除做加法</a></h4>
<h5 id="位运算">位运算</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            c = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">// leetcode的编译环境问题导致这里负数左移会报错，g++中则测试正常c = (a &amp; b) &lt;&lt; 1</span></span><br><span class="line">            a ^= b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于使用的是补码可以统一负数和正数运算，所以不用考虑正负数。</p>
<p>考察位运算，首先可以知道对于加法器，如果不考虑进位，那么值就是<code>a ^ b</code>，而进位为<code>a &amp; b</code>。则将不考虑进位算出来的值加上进位最终就是考虑进位的值，由于当前计算结果的进位是用于下一位的，所以需要将计算所得的进位左移一位，再次加，获得新的进位，知道进位为0，停止计算。</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 66. 构建乘积数组</title>
    <url>/2021/07/10/%E5%89%91%E6%8C%87%20Offer%2066.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="剑指-offer-66.-构建乘积数组"><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/07/07/238.%20Product%20of%20Array%20Except%20Self/">238. Product of Array Except Self</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 67. 把字符串转换成整数</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2067.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h4 id="剑指-offer-67.-把字符串转换成整数"><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[start] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++start;</span><br><span class="line">        <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[start] == <span class="string">&#x27;+&#x27;</span> || str[start] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            positive = str[start++] == <span class="string">&#x27;+&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; str.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(isValid(str[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(positive)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ret &gt; INT_MAX / <span class="number">10</span> || (ret == INT_MAX / <span class="number">10</span> &amp;&amp; num &gt;= INT_MAX % <span class="number">10</span>))</span><br><span class="line">                        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(-ret &lt; INT_MIN / <span class="number">10</span> || (-ret == INT_MIN / <span class="number">10</span> &amp;&amp; -num &lt;= INT_MIN % <span class="number">10</span>))</span><br><span class="line">                        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = ret * <span class="number">10</span> + num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> positive ? ret : -ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稍微优化一下 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[start] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++start;</span><br><span class="line">        <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[start] == <span class="string">&#x27;+&#x27;</span> || str[start] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            positive = str[start++] == <span class="string">&#x27;+&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; str.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(isValid(str[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ret &gt; <span class="number">214748364</span> || (ret == <span class="number">214748364</span> &amp;&amp; num &gt; <span class="number">7</span>)) <span class="comment">// 即使当num == 8时,如果是负数，虽然没越界，但是假设他越界了，依旧可以返回正确的值</span></span><br><span class="line">                    <span class="keyword">return</span> positive ? INT_MAX : INT_MIN;</span><br><span class="line">                ret = ret * <span class="number">10</span> + num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> positive ? ret : -ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2068%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h4 id="剑指-offer-68---i.-二叉搜索树的最近公共祖先"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/22/236-Lowest-Common-Ancestor-of-a-Binary-Tree/">236. Lowest Common Ancestor of a Binary Tree</a></p>
<p>但因为这题是BST，所以有别的方法</p>
<p>以下情况:</p>
<ol type="1">
<li>当p，q都在root左侧，那么p，q都在root左子树。</li>
<li>当p，q都在root右侧，那么p，q都在root右子树。</li>
<li>当第一次产生没在同一个子树时，这时候的root就是解
<ol type="1">
<li>p或q为root，剩下的在一边的树</li>
<li>p，q在root两侧</li>
</ol></li>
</ol>
<h5 id="迭代">迭代</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
    <url>/2021/07/11/%E5%89%91%E6%8C%87%20Offer%2068%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h4 id="剑指-offer-68---ii.-二叉树的最近公共祖先"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/04/22/236-Lowest-Common-Ancestor-of-a-Binary-Tree/">236. Lowest Common Ancestor of a Binary Tree</a></p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 01.01. 判定字符是否唯一</title>
    <url>/2021/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.01.%20%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</url>
    <content><![CDATA[<h4 id="面试题-01.01.-判定字符是否唯一"><a href="https://leetcode-cn.com/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4>
<h5 id="排序">排序</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(<span class="built_in">string</span> astr)</span> </span>&#123;</span><br><span class="line">        sort(astr.begin(), astr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; astr.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(astr[i] == astr[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="位运算">位运算</h5>
<p>由题意，可能这个字符串所有字母是a~z之间，本来想到用一个26大小的数组来记录。但是<strong>可以通过一个26位的二进制中的每个位是否为1来表示这个位对应的字母是否出现过</strong>，由此就可以呃不用其他的数据结构 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(<span class="built_in">string</span> astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : astr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(a &amp; (<span class="number">1</span> &lt;&lt; i)) <span class="comment">// 如果a这个位为1，那么结果为1，表示重复了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a |= <span class="number">1</span> &lt;&lt; i; <span class="comment">// 记录这个位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.02. 判定是否互为字符重排</title>
    <url>/2021/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.02.%20%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<h4 id="面试题-01.02.-判定是否互为字符重排"><a href="https://leetcode-cn.com/problems/check-permutation-lcci/">面试题 01.02. 判定是否互为字符重排</a></h4>
<h5 id="次遍历o3n">3次遍历O(3n)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckPermutation</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">26</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s1)</span><br><span class="line">            a[ch - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s2)</span><br><span class="line">            a[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 01.03. URL化</title>
    <url>/2021/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.03.%20URL%E5%8C%96/</url>
    <content><![CDATA[<h4 id="面试题-01.03.-url化"><a href="https://leetcode-cn.com/problems/string-to-url-lcci/">面试题 01.03. URL化</a></h4>
<h5 id="section"></h5>
<p>类似<a href="https://leetcode.cinte.cc/2021/06/17/剑指%20Offer%2005.%20替换空格/">剑指 Offer 05. 替换空格</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpaces</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            spaceNum += (S[i] == <span class="string">&#x27; &#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> realSize = length + <span class="number">2</span> * spaceNum;</span><br><span class="line">        S.resize(realSize); <span class="comment">// 有时候这个字符串会给出额外的空余空间，需要根据实际大小resize一下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>, j = realSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i, --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                S[j] = S[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                S[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                S[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 01.04. 回文排列</title>
    <url>/2021/07/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.04.%20%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="面试题-01.04.-回文排列"><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">面试题 01.04. 回文排列</a></h4>
<h5 id="hashmap">##### hashmap</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            ++memo[ch];</span><br><span class="line">        <span class="keyword">bool</span> isD = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : memo)</span><br><span class="line">            <span class="keyword">if</span>(it.second &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(isD)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    isD = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种思路，用count计算奇数个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(++memo[ch] &amp; <span class="number">1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以用2个64位长度的long来作为数组来记录。</p>
<h5 id="set">set</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.emplace(ch).second)</span><br><span class="line">                <span class="built_in">set</span>.erase(ch);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>.size() &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="计数">计数</h5>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 01.06. 字符串压缩</title>
    <url>/2021/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.06.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h4 id="面试题-01.06.-字符串压缩"><a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">compressString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> curVal = S.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] != curVal)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.append(curVal + to_string(curNum));</span><br><span class="line">                curVal = S[i];</span><br><span class="line">                curNum = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++curNum;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.append(curVal + to_string(curNum));</span><br><span class="line">        <span class="keyword">return</span> ret.size() &gt;= S.size() ? S : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 01.09. 字符串轮转</title>
    <url>/2021/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.09.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</url>
    <content><![CDATA[<h4 id="面试题-01.09.-字符串轮转"><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></h4>
<h5 id="题解中的大佬">题解中的大佬</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFlipedString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size() == s2.size() &amp;&amp; (s1 + s1).find(s2) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把旋转字符串前半部分补充成旋转前的，后半部分也补充成旋转前的。最后就变成了两个旋转前的拼起来，而旋转后的必然存在与其中。find表示未找到s2子串就返回-1。</p>
<h5 id="普通正常方法模拟">普通正常方法(模拟)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFlipedString</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.empty())</span><br><span class="line">            <span class="keyword">return</span> s2.empty();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2[i] == s1[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; s1.size() &amp;&amp; s2[j % s2.size()] == s1[k]) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k == s1.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 02.01. 移除重复节点</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="面试题-02.01.-移除重复节点"><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></h4>
<h5 id="借助set">借助set</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pseudoHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* ret = pseudoHead;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.emplace(head-&gt;val).second)</span><br><span class="line">            &#123;</span><br><span class="line">                pseudoHead-&gt;next = head;</span><br><span class="line">                pseudoHead = pseudoHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pseudoHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
<h5 id="不用set遍历好多次">不用set(遍历好多次)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> point = head;</span><br><span class="line">        <span class="keyword">while</span>(point)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = point;</span><br><span class="line">            <span class="keyword">auto</span> cur = point-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val == point-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre-&gt;next = cur-&gt;next;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre = pre-&gt;next;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            point = point-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n^2)</p>
<p>S(n) : O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 02.03. 删除中间节点</title>
    <url>/2021/07/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.03.%20%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="面试题-02.03.-删除中间节点"><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">面试题 02.03. 删除中间节点</a></h4>
<h5 id="把自己变成下一节点然后删掉下一节点">把自己变成下一节点，然后删掉下一节点</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> next = node-&gt;next;</span><br><span class="line">        node-&gt;val = next-&gt;val;</span><br><span class="line">        node-&gt;next = next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 02.05. 链表求和</title>
    <url>/2021/07/27/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.05.%20%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h4 id="面试题-02.05.-链表求和"><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">面试题 02.05. 链表求和</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode* ret = l1;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val += l2-&gt;val + c;</span><br><span class="line">            c = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">            l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            l1 = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val += c;</span><br><span class="line">                c = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                pre = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以新建个链表直接递归</p>
<p>不想写</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 02.06. 回文链表</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.06.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="面试题-02.06.-回文链表"><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/">面试题 02.06. 回文链表</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *walker = head, *runner = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> next = walker-&gt;next;</span><br><span class="line">            walker-&gt;next = pre;</span><br><span class="line">            pre = walker;</span><br><span class="line">            walker = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(runner)</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pre &amp;&amp; walker &amp;&amp; pre-&gt;val == walker-&gt;val) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !(pre || walker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 03.01. 三合一</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2003.01.%20%E4%B8%89%E5%90%88%E4%B8%80/</url>
    <content><![CDATA[<h4 id="面试题-03.01.-三合一"><a href="https://leetcode-cn.com/problems/three-in-one-lcci/">面试题 03.01. 三合一</a></h4>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TripleInOne(<span class="keyword">int</span> stackSize) : stacks(<span class="keyword">new</span> <span class="keyword">int</span>[stackSize * <span class="number">3</span> + <span class="number">3</span>]), top1(<span class="number">0</span>), top2(stackSize + <span class="number">1</span>), top3((stackSize &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>), stackSize(stackSize) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(stackNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">if</span>(top1 == stackSize)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                stacks[++top1] = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(top2 == (stackSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                stacks[++top2] = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(top3 == stackSize * <span class="number">3</span> + <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                stacks[++top3] = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty(stackNum))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(stackNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> stacks[top1--];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> stacks[top2--];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> stacks[top3--];</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty(stackNum))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(stackNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> stacks[top1];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> stacks[top2];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> stacks[top3];</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(stackNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> top1 == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> top2 == stackSize + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> top3 == (stackSize &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* stacks;</span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">    <span class="keyword">int</span> top2;</span><br><span class="line">    <span class="keyword">int</span> top3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TripleInOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TripleInOne* obj = new TripleInOne(stackSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(stackNum,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop(stackNum);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek(stackNum);</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;isEmpty(stackNum);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 03.03. 堆盘子</title>
    <url>/2021/07/27/%E9%9D%A2%E8%AF%95%E9%A2%98%2003.03.%20%E5%A0%86%E7%9B%98%E5%AD%90/</url>
    <content><![CDATA[<h4 id="面试题-03.03.-堆盘子"><a href="https://leetcode-cn.com/problems/stack-of-plates-lcci/">面试题 03.03. 堆盘子</a></h4>
<h5 id="双向链表">双向链表</h5>
<p>用双向链表来维护堆栈之间的顺序，用cur指针来指向当前的堆栈。每次通过顺序遍历来获取到第index个栈。通过删除节点来作为删除栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackOfPlates(<span class="keyword">int</span> cap) : head(<span class="keyword">new</span> Node()), tail(<span class="keyword">new</span> Node()), cap(cap)&#123;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        cur = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(isFull(cur))</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> Node(cur, cur-&gt;next);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;s.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = cur-&gt;s.top();</span><br><span class="line">        cur-&gt;s.pop();</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = cur;</span><br><span class="line">            cur = cur-&gt;prev;</span><br><span class="line">            deleteNode(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(index)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node* tmp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp == tail)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ret = tmp-&gt;s.top();</span><br><span class="line">        tmp-&gt;s.pop();</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == tmp)</span><br><span class="line">                cur = tmp-&gt;prev;</span><br><span class="line">            deleteNode(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(Node* prev, Node* next) : prev(prev), next(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    Node *cur;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;s.size() == cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StackOfPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StackOfPlates* obj = new StackOfPlates(cap);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAt(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="使用vector来存储stack">使用vector来存储stack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackOfPlates(<span class="keyword">int</span> cap) : cap(cap) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(stacks.empty() || stacks.back().size() == cap)</span><br><span class="line">            stacks.push_back(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        stacks.back().push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// o(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stacks.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = stacks.back().top();</span><br><span class="line">        stacks.back().pop();</span><br><span class="line">        <span class="keyword">if</span>(stacks.back().empty())</span><br><span class="line">            stacks.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// o(1), 最坏情况o(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= stacks.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = stacks[index].top();</span><br><span class="line">        stacks[index].pop();</span><br><span class="line">        <span class="keyword">if</span>(stacks[index].empty())</span><br><span class="line">            stacks.erase(stacks.begin() + index);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StackOfPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StackOfPlates* obj = new StackOfPlates(cap);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAt(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 03.05. 栈排序</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2003.05.%20%E6%A0%88%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="面试题-03.05.-栈排序"><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/">面试题 03.05. 栈排序</a></h4>
<p>用一个栈+临时栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SortedStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(val);</span><br><span class="line">        <span class="keyword">while</span>(!tmp.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(tmp.top());</span><br><span class="line">            tmp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SortedStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SortedStack* obj = new SortedStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 03.06. 动物收容所</title>
    <url>/2021/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98%2003.06.%20%E5%8A%A8%E7%89%A9%E6%94%B6%E5%AE%B9%E6%89%80/</url>
    <content><![CDATA[<h4 id="面试题-03.06.-动物收容所"><a href="https://leetcode-cn.com/problems/animal-shelter-lcci/">面试题 03.06. 动物收容所</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AnimalShelf() : head(<span class="keyword">new</span> Node()), tail(<span class="keyword">new</span> Node()) &#123;</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; animal)</span> </span>&#123;</span><br><span class="line">        push(animal[<span class="number">0</span>], animal[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dequeueAny</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail-&gt;prev == head)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret&#123;tail-&gt;prev-&gt;num, tail-&gt;prev-&gt;type&#125;;</span><br><span class="line">        deleteNode(tail-&gt;prev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dequeueDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = pop(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;ret, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dequeueCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = pop(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;ret, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Node* next;</span><br><span class="line">        Node* prev;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        Node() = <span class="keyword">default</span>;</span><br><span class="line">        Node(Node* next, Node* prev, <span class="keyword">int</span> num, <span class="keyword">int</span> type) : next(next), prev(prev), num(num), type(type) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span> Node(head-&gt;next, head, num, type);</span><br><span class="line">        next-&gt;prev = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> point = tail-&gt;prev;</span><br><span class="line">        <span class="keyword">while</span>(point != head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(point-&gt;type == type)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> ret = point-&gt;num;</span><br><span class="line">                deleteNode(point);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            point = point-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = node;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AnimalShelf object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AnimalShelf* obj = new AnimalShelf();</span></span><br><span class="line"><span class="comment"> * obj-&gt;enqueue(animal);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;dequeueAny();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_3 = obj-&gt;dequeueDog();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_4 = obj-&gt;dequeueCat();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.01. 节点间通路</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.01.%20%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="面试题-04.01.-节点间通路"><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路</a></h4>
<h5 id="bfs">##### BFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : graph)</span><br><span class="line">            <span class="built_in">map</span>[node[<span class="number">0</span>]].push_back(node[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = q.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                <span class="keyword">if</span>(p == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> next : <span class="built_in">map</span>[p])</span><br><span class="line">                    q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="dfs">DFS</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : graph)</span><br><span class="line">            <span class="built_in">map</span>[node[<span class="number">0</span>]].push_back(node[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dfs(start, target);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next : <span class="built_in">map</span>[cur])</span><br><span class="line">            <span class="keyword">if</span>(dfs(next, target))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>防止重复访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : graph)</span><br><span class="line">            <span class="built_in">map</span>[node[<span class="number">0</span>]].push_back(node[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dfs(start, target);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[cur])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next : <span class="built_in">map</span>[cur])</span><br><span class="line">            <span class="keyword">if</span>(dfs(next, target))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="不用hash直接用如图的graph">不用hash，直接用如图的graph</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(graph.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(start, target, graph);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][<span class="number">0</span>] == start &amp;&amp; graph[i][<span class="number">1</span>] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果[1]等于target那么[0]也可以到，所以成为新的target</span></span><br><span class="line">                <span class="keyword">if</span>(graph[i][<span class="number">1</span>] == target &amp;&amp; dfs(start, graph[i][<span class="number">0</span>], graph))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                visited[i] = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回溯，防止重复访问，然后缩短结尾区间。 // 缩短开头理论上也行</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.02. 最小高度树</title>
    <url>/2021/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.02.%20%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<h4 id="面试题-04.02.-最小高度树"><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a></h4>
<p>逆向inorder-traversal</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = helper(nums, lo, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.03. 特定深度节点链表</title>
    <url>/2021/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.03.%20%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="面试题-04.03.-特定深度节点链表"><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/">面试题 04.03. 特定深度节点链表</a></h4>
<p>level-order traversal</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">listOfDepth</span><span class="params">(TreeNode* tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tree)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; ret;</span><br><span class="line">        q.push(tree);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp; </span><br><span class="line">            ListNode* pseudoHead = &amp;tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = q.size(); i &lt; j; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                pseudoHead-&gt;next = <span class="keyword">new</span> ListNode(p-&gt;val);</span><br><span class="line">                pseudoHead = pseudoHead-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.04. 检查平衡性</title>
    <url>/2021/07/21/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.04.%20%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7/</url>
    <content><![CDATA[<h4 id="面试题-04.04.-检查平衡性"><a href="https://leetcode-cn.com/problems/check-balance-lcci/">面试题 04.04. 检查平衡性</a></h4>
<p>bottom-up</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        check(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = check(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = check(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left -right) &gt; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.06. 后继者</title>
    <url>/2021/07/23/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.06.%20%E5%90%8E%E7%BB%A7%E8%80%85/</url>
    <content><![CDATA[<h4 id="面试题-04.06.-后继者"><a href="https://leetcode-cn.com/problems/successor-lcci/">面试题 04.06. 后继者</a></h4>
<h5 id="中序遍历">中序遍历</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre == p)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="利用bst性质">利用bst性质</h5>
<p>后继节点是大于他中的最小的数</p>
<p>如果这个节点有右子树，后继节点就是右子树的最左边，如果没有，后继节点就是他路上最小的一个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; p-&gt;val &amp;&amp; (!ans || ans-&gt;val &gt; cur-&gt;val))</span><br><span class="line">                ans = cur; <span class="comment">// 记录路上大于p中最小的点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) <span class="comment">// 如果有右数，就返回右数中的最左边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span>(cur-&gt;left)</span><br><span class="line">                        cur = cur-&gt;left;</span><br><span class="line">                    <span class="keyword">return</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="comment">// 反之，返回路上的点</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;val &gt; p-&gt;val)</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 04.10. 检查子树</title>
    <url>/2021/08/01/%E9%9D%A2%E8%AF%95%E9%A2%98%2004.10.%20%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h4 id="面试题-04.10.-检查子树"><a href="https://leetcode-cn.com/problems/check-subtree-lcci/">面试题 04.10. 检查子树</a></h4>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(t1);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(check(p, t2))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> !t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)</span><br><span class="line">            <span class="keyword">return</span> !t1;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(t1-&gt;left, t2-&gt;left) &amp;&amp; check(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> !t2;</span><br><span class="line">        <span class="keyword">return</span> check(t1, t2) || checkSubTree(t1-&gt;left, t2) || checkSubTree(t1-&gt;right, t2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> !t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)</span><br><span class="line">            <span class="keyword">return</span> !t1;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(t1-&gt;left, t2-&gt;left) &amp;&amp; check(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.02. 二进制数转字符串</title>
    <url>/2021/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.02.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="面试题-05.02.-二进制数转字符串"><a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/">面试题 05.02. 二进制数转字符串</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;0.&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &amp;&amp; i++ &lt; <span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                ret.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.03. 翻转数位</title>
    <url>/2021/08/01/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.03.%20%E7%BF%BB%E8%BD%AC%E6%95%B0%E4%BD%8D/</url>
    <content><![CDATA[<h4 id="面试题-05.03.-翻转数位"><a href="https://leetcode-cn.com/problems/reverse-bits-lcci/">面试题 05.03. 翻转数位</a></h4>
<p>一个dp问题(我又菜起来了)</p>
<p>curSum记录当前遇到的连续的1。 curSumF记录翻转过后最长的连续1。</p>
<p>遇到0</p>
<p>​ curSum置0。</p>
<p>​ curSumF置为curSum+1，表示连接了前面一段。</p>
<p>遇到1</p>
<p>​ curSum和curSumF都加1。</p>
<p>因为curSum始终记录这前面一段连续1，所以设置为curSum+1后，如果后面还连续，就会自动更新连接这两段，如果后面为1，那就会清空为仅翻转当前位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curSumF = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; <span class="number">32</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++curSum;</span><br><span class="line">                ++curSumF;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curSumF = curSum + <span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>; <span class="comment">// 这里用右移，例如2147483647左移不让移</span></span><br><span class="line">            ret = max(ret, curSumF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似滑动窗口</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.04. 下一个数</title>
    <url>/2021/07/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.04.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="面试题-05.04.-下一个数"><a href="https://leetcode-cn.com/problems/closed-number-lcci/">面试题 05.04. 下一个数</a></h4>
<h5 id="真难">真难</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosedNumbers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> lastO = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastZ = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ju = num &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (ju)</span><br><span class="line">                ++lastO;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lastO != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lastZ = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastZ == <span class="number">-1</span>)</span><br><span class="line">            ret[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = num;</span><br><span class="line">            ret[<span class="number">0</span>] += <span class="number">1</span> &lt;&lt; lastZ; <span class="comment">// 将这个0变成1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastZ; ++i) <span class="comment">// 这个0右边所有位变成1</span></span><br><span class="line">                ret[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lastZ - <span class="number">1</span>; i &gt;= lastO - <span class="number">1</span>; --i)</span><br><span class="line">                ret[<span class="number">0</span>] -= <span class="number">1</span> &lt;&lt; i; <span class="comment">// 把0~k-1位保留1，其余各位变为0，就是把1放到最低位。</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastO = <span class="number">-1</span>;</span><br><span class="line">        lastZ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ju = num &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (ju == <span class="number">0</span>)</span><br><span class="line">                ++lastZ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lastZ != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lastO = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastO == <span class="number">-1</span>)</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">1</span>] = num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lastO; ++i) <span class="comment">// 把这个位及其右边所有1变成0</span></span><br><span class="line">                <span class="keyword">if</span> (ret[<span class="number">1</span>] &amp; <span class="number">1</span> &lt;&lt; i)</span><br><span class="line">                    ret[<span class="number">1</span>] ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lastO - <span class="number">1</span>; i &gt;= lastZ - <span class="number">1</span>; --i) <span class="comment">// 把所有1放到这个位右边的最高位上</span></span><br><span class="line">                ret[<span class="number">1</span>] += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原则:</p>
<p>对于小的数:</p>
<p>​ 找到最靠近低位的一个<code>1</code>，且这个1的右边还有0。将这个1变为0，这一位记为<code>i</code>，然后将这个1以及其右边的所有<code>1</code>(假设共有<code>k</code>个<code>1</code>)都移到<code>i - k ~  i - 1</code>的位置上(就是把1全都放到这个1右边的最高位)，如果在走完31个位后仍旧未找到这样一个1，那么就是不存在。</p>
<p>对于大的数:</p>
<p>​ 找到最靠近低位的一个<code>0</code>，且这个0的右边还有1。将这个0变为1，这一位记为<code>i</code>，然后将这个1右边的所有<code>1</code>(假设共有<code>k</code>个<code>1</code>)都移到<code>0 ~ k - 1</code>的位置上(就是把1全都放到这个位右边的最低位)，如果在走完31个位后仍旧未找到这样一个0，那么就是不存在。</p>
<h5 id="将循环位运算改为单步位运算">将循环位运算改为单步位运算</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosedNumbers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> lastO = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastZ = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ju = num &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (ju)</span><br><span class="line">                ++lastO;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lastO != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lastZ = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastZ == <span class="number">-1</span>)</span><br><span class="line">            ret[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = num;</span><br><span class="line">            ret[<span class="number">0</span>] += <span class="number">1</span> &lt;&lt; lastZ;</span><br><span class="line">            ret[<span class="number">0</span>] &amp;= ~((<span class="number">1</span> &lt;&lt; lastZ) - <span class="number">1</span>);</span><br><span class="line">            ret[<span class="number">0</span>] += (<span class="number">1</span> &lt;&lt; lastO - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastO = <span class="number">-1</span>;</span><br><span class="line">        lastZ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ju = num &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (ju == <span class="number">0</span>)</span><br><span class="line">                ++lastZ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lastZ != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lastO = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastO == <span class="number">-1</span>)</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">1</span>] = num;</span><br><span class="line">            ret[<span class="number">1</span>] ^= <span class="number">1</span> &lt;&lt; lastO;</span><br><span class="line">            ret[<span class="number">1</span>] |= (<span class="number">1</span> &lt;&lt; lastO) - <span class="number">1</span>;</span><br><span class="line">            ret[<span class="number">1</span>] -= (<span class="number">1</span> &lt;&lt; lastZ - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.06. 整数转换</title>
    <url>/2021/07/25/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.06.%20%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="面试题-05.06.-整数转换"><a href="https://leetcode-cn.com/problems/convert-integer-lcci/">面试题 05.06. 整数转换</a></h4>
<h5 id="位运算仅遍历1">位运算，仅遍历1</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> C = A ^ B; <span class="comment">// 由于有符号数的int只有31位表示数值，一位表示符号，所以转换成无符号数防止在负数的31个1减1后溢出(但是在vs中调试时，溢出后会变成有符号数的正数最大值，计算依旧成立)</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(C)</span><br><span class="line">        &#123;</span><br><span class="line">            C &amp;= C - <span class="number">1</span>;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.07. 配对交换</title>
    <url>/2021/07/25/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.07.%20%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="面试题-05.07.-配对交换"><a href="https://leetcode-cn.com/problems/exchange-lcci/">面试题 05.07. 配对交换</a></h4>
<h5 id="偶数位左移1奇数位右移1.">偶数位左移1，奇数位右移1.</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odd = num &amp; <span class="number">0xaaaaaaaa</span>; <span class="comment">// 1010...1010,提取奇数位</span></span><br><span class="line">        <span class="keyword">int</span> even = num &amp; <span class="number">0x55555555</span>; <span class="comment">// 0101...0101,提取偶数位</span></span><br><span class="line">        <span class="keyword">return</span> (even &lt;&lt; <span class="number">1</span>) | (odd &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 05.08. 绘制直线</title>
    <url>/2021/07/28/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.08.%20%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/</url>
    <content><![CDATA[<h4 id="面试题-05.08.-绘制直线"><a href="https://leetcode-cn.com/problems/draw-line-lcci/">面试题 05.08. 绘制直线</a></h4>
<p>题意可真难懂</p>
<p>给出的length表示一维int数组的长度，那么这个屏幕总共有<code>length * 32</code>位，每一位表示一个像素</p>
<p>而<code>w</code>表示每一行的宽度。例如，如果每行宽度为<code>96</code>，就表示这一行由3个int组成，在一维数组中占用3个元素。由此可以推算出高度为<code>w / 3</code>。</p>
<p>接下来进行位运算就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = length * <span class="number">32</span> / <span class="number">96</span>;</span><br><span class="line">        <span class="keyword">int</span> sh = w / <span class="number">32</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> startLine = x1 / <span class="number">32</span> + y * sh;</span><br><span class="line">        <span class="keyword">int</span> endLine = x2 / <span class="number">32</span> + y * sh;</span><br><span class="line">        x1 %= <span class="number">32</span>;</span><br><span class="line">        x2 %= <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startLine + <span class="number">1</span>; i &lt; endLine; ++i)</span><br><span class="line">            ret[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(startLine == endLine)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[startLine] += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1)) - <span class="number">1</span> - ((<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x2)) - <span class="number">1</span>);</span><br><span class="line">            ret[startLine] |= <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[startLine] |= <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1);</span><br><span class="line">            ret[startLine] += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1)) - <span class="number">1</span>;</span><br><span class="line">            ret[endLine] = ~((<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x2)) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稍微优化一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sh = w / <span class="number">32</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> startLine = x1 / <span class="number">32</span> + y * sh;</span><br><span class="line">        <span class="keyword">int</span> endLine = x2 / <span class="number">32</span> + y * sh;</span><br><span class="line">        x1 %= <span class="number">32</span>;</span><br><span class="line">        x2 %= <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startLine + <span class="number">1</span>; i &lt;= endLine; ++i)</span><br><span class="line">            ret[i] = <span class="number">-1</span>;</span><br><span class="line">        ret[startLine] |= <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1);</span><br><span class="line">        ret[startLine] += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x1)) - <span class="number">1</span>;</span><br><span class="line">        ret[endLine] &amp;= ~((<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - x2)) - <span class="number">1</span>); <span class="comment">// 这样子就可以不管startLine == endLine的情况了</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.01. 三步问题</title>
    <url>/2021/07/28/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.01.%20%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="面试题-08.01.-三步问题"><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/">面试题 08.01. 三步问题</a></h4>
<p>简单的dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            a = (c + b + a) % <span class="number">1000000007</span>;</span><br><span class="line">            swap(a, c);</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.03. 魔术索引</title>
    <url>/2021/08/04/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.03.%20%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="面试题-10.03.-搜索旋转数组"><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">面试题 10.03. 搜索旋转数组</a></h4>
<p><strong>easy的我都做不出了</strong></p>
<p>稍加优化的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; i) <span class="comment">// 重要，利用了递增序列的性质</span></span><br><span class="line">                i = nums[i] - <span class="number">1</span>; <span class="comment">// 如果nums[i] &gt; i，最好的情况是i后面直到正确答案都等于nums[i],这时候跳转过去就是正确答案，但是如果后面存在严格递增的子串，则正确答案一定再nums[i]位置后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="伪二分的dq">伪二分的DQ</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(nums, lo, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == mid) <span class="comment">// 如果中间的为mid，由于需要求最左，所以右边区间可以直接不算了</span></span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = helper(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.04. 幂集</title>
    <url>/2021/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.04.%20%E5%B9%82%E9%9B%86/</url>
    <content><![CDATA[<h4 id="面试题-08.04.-幂集"><a href="https://leetcode-cn.com/problems/power-set-lcci/">面试题 08.04. 幂集</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        backTrack(nums, ret, <span class="number">0</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ret.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, ret, i + <span class="number">1</span>, tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="section"></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        ret.push_back(&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> rett = ret;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : rett)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                ret.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="位">位</h5>
<p>一共length长的数组，每个数字看作是二进制0或1，当1时表示选这个数字，0为不选，那么子集一共有<code>2 ^ length</code>长</p>
<figure>
<img src="https://image.cinte.cc/2021/07/30/3d6104b0875d0.png" alt="1627634517255.png" /><figcaption aria-hidden="true">1627634517255.png</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span> &lt;&lt; nums.size(); <span class="comment">// 移位计算2的幂</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; i)</span><br><span class="line">                    tmp.push_back(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.05. 递归乘法</title>
    <url>/2021/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.05.%20%E9%80%92%E5%BD%92%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h4 id="面试题-08.05.-递归乘法"><a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/">面试题 08.05. 递归乘法</a></h4>
<p>又是一个我很菜的见证</p>
<h5 id="迭代">迭代</h5>
<p>二进制乘法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(B &amp; <span class="number">1</span>)</span><br><span class="line">                ret += A;</span><br><span class="line">            A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="递归">递归</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = B &amp; <span class="number">1</span> ? A : <span class="number">0</span>;</span><br><span class="line">        ret += multiply(A &lt;&lt; <span class="number">1</span>, B &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.07. 无重复字符串的排列组合</title>
    <url>/2021/08/04/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.07.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="面试题-08.07.-无重复字符串的排列组合"><a href="https://leetcode-cn.com/problems/permutation-i-lcci/">面试题 08.07. 无重复字符串的排列组合</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(S.size())</span></span>;</span><br><span class="line">        backTrack(ret, S, tmp, visited);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret, <span class="built_in">string</span>&amp; S, <span class="built_in">string</span>&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == S.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp += S[i];</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            backTrack(ret, S, tmp, visited);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.08. 有重复字符串的排列组合</title>
    <url>/2021/08/09/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.08.%20%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88.md%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="面试题-08.08.-有重复字符串的排列组合"><a href="https://leetcode-cn.com/problems/permutation-ii-lcci/">面试题 08.08. 有重复字符串的排列组合</a></h4>
<p>参考<a href="https://leetcode.cinte.cc/2021/03/25/47-Permutations-II/">(<em>´∇｀</em>) 被你发现啦~47. Permutations II | Cinte's Leetcode Record</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.10. 颜色填充</title>
    <url>/2021/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.10.%20%E9%A2%9C%E8%89%B2%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<h4 id="面试题-08.10.-颜色填充---力扣leetcode-leetcode-cn.com"><a href="https://leetcode-cn.com/problems/color-fill-lcci/">面试题 08.10. 颜色填充 - 力扣（LeetCode） (leetcode-cn.com)</a></h4>
<h5 id="dfs">dfs</h5>
<p>主要是要记录走过的点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        dfs(image, image[sr][sc], sr, sc);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; line : image)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pi : line)</span><br><span class="line">                <span class="keyword">if</span>(pi == <span class="number">-1</span>)</span><br><span class="line">                    pi = newColor;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> oldColor, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; image.size() - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; image[<span class="number">0</span>].size() - <span class="number">1</span> || image[i][j] != oldColor)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        image[i][j] = <span class="number">-1</span>;</span><br><span class="line">        dfs(image, oldColor, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(image, oldColor, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(image, oldColor, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(image, oldColor, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        dfs(image, newColor, image[sr][sc], sr, sc);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oldColor, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; image.size() - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; image[<span class="number">0</span>].size() - <span class="number">1</span> || image[i][j] != oldColor || image[i][j] == newColor) <span class="comment">// 新旧color如果相同，就没必要走了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        image[i][j] = newColor;</span><br><span class="line">        dfs(image, newColor, oldColor, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(image, newColor, oldColor, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(image, newColor, oldColor, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(image, newColor, oldColor, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="bfs">bfs</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;sr, sc&#125;);</span><br><span class="line">        <span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.first &lt; <span class="number">0</span> || p.first &gt;= image.size() || p.second &lt; <span class="number">0</span> || p.second &gt;= image[<span class="number">0</span>].size() || image[p.first][p.second] != oldColor)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            image[p.first][p.second] = newColor;</span><br><span class="line">            q.push(&#123;p.first + <span class="number">1</span>, p.second&#125;);</span><br><span class="line">            q.push(&#123;p.first - <span class="number">1</span>, p.second&#125;);</span><br><span class="line">            q.push(&#123;p.first, p.second + <span class="number">1</span>&#125;);</span><br><span class="line">            q.push(&#123;p.first, p.second - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.11. 硬币</title>
    <url>/2021/08/01/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.11.%20%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h4 id="面试题-08.11.-硬币"><a href="https://leetcode-cn.com/problems/coin-lcci/">面试题 08.11. 硬币</a></h4>
<p>设<code>F(i, v)</code>为前<code>i</code>种面值硬币构成面额为<code>v</code>的方案数。</p>
<p>(题中<code>i</code>为4，且面额为<code>[1, 5, 10, 25]</code>)</p>
<p>将第<code>i</code>个面额记为<code>c_i</code></p>
<p>则转移方程 <span class="math display">\[
F(i, v) = F(i - 1, v - 1 * c_i) + F(i - 1, v - 2 * c_i) + ... + F(i - 1, v - v/c_i * c_i)
\]</span></p>
<p>这是一个纵轴为采用的硬币种类，横轴为面额，内部值为方案数的表格</p>
<p><img src="https://image.cinte.cc/2021/08/02/7610cb05b7f9d.jpg" width="304" height="228"></p>
<p>以上的原始版本的代码实现</p>
<details>
<summary>
以上的原始版本的代码实现
</summary>
<pre><code>
class Solution &#123;
public:
    int waysToChange(int n) &#123;
        int coins[4]&#123;1, 5, 10, 25&#125;;
        vector<vector<int>> dp(5, vector<int>(n + 1, 0));
        dp[0][0] = 1;
        for(int i = 1; i <= 4; ++i)
        &#123;
            dp[i][0] = 1;
            auto coin = coins[i - 1];
            for(int j = 1; j <= n; ++j)
            &#123;
                dp[i][j] = dp[i - 1][j];
                for(int k = 1; k <= j / coin; ++k)
                &#123;
                    dp[i][j] += dp[i - 1][j - k * coin];
                    dp[i][j] %= 1000000007;
                &#125;
            &#125;
        &#125;
        return dp.back().back();
    &#125;
&#125;;
</code></pre>
</details>
<p>但是<strong>超时了</strong></p>
<strong>进行对时间的优化</strong> <span class="math display">\[
F(i, v) = F(i - 1, v - 1 * c_i) + F(i - 1, v - 2 * c_i) + ... + F(i - 1, v - v/c_i * c_i)
\]</span> 图中标红的公式与 <span class="math display">\[
F(i, v - c_i) = F(i - 1, v - 2 * c_i) + ... + F(i - 1, v - v/c_i * c_i)
\]</span> 进行比较，发现相同，所以 <span class="math display">\[
F(i, v) = F(i - 1, v - 1 * c_i) + F(i, v - c_i)
\]</span> 于是就可以减少一层循环
<details>
<summary>
以上的优化时间版本的代码实现
</summary>
<pre><code>
class Solution &#123;
public:
    int waysToChange(int n) &#123;
        int coins[4]&#123;1, 5, 10, 25&#125;;
        vector<vector<int>> dp(5, vector<int>(n + 1, 0));
        dp[0][0] = 1;
        for(int i = 1; i <= 4; ++i)
        &#123;
            dp[i][0] = 1;
            auto coin = coins[i - 1];
            for(int j = 1; j <= n; ++j)
            &#123;
                dp[i][j] = dp[i - 1][j];
                if(j >= coin)
                    dp[i][j] += dp[i][j - coin];
                dp[i][j] %= 1000000007;
            &#125;
        &#125;
        return dp.back().back();
    &#125;
&#125;;
</code></pre>
</details>
<p><strong>对空间优化</strong></p>
<p>发现每次循环仅仅使用到了上一层的数据，因此可以将空间使用从二维减少到一维，就用常规的方式即可</p>
<p>最终版本的代码</p>
<p>T(n) : O(n)</p>
<p>S(n) : O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> coins[<span class="number">4</span>]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coin; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - coin];</span><br><span class="line">                dp[j] %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有数学方法，抄累了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.12. 八皇后</title>
    <url>/2021/08/04/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.12.%20%E5%85%AB%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h4 id="面试题-08.12.-八皇后"><a href="https://leetcode-cn.com/problems/eight-queens-lcci/">面试题 08.12. 八皇后</a></h4>
<h5 id="backtrack">BackTrack</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        <span class="comment">// 从最后一行往前走</span></span><br><span class="line">        backTrack(ret, pos, n - <span class="number">1</span>, n, tmp);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos, <span class="keyword">int</span> curLine, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有行都走完了，就push入结果</span></span><br><span class="line">        <span class="keyword">if</span>(curLine &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(tmp); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">avl</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 记录已经被占用的位置</span></span><br><span class="line">        <span class="comment">// 遍历之前行，获取到不能放置的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; curLine; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            avl[pos[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> diff = i - curLine;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] - diff &gt;= <span class="number">0</span>)</span><br><span class="line">                avl[pos[i] - diff] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] + diff &lt; n)</span><br><span class="line">                avl[pos[i] + diff] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(avl[i]) <span class="comment">// 如果位置被占用了，就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pos[curLine] = i;</span><br><span class="line">            tmp.push_back(getLine(i, n));</span><br><span class="line">            backTrack(ret, pos, curLine - <span class="number">1</span>, n, tmp); <span class="comment">// 进入下一行</span></span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getLine</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j; j &lt; pos; ++j)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        line += <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt; n)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="solution">Solution</h5>
<p>以上对于已经占用的位置需要消耗掉O(n)的时间复杂度，但是可以观察到</p>
<p><strong>同一条斜线上的行和列之差或之和相等且独一无二</strong>，因此只需要记录之差和之和即可判断是否在同一斜线，时间复杂度降为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        backTrack(ret, pos, n - <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; lx;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; rx;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos, <span class="keyword">int</span> curLine, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curLine &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(getBoard(pos, n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i] || lx.find(i - curLine) != lx.end() || rx.find(i + curLine) != rx.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pos[curLine] = i;</span><br><span class="line">            col[i] = <span class="number">1</span>;</span><br><span class="line">            lx.insert(i - curLine); <span class="comment">// 记录向左上方的斜线，斜线上行列之差相等</span></span><br><span class="line">            rx.insert(i + curLine); <span class="comment">// 记录向右上方的斜线，斜线上行列之和相等</span></span><br><span class="line">            backTrack(ret, pos, curLine - <span class="number">1</span>, n);</span><br><span class="line">            col[i] = <span class="number">0</span>;</span><br><span class="line">            lx.erase(i - curLine);</span><br><span class="line">            rx.erase(i + curLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">getBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : pos)</span><br><span class="line">            ret.push_back(getLine(p, n));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getLine</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j; j &lt; pos; ++j)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        line += <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt; n)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n!)</p>
<p>S(n) : O(n)</p>
<h6 id="使用位运算优化sn为o1">使用位运算优化S(n)为O(1)</h6>
<p>左边斜线就是上几行皇后位置左移行之差次，右边斜线就是上几行皇后位置右移行之差次。</p>
<p>对于每行，获得左斜线就是左边值左移，右斜线就是右边值右移。即可</p>
<p>具体看<a href="https://leetcode-cn.com/problems/eight-queens-lcci/solution/ba-huang-hou-by-leetcode-solution/">解析</a></p>
<p><code>x &amp; (x - 1)</code>将最低位1置0</p>
<p><code>x &amp; -x</code>就是最低位1的位置</p>
<blockquote>
<p>二进制中相反数就是按位取反再加一，也就是说 x &amp; -x = x &amp; (~x + 1)，显然可以运算后只有最低位1可以保持1，其他都是0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ret;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">        backTrack(ret, pos, n - <span class="number">1</span>, n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos, <span class="keyword">int</span> curLine, <span class="keyword">int</span> n, <span class="keyword">int</span> col, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curLine &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(getBoard(pos, n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> alP = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(col | lx | rx));</span><br><span class="line">        <span class="keyword">while</span>(alP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lastZero = alP &amp; (~alP + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> po = __builtin_ctz(lastZero); <span class="comment">// gcc __buildin__函数，获取末尾0的数量，这里不能获取前导0，因为前导0会根据int为32位计算</span></span><br><span class="line">            alP &amp;= alP - <span class="number">1</span>; <span class="comment">// 去除最后一个1，继续</span></span><br><span class="line">            pos[curLine] = n - po - <span class="number">1</span>;</span><br><span class="line">            backTrack(ret, pos, curLine - <span class="number">1</span>, n, col | lastZero, (lx | lastZero) &lt;&lt; <span class="number">1</span>, (rx | lastZero) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">getBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : pos)</span><br><span class="line">            ret.push_back(getLine(p, n));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getLine</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j; j &lt; pos; ++j)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        line += <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt; n)</span><br><span class="line">            line += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>T(n) : O(n!)</p>
<p>S(n) : O(1)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.13. 堆箱子</title>
    <url>/2021/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.13.%20%E5%A0%86%E7%AE%B1%E5%AD%90/</url>
    <content><![CDATA[<h4 id="面试题-08.13.-堆箱子"><a href="https://leetcode-cn.com/problems/pile-box-lcci/">面试题 08.13. 堆箱子</a></h4>
<h5 id="on2算法">O(n^2)算法</h5>
<p>将箱子按照任意维度进行排序，那么答案毫无疑问就是子序列</p>
<p>对于每一个箱子来说，以他为顶的最高高度是在子序列之前所有符合条件的箱子堆出来的堆中最高的加上他自己的高度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; box)</span> </span>&#123;</span><br><span class="line">        sort(box.begin(), box.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b2)&#123; <span class="keyword">return</span> b1[<span class="number">2</span>] &lt; b2[<span class="number">2</span>]; &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(box.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = box[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; box.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = box[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                <span class="keyword">if</span>(box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + box[i][<span class="number">2</span>]);</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 10.01. 合并排序的数组</title>
    <url>/2021/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.01.%20%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="面试题-10.01.-合并排序的数组"><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">面试题 10.01. 合并排序的数组</a></h4>
<p>slot往前跑不可能跑的比ptA快，如果slot跑进A的原始领地，如果侵占了n个，那表示也用了n个A，所以A的指针永远在slot前</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slot = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ptA = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ptB = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptA &gt;= <span class="number">0</span> &amp;&amp; ptB &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[ptA] &gt; B[ptB])</span><br><span class="line">                A[slot--] = A[ptA--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[slot--] = B[ptB--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slot &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ptA &gt;= <span class="number">0</span>)</span><br><span class="line">                A[slot--] = A[ptA--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[slot--] = B[ptB--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 10.03. 搜索旋转数组</title>
    <url>/2021/08/02/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.03.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="面试题-10.03.-搜索旋转数组"><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">面试题 10.03. 搜索旋转数组</a></h4>
<p>边界条件真复杂。结合<a href="https://leetcode.cinte.cc/2021/06/16/剑指%20Offer%2011.%20旋转数组的最小数字/">剑指 Offer 11. 旋转数组的最小数字 | Cinte's Leetcode Record</a>思考</p>
<p>继续结合套路<a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/xuan-zhuan-shu-zu-cong-yi-dao-nan-ge-ge-dcv7a/">【旋转数组】从易到难，各个击破！ - 搜索旋转数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>对于一个旋转数组，分为2种，一种是出于旋转节点右边，一种是处于旋转节点左边。</p>
<p>当<code>arr[lo] == arr[target]</code>时，直接返回</p>
<p>当<code>arr[mid] &lt;= arr.back()</code>时，处于旋转节点右边</p>
<ol type="1">
<li><code>arr[mid] &gt; target</code> : 此时<code>target</code>必定处于旋转节点右边一部分，那么<code>hi = mid - 1</code></li>
<li><code>arr[mid] &lt; target</code> : 此时<code>target</code>有两种情况
<ol type="1">
<li><code>target &gt;= arr[0]</code> : 表示了<code>target</code>处于<code>0 ~ mid</code>，则<code>hi = mid - 1</code></li>
<li><code>target &lt; arr[0]</code> : 表示了<code>target</code>处于<code>mid ~</code>，则<code>lo = mid + 1</code></li>
</ol></li>
</ol>
<p>当<code>arr[mid] &gt; arr.back()</code>时，处于旋转节点左边</p>
<ol type="1">
<li><code>arr[mid] &lt; target</code> : 此时<code>target</code>必定位于旋转节点左边，是<code>lo = mid + 1</code></li>
<li><code>arr[mid] &gt; target</code> : 此时<code>target</code>有两种情况
<ol type="1">
<li><code>target &gt;= arr[0]</code> : 表示了<code>target</code>处于<code>0 ~ mid</code>，则<code>hi = mid - 1</code></li>
<li><code>target &lt; arr[0]</code> : 表示了<code>target</code>处于<code>mid ~</code>，则<code>lo = mid + 1</code></li>
</ol></li>
</ol>
<p><strong>重点</strong></p>
<p><code>arr[mid] == target</code>时，<code>hi = mid</code>，使其向左缩</p>
<p><strong>重点2</strong></p>
<p>当<code>arr[mid] == arr.back()</code>时，存在2种不确定的可能，对于这种情况需要单独处理，做法就是收缩区间。</p>
<p>那收缩区间是收缩<code>lo</code>还是<code>hi</code>呢，这里选择移动<code>lo</code>，因为所求的是最左的边界值，如果在前面没有返回的话，说明<code>arr[lo]</code>必定小于target，所以<code>++lo</code>后是安全的。</p>
<p>由此便可以进行二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[lo] == target)</span><br><span class="line">                <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; arr.back())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid] &gt; target)</span><br><span class="line">                    hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target &gt;= arr[<span class="number">0</span>])</span><br><span class="line">                        hi = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr.back())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid] &lt; target)</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= arr[<span class="number">0</span>])</span><br><span class="line">                        hi = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                ++lo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 16.02. 单词频率</title>
    <url>/2021/08/05/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.02.%20%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h4 id="面试题-16.01.-交换数字"><a href="https://leetcode-cn.com/problems/swap-numbers-lcci/">面试题 16.01. 交换数字</a></h4>
<h5 id="hashmap">hashmap</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordsFrequency</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WordsFrequency(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; book) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b : book)</span><br><span class="line">            ++<span class="built_in">map</span>[b];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[word];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordsFrequency object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordsFrequency* obj = new WordsFrequency(book);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="字典树前缀树trie">字典树(前缀树)(Trie)</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordsFrequency</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WordsFrequency(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; book) : root(<span class="keyword">new</span> Node()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b : book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pt = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!pt-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                    pt-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">                pt = pt-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ++pt-&gt;f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pt = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pt-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            pt = pt-&gt;childs[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pt-&gt;f;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Node* childs[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordsFrequency object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordsFrequency* obj = new WordsFrequency(book);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 16.04. 井字游戏</title>
    <url>/2021/08/06/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.04.%20%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="面试题-16.04.-井字游戏"><a href="https://leetcode-cn.com/problems/tic-tac-toe-lcci/">面试题 16.04. 井字游戏</a></h4>
<p>需要知道一个事实</p>
<p>不可能两个同时胜利的，平局的情况只有2个都输</p>
<p>然后每一列的记录，用异或，bang</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tictactoe</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> lxDiaX = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lxDiaO = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> rxDiaX = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> rxDiaO = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> rowX = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> rowO = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> colX = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> colO = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!lxDiaO)</span><br><span class="line">                lxDiaO = <span class="string">&#x27;O&#x27;</span> ^ board[i][i];</span><br><span class="line">            <span class="keyword">if</span>(!lxDiaX)</span><br><span class="line">                lxDiaX = <span class="string">&#x27;X&#x27;</span> ^ board[i][i];</span><br><span class="line">            <span class="keyword">if</span>(!rxDiaO)</span><br><span class="line">                rxDiaO = <span class="string">&#x27;O&#x27;</span> ^ board[i][n - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!rxDiaX)</span><br><span class="line">                rxDiaX = <span class="string">&#x27;X&#x27;</span> ^ board[i][n - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    pending = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!rowX)</span><br><span class="line">                    rowX = <span class="string">&#x27;X&#x27;</span> ^ board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(!rowO)</span><br><span class="line">                    rowO = <span class="string">&#x27;O&#x27;</span> ^ board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(!colX)</span><br><span class="line">                    colX = <span class="string">&#x27;X&#x27;</span> ^ board[j][i];</span><br><span class="line">                <span class="keyword">if</span>(!colO)</span><br><span class="line">                    colO = <span class="string">&#x27;O&#x27;</span> ^ board[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!rowX || !colX)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!rowO || !colO)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!lxDiaO || !rxDiaO)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!lxDiaX || !rxDiaX)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pending)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 16.06. 最小差</title>
    <url>/2021/08/09/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.06.%20%E6%9C%80%E5%B0%8F%E5%B7%AE/</url>
    <content><![CDATA[<h4 id="面试题-16.06.-最小差"><a href="https://leetcode-cn.com/problems/smallest-difference-lcci/">面试题 16.06. 最小差</a></h4>
<p>我菜炸了</p>
<h5 id="双指针">双指针</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.size(), n = b.size();</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        sort(b.begin(), b.end());</span><br><span class="line">        <span class="keyword">int</span> pa = <span class="number">0</span>, pb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = LONG_MAX;</span><br><span class="line">        <span class="keyword">while</span>(pa &lt; m &amp;&amp; pb &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = min(ret, <span class="built_in">abs</span>((<span class="keyword">long</span>)a[pa] - (<span class="keyword">long</span>)b[pb])); <span class="comment">// 注意int的溢出</span></span><br><span class="line">            <span class="keyword">if</span>(a[pa] &lt; b[pb]) <span class="comment">// 当这种情况时，如果要寻求一个更小的差，需要将a[pa]变大。变大后会出现新的a[pa] &gt; b[pb]或者a[pa] &lt; b[pb]的情况。因为如果此时变大b[pb]时，只会导致他们的差距yue&#x27;lai&#x27;yue</span></span><br><span class="line">                ++pa;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++pb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 16.07. 最大数值</title>
    <url>/2021/08/09/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.07.%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<h4 id="面试题-16.07.-最大数值"><a href="https://leetcode-cn.com/problems/maximum-lcci/">面试题 16.07. 最大数值</a></h4>
<h5 id="解法1">解法1</h5>
<p><span class="math display">\[
max(a, b) = (a + b + abs(a - b)) / 2;
\]</span></p>
<p>其中绝对值使用位运算代替，假设<code>a, b</code>为32位，则 <span class="math display">\[
abs(a) = ((a &gt;&gt; 31) \^{} a) - (a &gt;&gt; 31)
\]</span> c++中对有符号数的右移是算数右移</p>
<p>当<code>a &gt; 0</code>，<code>a &gt;&gt; 31 = 0x0000</code>，则<code>a &gt;&gt; 31 ^ a</code>就等于<code>a</code>，再减去<code>0x0000</code>还是a</p>
<p>当<code>a &lt; 0</code>，<code>a &gt;&gt; 31 = 0xFFFF</code>，则<code>a &gt;&gt; 31 ^ a</code>就等于<code>~a</code>，由于<code>0 - 0xFFFF = 1</code> ，所以最后是<code>~a + 1 = -a</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> la = a, lb = b;</span><br><span class="line">        <span class="keyword">return</span> ((la + lb) + (((la - lb) &gt;&gt; <span class="number">63</span>) ^ (la - lb)) - ((la - lb) &gt;&gt; <span class="number">63</span>)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解法2">解法2</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (<span class="keyword">long</span>)a - (<span class="keyword">long</span>)b; <span class="comment">// 求出差</span></span><br><span class="line">        <span class="keyword">int</span> k = d &gt;&gt; <span class="number">63</span>; <span class="comment">// 注意是有符号数右移，所以如果a&gt;b,k=0,如果a&lt;b,k=-1</span></span><br><span class="line">        <span class="comment">// k = 0时，= a</span></span><br><span class="line">        <span class="comment">// k = -1时，=-1 * -1 * b = b</span></span><br><span class="line">        <span class="keyword">return</span> (k + <span class="number">1</span>) * a - k * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解法3">解法3</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> aSign = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a &gt;&gt; <span class="number">31</span>; <span class="comment">// 只判断符号位，需要转为逻辑右移，否则移完会出现1</span></span><br><span class="line">       <span class="keyword">int</span> bSign = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)b &gt;&gt; <span class="number">31</span>;</span><br><span class="line">       <span class="keyword">int</span> diff = aSign ^ bSign; <span class="comment">// 相同为0，相异为1</span></span><br><span class="line">       <span class="comment">// 如果diff为1，异号，当k=0取a，反之取1，此时短路运算符||不会导致后面的溢出发生</span></span><br><span class="line">       <span class="comment">// diff为0，同号，运算时不会产生运算溢出，所以直接减然后取符号位，因为这里是逻辑与，所以无所谓算术右移逻辑右移</span></span><br><span class="line">       <span class="keyword">int</span> k = diff &amp;&amp; aSign || ((diff ^ <span class="number">1</span>) &amp;&amp; ((a - b) &gt;&gt; <span class="number">31</span>));</span><br><span class="line">       <span class="keyword">return</span> (k ^ <span class="number">1</span>) * a + k * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 16.10. 生存人数</title>
    <url>/2021/08/10/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.10.%20%E7%94%9F%E5%AD%98%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="面试题-16.10.-生存人数"><a href="https://leetcode-cn.com/problems/living-people-lcci/">面试题 16.10. 生存人数</a></h4>
<h5 id="dp">dp</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; birth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; death)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; born;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b : birth)</span><br><span class="line">            ++born[b];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; d : death)</span><br><span class="line">            ++dead[d];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">102</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">101</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> year = <span class="number">1900</span> + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当年活着的人只需要计算前一年的人数加上今年出生的和去年死亡的</span></span><br><span class="line">            <span class="comment">// 注意，今年死亡的人数仍旧属于今年生存，所以需要放到下一年计算</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + born[year] - dead[year - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLive)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLive = dp[i];</span><br><span class="line">                ret = year;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改用数组</p>
<p>在栈上分配空间比堆上更加高效</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; birth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; death)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> born[<span class="number">102</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dead[<span class="number">102</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b : birth)</span><br><span class="line">            ++born[b - <span class="number">1900</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; d : death)</span><br><span class="line">            ++dead[d - <span class="number">1900</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">102</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">101</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + born[i] - dead[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLive)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLive = dp[i];</span><br><span class="line">                ret = <span class="number">1900</span> + i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>差分数组，只记录每年的变化数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; birth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; death)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res[<span class="number">103</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; b : birth)</span><br><span class="line">            ++res[b - <span class="number">1900</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; d : death)</span><br><span class="line">            --res[d - <span class="number">1900</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> maxLive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">101</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] += res[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt; maxLive)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLive = res[i];</span><br><span class="line">                ret = <span class="number">1900</span> + i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
</search>
